var Ug = Object.defineProperty;
var Pg = (r, t, e) => t in r ? Ug(r, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : r[t] = e;
var Wt = (r, t, e) => (Pg(r, typeof t != "symbol" ? t + "" : t, e), e), Qa = (r, t, e) => {
  if (!t.has(r))
    throw TypeError("Cannot " + e);
};
var M = (r, t, e) => (Qa(r, t, "read from private field"), e ? e.call(r) : t.get(r)), je = (r, t, e) => {
  if (t.has(r))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(r) : t.set(r, e);
}, we = (r, t, e, A) => (Qa(r, t, "write to private field"), A ? A.call(r, e) : t.set(r, e), e);
var TA = (r, t, e) => (Qa(r, t, "access private method"), e);
var se = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Iu(r) {
  if (r.__esModule)
    return r;
  var t = r.default;
  if (typeof t == "function") {
    var e = function A() {
      return this instanceof A ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    e.prototype = t.prototype;
  } else
    e = {};
  return Object.defineProperty(e, "__esModule", { value: !0 }), Object.keys(r).forEach(function(A) {
    var n = Object.getOwnPropertyDescriptor(r, A);
    Object.defineProperty(e, A, n.get ? n : {
      enumerable: !0,
      get: function() {
        return r[A];
      }
    });
  }), e;
}
var Ba = {}, zt = {};
const Mg = {}, Lg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Mg
}, Symbol.toStringTag, { value: "Module" })), L = /* @__PURE__ */ Iu(Lg);
var Et = {};
Object.defineProperty(Et, "__esModule", { value: !0 });
Et.toCommandProperties = Et.toCommandValue = void 0;
function Hg(r) {
  return r == null ? "" : typeof r == "string" || r instanceof String ? r : JSON.stringify(r);
}
Et.toCommandValue = Hg;
function Gg(r) {
  return Object.keys(r).length ? {
    title: r.title,
    file: r.file,
    line: r.startLine,
    endLine: r.endLine,
    col: r.startColumn,
    endColumn: r.endColumn
  } : {};
}
Et.toCommandProperties = Gg;
var Wg = se && se.__createBinding || (Object.create ? function(r, t, e, A) {
  A === void 0 && (A = e), Object.defineProperty(r, A, { enumerable: !0, get: function() {
    return t[e];
  } });
} : function(r, t, e, A) {
  A === void 0 && (A = e), r[A] = t[e];
}), Yg = se && se.__setModuleDefault || (Object.create ? function(r, t) {
  Object.defineProperty(r, "default", { enumerable: !0, value: t });
} : function(r, t) {
  r.default = t;
}), Jg = se && se.__importStar || function(r) {
  if (r && r.__esModule)
    return r;
  var t = {};
  if (r != null)
    for (var e in r)
      e !== "default" && Object.hasOwnProperty.call(r, e) && Wg(t, r, e);
  return Yg(t, r), t;
};
Object.defineProperty(zt, "__esModule", { value: !0 });
zt.issue = zt.issueCommand = void 0;
const _g = Jg(L), du = Et;
function pu(r, t, e) {
  const A = new Og(r, t, e);
  process.stdout.write(A.toString() + _g.EOL);
}
zt.issueCommand = pu;
function xg(r, t = "") {
  pu(r, {}, t);
}
zt.issue = xg;
const _s = "::";
class Og {
  constructor(t, e, A) {
    t || (t = "missing.command"), this.command = t, this.properties = e, this.message = A;
  }
  toString() {
    let t = _s + this.command;
    if (this.properties && Object.keys(this.properties).length > 0) {
      t += " ";
      let e = !0;
      for (const A in this.properties)
        if (this.properties.hasOwnProperty(A)) {
          const n = this.properties[A];
          n && (e ? e = !1 : t += ",", t += `${A}=${jg(n)}`);
        }
    }
    return t += `${_s}${qg(this.message)}`, t;
  }
}
function qg(r) {
  return du.toCommandValue(r).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
}
function jg(r) {
  return du.toCommandValue(r).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
}
var er = {}, Tn, Vg = new Uint8Array(16);
function yu() {
  if (!Tn && (Tn = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !Tn))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Tn(Vg);
}
const $g = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function Qi(r) {
  return typeof r == "string" && $g.test(r);
}
var Ze = [];
for (var Ia = 0; Ia < 256; ++Ia)
  Ze.push((Ia + 256).toString(16).substr(1));
function Bi(r) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, e = (Ze[r[t + 0]] + Ze[r[t + 1]] + Ze[r[t + 2]] + Ze[r[t + 3]] + "-" + Ze[r[t + 4]] + Ze[r[t + 5]] + "-" + Ze[r[t + 6]] + Ze[r[t + 7]] + "-" + Ze[r[t + 8]] + Ze[r[t + 9]] + "-" + Ze[r[t + 10]] + Ze[r[t + 11]] + Ze[r[t + 12]] + Ze[r[t + 13]] + Ze[r[t + 14]] + Ze[r[t + 15]]).toLowerCase();
  if (!Qi(e))
    throw TypeError("Stringified UUID is invalid");
  return e;
}
var xs, da, pa = 0, ya = 0;
function Xg(r, t, e) {
  var A = t && e || 0, n = t || new Array(16);
  r = r || {};
  var i = r.node || xs, a = r.clockseq !== void 0 ? r.clockseq : da;
  if (i == null || a == null) {
    var o = r.random || (r.rng || yu)();
    i == null && (i = xs = [o[0] | 1, o[1], o[2], o[3], o[4], o[5]]), a == null && (a = da = (o[6] << 8 | o[7]) & 16383);
  }
  var s = r.msecs !== void 0 ? r.msecs : Date.now(), l = r.nsecs !== void 0 ? r.nsecs : ya + 1, c = s - pa + (l - ya) / 1e4;
  if (c < 0 && r.clockseq === void 0 && (a = a + 1 & 16383), (c < 0 || s > pa) && r.nsecs === void 0 && (l = 0), l >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  pa = s, ya = l, da = a, s += 122192928e5;
  var u = ((s & 268435455) * 1e4 + l) % 4294967296;
  n[A++] = u >>> 24 & 255, n[A++] = u >>> 16 & 255, n[A++] = u >>> 8 & 255, n[A++] = u & 255;
  var h = s / 4294967296 * 1e4 & 268435455;
  n[A++] = h >>> 8 & 255, n[A++] = h & 255, n[A++] = h >>> 24 & 15 | 16, n[A++] = h >>> 16 & 255, n[A++] = a >>> 8 | 128, n[A++] = a & 255;
  for (var g = 0; g < 6; ++g)
    n[A + g] = i[g];
  return t || Bi(n);
}
function mu(r) {
  if (!Qi(r))
    throw TypeError("Invalid UUID");
  var t, e = new Uint8Array(16);
  return e[0] = (t = parseInt(r.slice(0, 8), 16)) >>> 24, e[1] = t >>> 16 & 255, e[2] = t >>> 8 & 255, e[3] = t & 255, e[4] = (t = parseInt(r.slice(9, 13), 16)) >>> 8, e[5] = t & 255, e[6] = (t = parseInt(r.slice(14, 18), 16)) >>> 8, e[7] = t & 255, e[8] = (t = parseInt(r.slice(19, 23), 16)) >>> 8, e[9] = t & 255, e[10] = (t = parseInt(r.slice(24, 36), 16)) / 1099511627776 & 255, e[11] = t / 4294967296 & 255, e[12] = t >>> 24 & 255, e[13] = t >>> 16 & 255, e[14] = t >>> 8 & 255, e[15] = t & 255, e;
}
function Zg(r) {
  r = unescape(encodeURIComponent(r));
  for (var t = [], e = 0; e < r.length; ++e)
    t.push(r.charCodeAt(e));
  return t;
}
var Kg = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", zg = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function wu(r, t, e) {
  function A(n, i, a, o) {
    if (typeof n == "string" && (n = Zg(n)), typeof i == "string" && (i = mu(i)), i.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var s = new Uint8Array(16 + n.length);
    if (s.set(i), s.set(n, i.length), s = e(s), s[6] = s[6] & 15 | t, s[8] = s[8] & 63 | 128, a) {
      o = o || 0;
      for (var l = 0; l < 16; ++l)
        a[o + l] = s[l];
      return a;
    }
    return Bi(s);
  }
  try {
    A.name = r;
  } catch {
  }
  return A.DNS = Kg, A.URL = zg, A;
}
function eE(r) {
  if (typeof r == "string") {
    var t = unescape(encodeURIComponent(r));
    r = new Uint8Array(t.length);
    for (var e = 0; e < t.length; ++e)
      r[e] = t.charCodeAt(e);
  }
  return AE(tE(rE(r), r.length * 8));
}
function AE(r) {
  for (var t = [], e = r.length * 32, A = "0123456789abcdef", n = 0; n < e; n += 8) {
    var i = r[n >> 5] >>> n % 32 & 255, a = parseInt(A.charAt(i >>> 4 & 15) + A.charAt(i & 15), 16);
    t.push(a);
  }
  return t;
}
function vu(r) {
  return (r + 64 >>> 9 << 4) + 14 + 1;
}
function tE(r, t) {
  r[t >> 5] |= 128 << t % 32, r[vu(t) - 1] = t;
  for (var e = 1732584193, A = -271733879, n = -1732584194, i = 271733878, a = 0; a < r.length; a += 16) {
    var o = e, s = A, l = n, c = i;
    e = tA(e, A, n, i, r[a], 7, -680876936), i = tA(i, e, A, n, r[a + 1], 12, -389564586), n = tA(n, i, e, A, r[a + 2], 17, 606105819), A = tA(A, n, i, e, r[a + 3], 22, -1044525330), e = tA(e, A, n, i, r[a + 4], 7, -176418897), i = tA(i, e, A, n, r[a + 5], 12, 1200080426), n = tA(n, i, e, A, r[a + 6], 17, -1473231341), A = tA(A, n, i, e, r[a + 7], 22, -45705983), e = tA(e, A, n, i, r[a + 8], 7, 1770035416), i = tA(i, e, A, n, r[a + 9], 12, -1958414417), n = tA(n, i, e, A, r[a + 10], 17, -42063), A = tA(A, n, i, e, r[a + 11], 22, -1990404162), e = tA(e, A, n, i, r[a + 12], 7, 1804603682), i = tA(i, e, A, n, r[a + 13], 12, -40341101), n = tA(n, i, e, A, r[a + 14], 17, -1502002290), A = tA(A, n, i, e, r[a + 15], 22, 1236535329), e = rA(e, A, n, i, r[a + 1], 5, -165796510), i = rA(i, e, A, n, r[a + 6], 9, -1069501632), n = rA(n, i, e, A, r[a + 11], 14, 643717713), A = rA(A, n, i, e, r[a], 20, -373897302), e = rA(e, A, n, i, r[a + 5], 5, -701558691), i = rA(i, e, A, n, r[a + 10], 9, 38016083), n = rA(n, i, e, A, r[a + 15], 14, -660478335), A = rA(A, n, i, e, r[a + 4], 20, -405537848), e = rA(e, A, n, i, r[a + 9], 5, 568446438), i = rA(i, e, A, n, r[a + 14], 9, -1019803690), n = rA(n, i, e, A, r[a + 3], 14, -187363961), A = rA(A, n, i, e, r[a + 8], 20, 1163531501), e = rA(e, A, n, i, r[a + 13], 5, -1444681467), i = rA(i, e, A, n, r[a + 2], 9, -51403784), n = rA(n, i, e, A, r[a + 7], 14, 1735328473), A = rA(A, n, i, e, r[a + 12], 20, -1926607734), e = nA(e, A, n, i, r[a + 5], 4, -378558), i = nA(i, e, A, n, r[a + 8], 11, -2022574463), n = nA(n, i, e, A, r[a + 11], 16, 1839030562), A = nA(A, n, i, e, r[a + 14], 23, -35309556), e = nA(e, A, n, i, r[a + 1], 4, -1530992060), i = nA(i, e, A, n, r[a + 4], 11, 1272893353), n = nA(n, i, e, A, r[a + 7], 16, -155497632), A = nA(A, n, i, e, r[a + 10], 23, -1094730640), e = nA(e, A, n, i, r[a + 13], 4, 681279174), i = nA(i, e, A, n, r[a], 11, -358537222), n = nA(n, i, e, A, r[a + 3], 16, -722521979), A = nA(A, n, i, e, r[a + 6], 23, 76029189), e = nA(e, A, n, i, r[a + 9], 4, -640364487), i = nA(i, e, A, n, r[a + 12], 11, -421815835), n = nA(n, i, e, A, r[a + 15], 16, 530742520), A = nA(A, n, i, e, r[a + 2], 23, -995338651), e = iA(e, A, n, i, r[a], 6, -198630844), i = iA(i, e, A, n, r[a + 7], 10, 1126891415), n = iA(n, i, e, A, r[a + 14], 15, -1416354905), A = iA(A, n, i, e, r[a + 5], 21, -57434055), e = iA(e, A, n, i, r[a + 12], 6, 1700485571), i = iA(i, e, A, n, r[a + 3], 10, -1894986606), n = iA(n, i, e, A, r[a + 10], 15, -1051523), A = iA(A, n, i, e, r[a + 1], 21, -2054922799), e = iA(e, A, n, i, r[a + 8], 6, 1873313359), i = iA(i, e, A, n, r[a + 15], 10, -30611744), n = iA(n, i, e, A, r[a + 6], 15, -1560198380), A = iA(A, n, i, e, r[a + 13], 21, 1309151649), e = iA(e, A, n, i, r[a + 4], 6, -145523070), i = iA(i, e, A, n, r[a + 11], 10, -1120210379), n = iA(n, i, e, A, r[a + 2], 15, 718787259), A = iA(A, n, i, e, r[a + 9], 21, -343485551), e = lt(e, o), A = lt(A, s), n = lt(n, l), i = lt(i, c);
  }
  return [e, A, n, i];
}
function rE(r) {
  if (r.length === 0)
    return [];
  for (var t = r.length * 8, e = new Uint32Array(vu(t)), A = 0; A < t; A += 8)
    e[A >> 5] |= (r[A / 8] & 255) << A % 32;
  return e;
}
function lt(r, t) {
  var e = (r & 65535) + (t & 65535), A = (r >> 16) + (t >> 16) + (e >> 16);
  return A << 16 | e & 65535;
}
function nE(r, t) {
  return r << t | r >>> 32 - t;
}
function Ii(r, t, e, A, n, i) {
  return lt(nE(lt(lt(t, r), lt(A, i)), n), e);
}
function tA(r, t, e, A, n, i, a) {
  return Ii(t & e | ~t & A, r, t, n, i, a);
}
function rA(r, t, e, A, n, i, a) {
  return Ii(t & A | e & ~A, r, t, n, i, a);
}
function nA(r, t, e, A, n, i, a) {
  return Ii(t ^ e ^ A, r, t, n, i, a);
}
function iA(r, t, e, A, n, i, a) {
  return Ii(e ^ (t | ~A), r, t, n, i, a);
}
var iE = wu("v3", 48, eE);
const aE = iE;
function oE(r, t, e) {
  r = r || {};
  var A = r.random || (r.rng || yu)();
  if (A[6] = A[6] & 15 | 64, A[8] = A[8] & 63 | 128, t) {
    e = e || 0;
    for (var n = 0; n < 16; ++n)
      t[e + n] = A[n];
    return t;
  }
  return Bi(A);
}
function sE(r, t, e, A) {
  switch (r) {
    case 0:
      return t & e ^ ~t & A;
    case 1:
      return t ^ e ^ A;
    case 2:
      return t & e ^ t & A ^ e & A;
    case 3:
      return t ^ e ^ A;
  }
}
function ma(r, t) {
  return r << t | r >>> 32 - t;
}
function cE(r) {
  var t = [1518500249, 1859775393, 2400959708, 3395469782], e = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof r == "string") {
    var A = unescape(encodeURIComponent(r));
    r = [];
    for (var n = 0; n < A.length; ++n)
      r.push(A.charCodeAt(n));
  } else
    Array.isArray(r) || (r = Array.prototype.slice.call(r));
  r.push(128);
  for (var i = r.length / 4 + 2, a = Math.ceil(i / 16), o = new Array(a), s = 0; s < a; ++s) {
    for (var l = new Uint32Array(16), c = 0; c < 16; ++c)
      l[c] = r[s * 64 + c * 4] << 24 | r[s * 64 + c * 4 + 1] << 16 | r[s * 64 + c * 4 + 2] << 8 | r[s * 64 + c * 4 + 3];
    o[s] = l;
  }
  o[a - 1][14] = (r.length - 1) * 8 / Math.pow(2, 32), o[a - 1][14] = Math.floor(o[a - 1][14]), o[a - 1][15] = (r.length - 1) * 8 & 4294967295;
  for (var u = 0; u < a; ++u) {
    for (var h = new Uint32Array(80), g = 0; g < 16; ++g)
      h[g] = o[u][g];
    for (var d = 16; d < 80; ++d)
      h[d] = ma(h[d - 3] ^ h[d - 8] ^ h[d - 14] ^ h[d - 16], 1);
    for (var I = e[0], y = e[1], Q = e[2], E = e[3], B = e[4], w = 0; w < 80; ++w) {
      var C = Math.floor(w / 20), f = ma(I, 5) + sE(C, y, Q, E) + B + t[C] + h[w] >>> 0;
      B = E, E = Q, Q = ma(y, 30) >>> 0, y = I, I = f;
    }
    e[0] = e[0] + I >>> 0, e[1] = e[1] + y >>> 0, e[2] = e[2] + Q >>> 0, e[3] = e[3] + E >>> 0, e[4] = e[4] + B >>> 0;
  }
  return [e[0] >> 24 & 255, e[0] >> 16 & 255, e[0] >> 8 & 255, e[0] & 255, e[1] >> 24 & 255, e[1] >> 16 & 255, e[1] >> 8 & 255, e[1] & 255, e[2] >> 24 & 255, e[2] >> 16 & 255, e[2] >> 8 & 255, e[2] & 255, e[3] >> 24 & 255, e[3] >> 16 & 255, e[3] >> 8 & 255, e[3] & 255, e[4] >> 24 & 255, e[4] >> 16 & 255, e[4] >> 8 & 255, e[4] & 255];
}
var lE = wu("v5", 80, cE);
const uE = lE, hE = "00000000-0000-0000-0000-000000000000";
function gE(r) {
  if (!Qi(r))
    throw TypeError("Invalid UUID");
  return parseInt(r.substr(14, 1), 16);
}
const EE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: hE,
  parse: mu,
  stringify: Bi,
  v1: Xg,
  v3: aE,
  v4: oE,
  v5: uE,
  validate: Qi,
  version: gE
}, Symbol.toStringTag, { value: "Module" })), CE = /* @__PURE__ */ Iu(EE);
var fE = se && se.__createBinding || (Object.create ? function(r, t, e, A) {
  A === void 0 && (A = e), Object.defineProperty(r, A, { enumerable: !0, get: function() {
    return t[e];
  } });
} : function(r, t, e, A) {
  A === void 0 && (A = e), r[A] = t[e];
}), QE = se && se.__setModuleDefault || (Object.create ? function(r, t) {
  Object.defineProperty(r, "default", { enumerable: !0, value: t });
} : function(r, t) {
  r.default = t;
}), ku = se && se.__importStar || function(r) {
  if (r && r.__esModule)
    return r;
  var t = {};
  if (r != null)
    for (var e in r)
      e !== "default" && Object.hasOwnProperty.call(r, e) && fE(t, r, e);
  return QE(t, r), t;
};
Object.defineProperty(er, "__esModule", { value: !0 });
er.prepareKeyValueMessage = er.issueFileCommand = void 0;
const Os = ku(L), As = ku(L), BE = CE, bu = Et;
function IE(r, t) {
  const e = process.env[`GITHUB_${r}`];
  if (!e)
    throw new Error(`Unable to find environment variable for file command ${r}`);
  if (!Os.existsSync(e))
    throw new Error(`Missing file at path: ${e}`);
  Os.appendFileSync(e, `${bu.toCommandValue(t)}${As.EOL}`, {
    encoding: "utf8"
  });
}
er.issueFileCommand = IE;
function dE(r, t) {
  const e = `ghadelimiter_${BE.v4()}`, A = bu.toCommandValue(t);
  if (r.includes(e))
    throw new Error(`Unexpected input: name should not contain the delimiter "${e}"`);
  if (A.includes(e))
    throw new Error(`Unexpected input: value should not contain the delimiter "${e}"`);
  return `${r}<<${e}${As.EOL}${A}${As.EOL}${e}`;
}
er.prepareKeyValueMessage = dE;
var hr = {}, Xe = {}, Ar = {};
Object.defineProperty(Ar, "__esModule", { value: !0 });
Ar.checkBypass = Ar.getProxyUrl = void 0;
function pE(r) {
  const t = r.protocol === "https:";
  if (Tu(r))
    return;
  const e = t ? process.env.https_proxy || process.env.HTTPS_PROXY : process.env.http_proxy || process.env.HTTP_PROXY;
  if (e)
    try {
      return new URL(e);
    } catch {
      if (!e.startsWith("http://") && !e.startsWith("https://"))
        return new URL(`http://${e}`);
    }
  else
    return;
}
Ar.getProxyUrl = pE;
function Tu(r) {
  if (!r.hostname)
    return !1;
  const t = r.hostname;
  if (yE(t))
    return !0;
  const e = process.env.no_proxy || process.env.NO_PROXY || "";
  if (!e)
    return !1;
  let A;
  r.port ? A = Number(r.port) : r.protocol === "http:" ? A = 80 : r.protocol === "https:" && (A = 443);
  const n = [r.hostname.toUpperCase()];
  typeof A == "number" && n.push(`${n[0]}:${A}`);
  for (const i of e.split(",").map((a) => a.trim().toUpperCase()).filter((a) => a))
    if (i === "*" || n.some((a) => a === i || a.endsWith(`.${i}`) || i.startsWith(".") && a.endsWith(`${i}`)))
      return !0;
  return !1;
}
Ar.checkBypass = Tu;
function yE(r) {
  const t = r.toLowerCase();
  return t === "localhost" || t.startsWith("127.") || t.startsWith("[::1]") || t.startsWith("[0:0:0:0:0:0:0:1]");
}
var ar = {}, mE = L, ys = L, Fu = L, wE = L, vE = L;
ar.httpOverHttp = kE;
ar.httpsOverHttp = bE;
ar.httpOverHttps = TE;
ar.httpsOverHttps = FE;
function kE(r) {
  var t = new KA(r);
  return t.request = ys.request, t;
}
function bE(r) {
  var t = new KA(r);
  return t.request = ys.request, t.createSocket = Ru, t.defaultPort = 443, t;
}
function TE(r) {
  var t = new KA(r);
  return t.request = Fu.request, t;
}
function FE(r) {
  var t = new KA(r);
  return t.request = Fu.request, t.createSocket = Ru, t.defaultPort = 443, t;
}
function KA(r) {
  var t = this;
  t.options = r || {}, t.proxyOptions = t.options.proxy || {}, t.maxSockets = t.options.maxSockets || ys.Agent.defaultMaxSockets, t.requests = [], t.sockets = [], t.on("free", function(A, n, i, a) {
    for (var o = Du(n, i, a), s = 0, l = t.requests.length; s < l; ++s) {
      var c = t.requests[s];
      if (c.host === o.host && c.port === o.port) {
        t.requests.splice(s, 1), c.request.onSocket(A);
        return;
      }
    }
    A.destroy(), t.removeSocket(A);
  });
}
vE.inherits(KA, wE.EventEmitter);
KA.prototype.addRequest = function(t, e, A, n) {
  var i = this, a = ms({ request: t }, i.options, Du(e, A, n));
  if (i.sockets.length >= this.maxSockets) {
    i.requests.push(a);
    return;
  }
  i.createSocket(a, function(o) {
    o.on("free", s), o.on("close", l), o.on("agentRemove", l), t.onSocket(o);
    function s() {
      i.emit("free", o, a);
    }
    function l(c) {
      i.removeSocket(o), o.removeListener("free", s), o.removeListener("close", l), o.removeListener("agentRemove", l);
    }
  });
};
KA.prototype.createSocket = function(t, e) {
  var A = this, n = {};
  A.sockets.push(n);
  var i = ms({}, A.proxyOptions, {
    method: "CONNECT",
    path: t.host + ":" + t.port,
    agent: !1,
    headers: {
      host: t.host + ":" + t.port
    }
  });
  t.localAddress && (i.localAddress = t.localAddress), i.proxyAuth && (i.headers = i.headers || {}, i.headers["Proxy-Authorization"] = "Basic " + new Buffer(i.proxyAuth).toString("base64")), at("making CONNECT request");
  var a = A.request(i);
  a.useChunkedEncodingByDefault = !1, a.once("response", o), a.once("upgrade", s), a.once("connect", l), a.once("error", c), a.end();
  function o(u) {
    u.upgrade = !0;
  }
  function s(u, h, g) {
    process.nextTick(function() {
      l(u, h, g);
    });
  }
  function l(u, h, g) {
    if (a.removeAllListeners(), h.removeAllListeners(), u.statusCode !== 200) {
      at(
        "tunneling socket could not be established, statusCode=%d",
        u.statusCode
      ), h.destroy();
      var d = new Error("tunneling socket could not be established, statusCode=" + u.statusCode);
      d.code = "ECONNRESET", t.request.emit("error", d), A.removeSocket(n);
      return;
    }
    if (g.length > 0) {
      at("got illegal response body from proxy"), h.destroy();
      var d = new Error("got illegal response body from proxy");
      d.code = "ECONNRESET", t.request.emit("error", d), A.removeSocket(n);
      return;
    }
    return at("tunneling connection has established"), A.sockets[A.sockets.indexOf(n)] = h, e(h);
  }
  function c(u) {
    a.removeAllListeners(), at(
      `tunneling socket could not be established, cause=%s
`,
      u.message,
      u.stack
    );
    var h = new Error("tunneling socket could not be established, cause=" + u.message);
    h.code = "ECONNRESET", t.request.emit("error", h), A.removeSocket(n);
  }
};
KA.prototype.removeSocket = function(t) {
  var e = this.sockets.indexOf(t);
  if (e !== -1) {
    this.sockets.splice(e, 1);
    var A = this.requests.shift();
    A && this.createSocket(A, function(n) {
      A.request.onSocket(n);
    });
  }
};
function Ru(r, t) {
  var e = this;
  KA.prototype.createSocket.call(e, r, function(A) {
    var n = r.request.getHeader("host"), i = ms({}, e.options, {
      socket: A,
      servername: n ? n.replace(/:.*$/, "") : r.host
    }), a = mE.connect(0, i);
    e.sockets[e.sockets.indexOf(A)] = a, t(a);
  });
}
function Du(r, t, e) {
  return typeof r == "string" ? {
    host: r,
    port: t,
    localAddress: e
  } : r;
}
function ms(r) {
  for (var t = 1, e = arguments.length; t < e; ++t) {
    var A = arguments[t];
    if (typeof A == "object")
      for (var n = Object.keys(A), i = 0, a = n.length; i < a; ++i) {
        var o = n[i];
        A[o] !== void 0 && (r[o] = A[o]);
      }
  }
  return r;
}
var at;
process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG) ? at = function() {
  var r = Array.prototype.slice.call(arguments);
  typeof r[0] == "string" ? r[0] = "TUNNEL: " + r[0] : r.unshift("TUNNEL:"), console.error.apply(console, r);
} : at = function() {
};
ar.debug = at;
var RE = ar, ce = {}, Re = {
  kClose: Symbol("close"),
  kDestroy: Symbol("destroy"),
  kDispatch: Symbol("dispatch"),
  kUrl: Symbol("url"),
  kWriting: Symbol("writing"),
  kResuming: Symbol("resuming"),
  kQueue: Symbol("queue"),
  kConnect: Symbol("connect"),
  kConnecting: Symbol("connecting"),
  kHeadersList: Symbol("headers list"),
  kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
  kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
  kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
  kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
  kKeepAlive: Symbol("keep alive"),
  kHeadersTimeout: Symbol("headers timeout"),
  kBodyTimeout: Symbol("body timeout"),
  kServerName: Symbol("server name"),
  kLocalAddress: Symbol("local address"),
  kHost: Symbol("host"),
  kNoRef: Symbol("no ref"),
  kBodyUsed: Symbol("used"),
  kRunning: Symbol("running"),
  kBlocking: Symbol("blocking"),
  kPending: Symbol("pending"),
  kSize: Symbol("size"),
  kBusy: Symbol("busy"),
  kQueued: Symbol("queued"),
  kFree: Symbol("free"),
  kConnected: Symbol("connected"),
  kClosed: Symbol("closed"),
  kNeedDrain: Symbol("need drain"),
  kReset: Symbol("reset"),
  kDestroyed: Symbol.for("nodejs.stream.destroyed"),
  kMaxHeadersSize: Symbol("max headers size"),
  kRunningIdx: Symbol("running index"),
  kPendingIdx: Symbol("pending index"),
  kError: Symbol("error"),
  kClients: Symbol("clients"),
  kClient: Symbol("client"),
  kParser: Symbol("parser"),
  kOnDestroyed: Symbol("destroy callbacks"),
  kPipelining: Symbol("pipelining"),
  kSocket: Symbol("socket"),
  kHostHeader: Symbol("host header"),
  kConnector: Symbol("connector"),
  kStrictContentLength: Symbol("strict content length"),
  kMaxRedirections: Symbol("maxRedirections"),
  kMaxRequests: Symbol("maxRequestsPerClient"),
  kProxy: Symbol("proxy agent options"),
  kCounter: Symbol("socket request counter"),
  kInterceptors: Symbol("dispatch interceptors"),
  kMaxResponseSize: Symbol("max response size"),
  kHTTP2Session: Symbol("http2Session"),
  kHTTP2SessionState: Symbol("http2Session state"),
  kHTTP2BuildRequest: Symbol("http2 build request"),
  kHTTP1BuildRequest: Symbol("http1 build request"),
  kHTTP2CopyHeaders: Symbol("http2 copy headers"),
  kHTTPConnVersion: Symbol("http connection version"),
  kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
  kConstruct: Symbol("constructable")
};
let $e = class extends Error {
  constructor(t) {
    super(t), this.name = "UndiciError", this.code = "UND_ERR";
  }
}, DE = class Nu extends $e {
  constructor(t) {
    super(t), Error.captureStackTrace(this, Nu), this.name = "ConnectTimeoutError", this.message = t || "Connect Timeout Error", this.code = "UND_ERR_CONNECT_TIMEOUT";
  }
}, NE = class Su extends $e {
  constructor(t) {
    super(t), Error.captureStackTrace(this, Su), this.name = "HeadersTimeoutError", this.message = t || "Headers Timeout Error", this.code = "UND_ERR_HEADERS_TIMEOUT";
  }
}, SE = class Uu extends $e {
  constructor(t) {
    super(t), Error.captureStackTrace(this, Uu), this.name = "HeadersOverflowError", this.message = t || "Headers Overflow Error", this.code = "UND_ERR_HEADERS_OVERFLOW";
  }
}, UE = class Pu extends $e {
  constructor(t) {
    super(t), Error.captureStackTrace(this, Pu), this.name = "BodyTimeoutError", this.message = t || "Body Timeout Error", this.code = "UND_ERR_BODY_TIMEOUT";
  }
}, PE = class Mu extends $e {
  constructor(t, e, A, n) {
    super(t), Error.captureStackTrace(this, Mu), this.name = "ResponseStatusCodeError", this.message = t || "Response Status Code Error", this.code = "UND_ERR_RESPONSE_STATUS_CODE", this.body = n, this.status = e, this.statusCode = e, this.headers = A;
  }
}, ME = class Lu extends $e {
  constructor(t) {
    super(t), Error.captureStackTrace(this, Lu), this.name = "InvalidArgumentError", this.message = t || "Invalid Argument Error", this.code = "UND_ERR_INVALID_ARG";
  }
}, LE = class Hu extends $e {
  constructor(t) {
    super(t), Error.captureStackTrace(this, Hu), this.name = "InvalidReturnValueError", this.message = t || "Invalid Return Value Error", this.code = "UND_ERR_INVALID_RETURN_VALUE";
  }
}, HE = class Gu extends $e {
  constructor(t) {
    super(t), Error.captureStackTrace(this, Gu), this.name = "AbortError", this.message = t || "Request aborted", this.code = "UND_ERR_ABORTED";
  }
}, GE = class Wu extends $e {
  constructor(t) {
    super(t), Error.captureStackTrace(this, Wu), this.name = "InformationalError", this.message = t || "Request information", this.code = "UND_ERR_INFO";
  }
}, WE = class Yu extends $e {
  constructor(t) {
    super(t), Error.captureStackTrace(this, Yu), this.name = "RequestContentLengthMismatchError", this.message = t || "Request body length does not match content-length header", this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
  }
}, YE = class Ju extends $e {
  constructor(t) {
    super(t), Error.captureStackTrace(this, Ju), this.name = "ResponseContentLengthMismatchError", this.message = t || "Response body length does not match content-length header", this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
  }
}, JE = class _u extends $e {
  constructor(t) {
    super(t), Error.captureStackTrace(this, _u), this.name = "ClientDestroyedError", this.message = t || "The client is destroyed", this.code = "UND_ERR_DESTROYED";
  }
}, _E = class xu extends $e {
  constructor(t) {
    super(t), Error.captureStackTrace(this, xu), this.name = "ClientClosedError", this.message = t || "The client is closed", this.code = "UND_ERR_CLOSED";
  }
}, xE = class Ou extends $e {
  constructor(t, e) {
    super(t), Error.captureStackTrace(this, Ou), this.name = "SocketError", this.message = t || "Socket error", this.code = "UND_ERR_SOCKET", this.socket = e;
  }
}, qu = class ju extends $e {
  constructor(t) {
    super(t), Error.captureStackTrace(this, ju), this.name = "NotSupportedError", this.message = t || "Not supported error", this.code = "UND_ERR_NOT_SUPPORTED";
  }
}, OE = class extends $e {
  constructor(t) {
    super(t), Error.captureStackTrace(this, qu), this.name = "MissingUpstreamError", this.message = t || "No upstream has been added to the BalancedPool", this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
  }
}, qE = class Vu extends Error {
  constructor(t, e, A) {
    super(t), Error.captureStackTrace(this, Vu), this.name = "HTTPParserError", this.code = e ? `HPE_${e}` : void 0, this.data = A ? A.toString() : void 0;
  }
}, jE = class $u extends $e {
  constructor(t) {
    super(t), Error.captureStackTrace(this, $u), this.name = "ResponseExceededMaxSizeError", this.message = t || "Response content exceeded max size", this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
  }
}, VE = class Xu extends $e {
  constructor(t, e, { headers: A, data: n }) {
    super(t), Error.captureStackTrace(this, Xu), this.name = "RequestRetryError", this.message = t || "Request retry error", this.code = "UND_ERR_REQ_RETRY", this.statusCode = e, this.data = n, this.headers = A;
  }
};
var ke = {
  HTTPParserError: qE,
  UndiciError: $e,
  HeadersTimeoutError: NE,
  HeadersOverflowError: SE,
  BodyTimeoutError: UE,
  RequestContentLengthMismatchError: WE,
  ConnectTimeoutError: DE,
  ResponseStatusCodeError: PE,
  InvalidArgumentError: ME,
  InvalidReturnValueError: LE,
  RequestAbortedError: HE,
  ClientDestroyedError: JE,
  ClientClosedError: _E,
  InformationalError: GE,
  SocketError: xE,
  NotSupportedError: qu,
  ResponseContentLengthMismatchError: YE,
  BalancedPoolMissingUpstreamError: OE,
  ResponseExceededMaxSizeError: jE,
  RequestRetryError: VE
};
const li = {}, ts = [
  "Accept",
  "Accept-Encoding",
  "Accept-Language",
  "Accept-Ranges",
  "Access-Control-Allow-Credentials",
  "Access-Control-Allow-Headers",
  "Access-Control-Allow-Methods",
  "Access-Control-Allow-Origin",
  "Access-Control-Expose-Headers",
  "Access-Control-Max-Age",
  "Access-Control-Request-Headers",
  "Access-Control-Request-Method",
  "Age",
  "Allow",
  "Alt-Svc",
  "Alt-Used",
  "Authorization",
  "Cache-Control",
  "Clear-Site-Data",
  "Connection",
  "Content-Disposition",
  "Content-Encoding",
  "Content-Language",
  "Content-Length",
  "Content-Location",
  "Content-Range",
  "Content-Security-Policy",
  "Content-Security-Policy-Report-Only",
  "Content-Type",
  "Cookie",
  "Cross-Origin-Embedder-Policy",
  "Cross-Origin-Opener-Policy",
  "Cross-Origin-Resource-Policy",
  "Date",
  "Device-Memory",
  "Downlink",
  "ECT",
  "ETag",
  "Expect",
  "Expect-CT",
  "Expires",
  "Forwarded",
  "From",
  "Host",
  "If-Match",
  "If-Modified-Since",
  "If-None-Match",
  "If-Range",
  "If-Unmodified-Since",
  "Keep-Alive",
  "Last-Modified",
  "Link",
  "Location",
  "Max-Forwards",
  "Origin",
  "Permissions-Policy",
  "Pragma",
  "Proxy-Authenticate",
  "Proxy-Authorization",
  "RTT",
  "Range",
  "Referer",
  "Referrer-Policy",
  "Refresh",
  "Retry-After",
  "Sec-WebSocket-Accept",
  "Sec-WebSocket-Extensions",
  "Sec-WebSocket-Key",
  "Sec-WebSocket-Protocol",
  "Sec-WebSocket-Version",
  "Server",
  "Server-Timing",
  "Service-Worker-Allowed",
  "Service-Worker-Navigation-Preload",
  "Set-Cookie",
  "SourceMap",
  "Strict-Transport-Security",
  "Supports-Loading-Mode",
  "TE",
  "Timing-Allow-Origin",
  "Trailer",
  "Transfer-Encoding",
  "Upgrade",
  "Upgrade-Insecure-Requests",
  "User-Agent",
  "Vary",
  "Via",
  "WWW-Authenticate",
  "X-Content-Type-Options",
  "X-DNS-Prefetch-Control",
  "X-Frame-Options",
  "X-Permitted-Cross-Domain-Policies",
  "X-Powered-By",
  "X-Requested-With",
  "X-XSS-Protection"
];
for (let r = 0; r < ts.length; ++r) {
  const t = ts[r], e = t.toLowerCase();
  li[t] = li[e] = e;
}
Object.setPrototypeOf(li, null);
var $E = {
  wellknownHeaderNames: ts,
  headerNameLowerCasedRecord: li
};
const Zu = L, { kDestroyed: Ku, kBodyUsed: qs } = Re, { IncomingMessage: XE } = L, tr = L, ZE = L, { InvalidArgumentError: Ke } = ke, { Blob: js } = L, ui = L, { stringify: KE } = L, { headerNameLowerCasedRecord: zE } = $E, [wa, Vs] = process.versions.node.split(".").map((r) => Number(r));
function eC() {
}
function ws(r) {
  return r && typeof r == "object" && typeof r.pipe == "function" && typeof r.on == "function";
}
function zu(r) {
  return js && r instanceof js || r && typeof r == "object" && (typeof r.stream == "function" || typeof r.arrayBuffer == "function") && /^(Blob|File)$/.test(r[Symbol.toStringTag]);
}
function AC(r, t) {
  if (r.includes("?") || r.includes("#"))
    throw new Error('Query params cannot be passed when url already contains "?" or "#".');
  const e = KE(t);
  return e && (r += "?" + e), r;
}
function eh(r) {
  if (typeof r == "string") {
    if (r = new URL(r), !/^https?:/.test(r.origin || r.protocol))
      throw new Ke("Invalid URL protocol: the URL must start with `http:` or `https:`.");
    return r;
  }
  if (!r || typeof r != "object")
    throw new Ke("Invalid URL: The URL argument must be a non-null object.");
  if (!/^https?:/.test(r.origin || r.protocol))
    throw new Ke("Invalid URL protocol: the URL must start with `http:` or `https:`.");
  if (!(r instanceof URL)) {
    if (r.port != null && r.port !== "" && !Number.isFinite(parseInt(r.port)))
      throw new Ke("Invalid URL: port must be a valid integer or a string representation of an integer.");
    if (r.path != null && typeof r.path != "string")
      throw new Ke("Invalid URL path: the path must be a string or null/undefined.");
    if (r.pathname != null && typeof r.pathname != "string")
      throw new Ke("Invalid URL pathname: the pathname must be a string or null/undefined.");
    if (r.hostname != null && typeof r.hostname != "string")
      throw new Ke("Invalid URL hostname: the hostname must be a string or null/undefined.");
    if (r.origin != null && typeof r.origin != "string")
      throw new Ke("Invalid URL origin: the origin must be a string or null/undefined.");
    const t = r.port != null ? r.port : r.protocol === "https:" ? 443 : 80;
    let e = r.origin != null ? r.origin : `${r.protocol}//${r.hostname}:${t}`, A = r.path != null ? r.path : `${r.pathname || ""}${r.search || ""}`;
    e.endsWith("/") && (e = e.substring(0, e.length - 1)), A && !A.startsWith("/") && (A = `/${A}`), r = new URL(e + A);
  }
  return r;
}
function tC(r) {
  if (r = eh(r), r.pathname !== "/" || r.search || r.hash)
    throw new Ke("invalid url");
  return r;
}
function rC(r) {
  if (r[0] === "[") {
    const e = r.indexOf("]");
    return Zu(e !== -1), r.substring(1, e);
  }
  const t = r.indexOf(":");
  return t === -1 ? r : r.substring(0, t);
}
function nC(r) {
  if (!r)
    return null;
  Zu.strictEqual(typeof r, "string");
  const t = rC(r);
  return ZE.isIP(t) ? "" : t;
}
function iC(r) {
  return JSON.parse(JSON.stringify(r));
}
function aC(r) {
  return r != null && typeof r[Symbol.asyncIterator] == "function";
}
function oC(r) {
  return r != null && (typeof r[Symbol.iterator] == "function" || typeof r[Symbol.asyncIterator] == "function");
}
function sC(r) {
  if (r == null)
    return 0;
  if (ws(r)) {
    const t = r._readableState;
    return t && t.objectMode === !1 && t.ended === !0 && Number.isFinite(t.length) ? t.length : null;
  } else {
    if (zu(r))
      return r.size != null ? r.size : null;
    if (th(r))
      return r.byteLength;
  }
  return null;
}
function vs(r) {
  return !r || !!(r.destroyed || r[Ku]);
}
function Ah(r) {
  const t = r && r._readableState;
  return vs(r) && t && !t.endEmitted;
}
function cC(r, t) {
  r == null || !ws(r) || vs(r) || (typeof r.destroy == "function" ? (Object.getPrototypeOf(r).constructor === XE && (r.socket = null), r.destroy(t)) : t && process.nextTick((e, A) => {
    e.emit("error", A);
  }, r, t), r.destroyed !== !0 && (r[Ku] = !0));
}
const lC = /timeout=(\d+)/;
function uC(r) {
  const t = r.toString().match(lC);
  return t ? parseInt(t[1], 10) * 1e3 : null;
}
function hC(r) {
  return zE[r] || r.toLowerCase();
}
function gC(r, t = {}) {
  if (!Array.isArray(r))
    return r;
  for (let e = 0; e < r.length; e += 2) {
    const A = r[e].toString().toLowerCase();
    let n = t[A];
    n ? (Array.isArray(n) || (n = [n], t[A] = n), n.push(r[e + 1].toString("utf8"))) : Array.isArray(r[e + 1]) ? t[A] = r[e + 1].map((i) => i.toString("utf8")) : t[A] = r[e + 1].toString("utf8");
  }
  return "content-length" in t && "content-disposition" in t && (t["content-disposition"] = Buffer.from(t["content-disposition"]).toString("latin1")), t;
}
function EC(r) {
  const t = [];
  let e = !1, A = -1;
  for (let n = 0; n < r.length; n += 2) {
    const i = r[n + 0].toString(), a = r[n + 1].toString("utf8");
    i.length === 14 && (i === "content-length" || i.toLowerCase() === "content-length") ? (t.push(i, a), e = !0) : i.length === 19 && (i === "content-disposition" || i.toLowerCase() === "content-disposition") ? A = t.push(i, a) - 1 : t.push(i, a);
  }
  return e && A !== -1 && (t[A] = Buffer.from(t[A]).toString("latin1")), t;
}
function th(r) {
  return r instanceof Uint8Array || Buffer.isBuffer(r);
}
function CC(r, t, e) {
  if (!r || typeof r != "object")
    throw new Ke("handler must be an object");
  if (typeof r.onConnect != "function")
    throw new Ke("invalid onConnect method");
  if (typeof r.onError != "function")
    throw new Ke("invalid onError method");
  if (typeof r.onBodySent != "function" && r.onBodySent !== void 0)
    throw new Ke("invalid onBodySent method");
  if (e || t === "CONNECT") {
    if (typeof r.onUpgrade != "function")
      throw new Ke("invalid onUpgrade method");
  } else {
    if (typeof r.onHeaders != "function")
      throw new Ke("invalid onHeaders method");
    if (typeof r.onData != "function")
      throw new Ke("invalid onData method");
    if (typeof r.onComplete != "function")
      throw new Ke("invalid onComplete method");
  }
}
function fC(r) {
  return !!(r && (tr.isDisturbed ? tr.isDisturbed(r) || r[qs] : r[qs] || r.readableDidRead || r._readableState && r._readableState.dataEmitted || Ah(r)));
}
function QC(r) {
  return !!(r && (tr.isErrored ? tr.isErrored(r) : /state: 'errored'/.test(
    ui.inspect(r)
  )));
}
function BC(r) {
  return !!(r && (tr.isReadable ? tr.isReadable(r) : /state: 'readable'/.test(
    ui.inspect(r)
  )));
}
function IC(r) {
  return {
    localAddress: r.localAddress,
    localPort: r.localPort,
    remoteAddress: r.remoteAddress,
    remotePort: r.remotePort,
    remoteFamily: r.remoteFamily,
    timeout: r.timeout,
    bytesWritten: r.bytesWritten,
    bytesRead: r.bytesRead
  };
}
async function* dC(r) {
  for await (const t of r)
    yield Buffer.isBuffer(t) ? t : Buffer.from(t);
}
let gr;
function pC(r) {
  if (gr || (gr = L.ReadableStream), gr.from)
    return gr.from(dC(r));
  let t;
  return new gr(
    {
      async start() {
        t = r[Symbol.asyncIterator]();
      },
      async pull(e) {
        const { done: A, value: n } = await t.next();
        if (A)
          queueMicrotask(() => {
            e.close();
          });
        else {
          const i = Buffer.isBuffer(n) ? n : Buffer.from(n);
          e.enqueue(new Uint8Array(i));
        }
        return e.desiredSize > 0;
      },
      async cancel(e) {
        await t.return();
      }
    },
    0
  );
}
function yC(r) {
  return r && typeof r == "object" && typeof r.append == "function" && typeof r.delete == "function" && typeof r.get == "function" && typeof r.getAll == "function" && typeof r.has == "function" && typeof r.set == "function" && r[Symbol.toStringTag] === "FormData";
}
function mC(r) {
  if (r) {
    if (typeof r.throwIfAborted == "function")
      r.throwIfAborted();
    else if (r.aborted) {
      const t = new Error("The operation was aborted");
      throw t.name = "AbortError", t;
    }
  }
}
function wC(r, t) {
  return "addEventListener" in r ? (r.addEventListener("abort", t, { once: !0 }), () => r.removeEventListener("abort", t)) : (r.addListener("abort", t), () => r.removeListener("abort", t));
}
const vC = !!String.prototype.toWellFormed;
function kC(r) {
  return vC ? `${r}`.toWellFormed() : ui.toUSVString ? ui.toUSVString(r) : `${r}`;
}
function bC(r) {
  if (r == null || r === "")
    return { start: 0, end: null, size: null };
  const t = r ? r.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
  return t ? {
    start: parseInt(t[1]),
    end: t[2] ? parseInt(t[2]) : null,
    size: t[3] ? parseInt(t[3]) : null
  } : null;
}
const rh = /* @__PURE__ */ Object.create(null);
rh.enumerable = !0;
var Ie = {
  kEnumerableProperty: rh,
  nop: eC,
  isDisturbed: fC,
  isErrored: QC,
  isReadable: BC,
  toUSVString: kC,
  isReadableAborted: Ah,
  isBlobLike: zu,
  parseOrigin: tC,
  parseURL: eh,
  getServerName: nC,
  isStream: ws,
  isIterable: oC,
  isAsyncIterable: aC,
  isDestroyed: vs,
  headerNameToString: hC,
  parseRawHeaders: EC,
  parseHeaders: gC,
  parseKeepAliveTimeout: uC,
  destroy: cC,
  bodyLength: sC,
  deepClone: iC,
  ReadableStreamFrom: pC,
  isBuffer: th,
  validateHandler: CC,
  getSocketInfo: IC,
  isFormDataLike: yC,
  buildURL: AC,
  throwIfAborted: mC,
  addAbortListener: wC,
  parseRangeHeader: bC,
  nodeMajor: wa,
  nodeMinor: Vs,
  nodeHasAutoSelectFamily: wa > 18 || wa === 18 && Vs >= 13,
  safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"]
};
let va = Date.now(), rt;
const nt = [];
function TC() {
  va = Date.now();
  let r = nt.length, t = 0;
  for (; t < r; ) {
    const e = nt[t];
    e.state === 0 ? e.state = va + e.delay : e.state > 0 && va >= e.state && (e.state = -1, e.callback(e.opaque)), e.state === -1 ? (e.state = -2, t !== r - 1 ? nt[t] = nt.pop() : nt.pop(), r -= 1) : t += 1;
  }
  nt.length > 0 && nh();
}
function nh() {
  rt && rt.refresh ? rt.refresh() : (clearTimeout(rt), rt = setTimeout(TC, 1e3), rt.unref && rt.unref());
}
class $s {
  constructor(t, e, A) {
    this.callback = t, this.delay = e, this.opaque = A, this.state = -2, this.refresh();
  }
  refresh() {
    this.state === -2 && (nt.push(this), (!rt || nt.length === 1) && nh()), this.state = 0;
  }
  clear() {
    this.state = -1;
  }
}
var FC = {
  setTimeout(r, t, e) {
    return t < 1e3 ? setTimeout(r, t, e) : new $s(r, t, e);
  },
  clearTimeout(r) {
    r instanceof $s ? r.clear() : clearTimeout(r);
  }
}, Yt = { exports: {} }, ka, Xs;
function ih() {
  if (Xs)
    return ka;
  Xs = 1;
  const r = L.EventEmitter, t = L.inherits;
  function e(A) {
    if (typeof A == "string" && (A = Buffer.from(A)), !Buffer.isBuffer(A))
      throw new TypeError("The needle has to be a String or a Buffer.");
    const n = A.length;
    if (n === 0)
      throw new Error("The needle cannot be an empty String/Buffer.");
    if (n > 256)
      throw new Error("The needle cannot have a length bigger than 256.");
    this.maxMatches = 1 / 0, this.matches = 0, this._occ = new Array(256).fill(n), this._lookbehind_size = 0, this._needle = A, this._bufpos = 0, this._lookbehind = Buffer.alloc(n);
    for (var i = 0; i < n - 1; ++i)
      this._occ[A[i]] = n - 1 - i;
  }
  return t(e, r), e.prototype.reset = function() {
    this._lookbehind_size = 0, this.matches = 0, this._bufpos = 0;
  }, e.prototype.push = function(A, n) {
    Buffer.isBuffer(A) || (A = Buffer.from(A, "binary"));
    const i = A.length;
    this._bufpos = n || 0;
    let a;
    for (; a !== i && this.matches < this.maxMatches; )
      a = this._sbmh_feed(A);
    return a;
  }, e.prototype._sbmh_feed = function(A) {
    const n = A.length, i = this._needle, a = i.length, o = i[a - 1];
    let s = -this._lookbehind_size, l;
    if (s < 0) {
      for (; s < 0 && s <= n - a; ) {
        if (l = this._sbmh_lookup_char(A, s + a - 1), l === o && this._sbmh_memcmp(A, s, a - 1))
          return this._lookbehind_size = 0, ++this.matches, this.emit("info", !0), this._bufpos = s + a;
        s += this._occ[l];
      }
      if (s < 0)
        for (; s < 0 && !this._sbmh_memcmp(A, s, n - s); )
          ++s;
      if (s >= 0)
        this.emit("info", !1, this._lookbehind, 0, this._lookbehind_size), this._lookbehind_size = 0;
      else {
        const c = this._lookbehind_size + s;
        return c > 0 && this.emit("info", !1, this._lookbehind, 0, c), this._lookbehind.copy(
          this._lookbehind,
          0,
          c,
          this._lookbehind_size - c
        ), this._lookbehind_size -= c, A.copy(this._lookbehind, this._lookbehind_size), this._lookbehind_size += n, this._bufpos = n, n;
      }
    }
    if (s += (s >= 0) * this._bufpos, A.indexOf(i, s) !== -1)
      return s = A.indexOf(i, s), ++this.matches, s > 0 ? this.emit("info", !0, A, this._bufpos, s) : this.emit("info", !0), this._bufpos = s + a;
    for (s = n - a; s < n && (A[s] !== i[0] || Buffer.compare(
      A.subarray(s, s + n - s),
      i.subarray(0, n - s)
    ) !== 0); )
      ++s;
    return s < n && (A.copy(this._lookbehind, 0, s, s + (n - s)), this._lookbehind_size = n - s), s > 0 && this.emit("info", !1, A, this._bufpos, s < n ? s : n), this._bufpos = n, n;
  }, e.prototype._sbmh_lookup_char = function(A, n) {
    return n < 0 ? this._lookbehind[this._lookbehind_size + n] : A[n];
  }, e.prototype._sbmh_memcmp = function(A, n, i) {
    for (var a = 0; a < i; ++a)
      if (this._sbmh_lookup_char(A, n + a) !== this._needle[a])
        return !1;
    return !0;
  }, ka = e, ka;
}
var ba, Zs;
function RC() {
  if (Zs)
    return ba;
  Zs = 1;
  const r = L.inherits, t = L.Readable;
  function e(A) {
    t.call(this, A);
  }
  return r(e, t), e.prototype._read = function(A) {
  }, ba = e, ba;
}
var Ta, Ks;
function ks() {
  return Ks || (Ks = 1, Ta = function(t, e, A) {
    if (!t || t[e] === void 0 || t[e] === null)
      return A;
    if (typeof t[e] != "number" || isNaN(t[e]))
      throw new TypeError("Limit " + e + " is not a valid number");
    return t[e];
  }), Ta;
}
var Fa, zs;
function DC() {
  if (zs)
    return Fa;
  zs = 1;
  const r = L.EventEmitter, t = L.inherits, e = ks(), A = ih(), n = Buffer.from(`\r
\r
`), i = /\r\n/g, a = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
  function o(s) {
    r.call(this), s = s || {};
    const l = this;
    this.nread = 0, this.maxed = !1, this.npairs = 0, this.maxHeaderPairs = e(s, "maxHeaderPairs", 2e3), this.maxHeaderSize = e(s, "maxHeaderSize", 80 * 1024), this.buffer = "", this.header = {}, this.finished = !1, this.ss = new A(n), this.ss.on("info", function(c, u, h, g) {
      u && !l.maxed && (l.nread + g - h >= l.maxHeaderSize ? (g = l.maxHeaderSize - l.nread + h, l.nread = l.maxHeaderSize, l.maxed = !0) : l.nread += g - h, l.buffer += u.toString("binary", h, g)), c && l._finish();
    });
  }
  return t(o, r), o.prototype.push = function(s) {
    const l = this.ss.push(s);
    if (this.finished)
      return l;
  }, o.prototype.reset = function() {
    this.finished = !1, this.buffer = "", this.header = {}, this.ss.reset();
  }, o.prototype._finish = function() {
    this.buffer && this._parseHeader(), this.ss.matches = this.ss.maxMatches;
    const s = this.header;
    this.header = {}, this.buffer = "", this.finished = !0, this.nread = this.npairs = 0, this.maxed = !1, this.emit("header", s);
  }, o.prototype._parseHeader = function() {
    if (this.npairs === this.maxHeaderPairs)
      return;
    const s = this.buffer.split(i), l = s.length;
    let c, u;
    for (var h = 0; h < l; ++h) {
      if (s[h].length === 0)
        continue;
      if ((s[h][0] === "	" || s[h][0] === " ") && u) {
        this.header[u][this.header[u].length - 1] += s[h];
        continue;
      }
      const g = s[h].indexOf(":");
      if (g === -1 || g === 0)
        return;
      if (c = a.exec(s[h]), u = c[1].toLowerCase(), this.header[u] = this.header[u] || [], this.header[u].push(c[2] || ""), ++this.npairs === this.maxHeaderPairs)
        break;
    }
  }, Fa = o, Fa;
}
var Ra, ec;
function ah() {
  if (ec)
    return Ra;
  ec = 1;
  const r = L.Writable, t = L.inherits, e = ih(), A = RC(), n = DC(), i = 45, a = Buffer.from("-"), o = Buffer.from(`\r
`), s = function() {
  };
  function l(c) {
    if (!(this instanceof l))
      return new l(c);
    if (r.call(this, c), !c || !c.headerFirst && typeof c.boundary != "string")
      throw new TypeError("Boundary required");
    typeof c.boundary == "string" ? this.setBoundary(c.boundary) : this._bparser = void 0, this._headerFirst = c.headerFirst, this._dashes = 0, this._parts = 0, this._finished = !1, this._realFinish = !1, this._isPreamble = !0, this._justMatched = !1, this._firstWrite = !0, this._inHeader = !0, this._part = void 0, this._cb = void 0, this._ignoreData = !1, this._partOpts = { highWaterMark: c.partHwm }, this._pause = !1;
    const u = this;
    this._hparser = new n(c), this._hparser.on("header", function(h) {
      u._inHeader = !1, u._part.emit("header", h);
    });
  }
  return t(l, r), l.prototype.emit = function(c) {
    if (c === "finish" && !this._realFinish) {
      if (!this._finished) {
        const u = this;
        process.nextTick(function() {
          if (u.emit("error", new Error("Unexpected end of multipart data")), u._part && !u._ignoreData) {
            const h = u._isPreamble ? "Preamble" : "Part";
            u._part.emit("error", new Error(h + " terminated early due to unexpected end of multipart data")), u._part.push(null), process.nextTick(function() {
              u._realFinish = !0, u.emit("finish"), u._realFinish = !1;
            });
            return;
          }
          u._realFinish = !0, u.emit("finish"), u._realFinish = !1;
        });
      }
    } else
      r.prototype.emit.apply(this, arguments);
  }, l.prototype._write = function(c, u, h) {
    if (!this._hparser && !this._bparser)
      return h();
    if (this._headerFirst && this._isPreamble) {
      this._part || (this._part = new A(this._partOpts), this.listenerCount("preamble") !== 0 ? this.emit("preamble", this._part) : this._ignore());
      const g = this._hparser.push(c);
      if (!this._inHeader && g !== void 0 && g < c.length)
        c = c.slice(g);
      else
        return h();
    }
    this._firstWrite && (this._bparser.push(o), this._firstWrite = !1), this._bparser.push(c), this._pause ? this._cb = h : h();
  }, l.prototype.reset = function() {
    this._part = void 0, this._bparser = void 0, this._hparser = void 0;
  }, l.prototype.setBoundary = function(c) {
    const u = this;
    this._bparser = new e(`\r
--` + c), this._bparser.on("info", function(h, g, d, I) {
      u._oninfo(h, g, d, I);
    });
  }, l.prototype._ignore = function() {
    this._part && !this._ignoreData && (this._ignoreData = !0, this._part.on("error", s), this._part.resume());
  }, l.prototype._oninfo = function(c, u, h, g) {
    let d;
    const I = this;
    let y = 0, Q, E = !0;
    if (!this._part && this._justMatched && u) {
      for (; this._dashes < 2 && h + y < g; )
        if (u[h + y] === i)
          ++y, ++this._dashes;
        else {
          this._dashes && (d = a), this._dashes = 0;
          break;
        }
      if (this._dashes === 2 && (h + y < g && this.listenerCount("trailer") !== 0 && this.emit("trailer", u.slice(h + y, g)), this.reset(), this._finished = !0, I._parts === 0 && (I._realFinish = !0, I.emit("finish"), I._realFinish = !1)), this._dashes)
        return;
    }
    this._justMatched && (this._justMatched = !1), this._part || (this._part = new A(this._partOpts), this._part._read = function(B) {
      I._unpause();
    }, this._isPreamble && this.listenerCount("preamble") !== 0 ? this.emit("preamble", this._part) : this._isPreamble !== !0 && this.listenerCount("part") !== 0 ? this.emit("part", this._part) : this._ignore(), this._isPreamble || (this._inHeader = !0)), u && h < g && !this._ignoreData && (this._isPreamble || !this._inHeader ? (d && (E = this._part.push(d)), E = this._part.push(u.slice(h, g)), E || (this._pause = !0)) : !this._isPreamble && this._inHeader && (d && this._hparser.push(d), Q = this._hparser.push(u.slice(h, g)), !this._inHeader && Q !== void 0 && Q < g && this._oninfo(!1, u, h + Q, g))), c && (this._hparser.reset(), this._isPreamble ? this._isPreamble = !1 : h !== g && (++this._parts, this._part.on("end", function() {
      --I._parts === 0 && (I._finished ? (I._realFinish = !0, I.emit("finish"), I._realFinish = !1) : I._unpause());
    })), this._part.push(null), this._part = void 0, this._ignoreData = !1, this._justMatched = !0, this._dashes = 0);
  }, l.prototype._unpause = function() {
    if (this._pause && (this._pause = !1, this._cb)) {
      const c = this._cb;
      this._cb = void 0, c();
    }
  }, Ra = l, Ra;
}
var Da, Ac;
function bs() {
  if (Ac)
    return Da;
  Ac = 1;
  const r = new TextDecoder("utf-8"), t = /* @__PURE__ */ new Map([
    ["utf-8", r],
    ["utf8", r]
  ]);
  function e(i) {
    let a;
    for (; ; )
      switch (i) {
        case "utf-8":
        case "utf8":
          return A.utf8;
        case "latin1":
        case "ascii":
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return A.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return A.utf16le;
        case "base64":
          return A.base64;
        default:
          if (a === void 0) {
            a = !0, i = i.toLowerCase();
            continue;
          }
          return A.other.bind(i);
      }
  }
  const A = {
    utf8: (i, a) => i.length === 0 ? "" : (typeof i == "string" && (i = Buffer.from(i, a)), i.utf8Slice(0, i.length)),
    latin1: (i, a) => i.length === 0 ? "" : typeof i == "string" ? i : i.latin1Slice(0, i.length),
    utf16le: (i, a) => i.length === 0 ? "" : (typeof i == "string" && (i = Buffer.from(i, a)), i.ucs2Slice(0, i.length)),
    base64: (i, a) => i.length === 0 ? "" : (typeof i == "string" && (i = Buffer.from(i, a)), i.base64Slice(0, i.length)),
    other: (i, a) => {
      if (i.length === 0)
        return "";
      if (typeof i == "string" && (i = Buffer.from(i, a)), t.has(this.toString()))
        try {
          return t.get(this).decode(i);
        } catch {
        }
      return typeof i == "string" ? i : i.toString();
    }
  };
  function n(i, a, o) {
    return i && e(o)(i, a);
  }
  return Da = n, Da;
}
var Na, tc;
function oh() {
  if (tc)
    return Na;
  tc = 1;
  const r = bs(), t = /%[a-fA-F0-9][a-fA-F0-9]/g, e = {
    "%00": "\0",
    "%01": "",
    "%02": "",
    "%03": "",
    "%04": "",
    "%05": "",
    "%06": "",
    "%07": "\x07",
    "%08": "\b",
    "%09": "	",
    "%0a": `
`,
    "%0A": `
`,
    "%0b": "\v",
    "%0B": "\v",
    "%0c": "\f",
    "%0C": "\f",
    "%0d": "\r",
    "%0D": "\r",
    "%0e": "",
    "%0E": "",
    "%0f": "",
    "%0F": "",
    "%10": "",
    "%11": "",
    "%12": "",
    "%13": "",
    "%14": "",
    "%15": "",
    "%16": "",
    "%17": "",
    "%18": "",
    "%19": "",
    "%1a": "",
    "%1A": "",
    "%1b": "\x1B",
    "%1B": "\x1B",
    "%1c": "",
    "%1C": "",
    "%1d": "",
    "%1D": "",
    "%1e": "",
    "%1E": "",
    "%1f": "",
    "%1F": "",
    "%20": " ",
    "%21": "!",
    "%22": '"',
    "%23": "#",
    "%24": "$",
    "%25": "%",
    "%26": "&",
    "%27": "'",
    "%28": "(",
    "%29": ")",
    "%2a": "*",
    "%2A": "*",
    "%2b": "+",
    "%2B": "+",
    "%2c": ",",
    "%2C": ",",
    "%2d": "-",
    "%2D": "-",
    "%2e": ".",
    "%2E": ".",
    "%2f": "/",
    "%2F": "/",
    "%30": "0",
    "%31": "1",
    "%32": "2",
    "%33": "3",
    "%34": "4",
    "%35": "5",
    "%36": "6",
    "%37": "7",
    "%38": "8",
    "%39": "9",
    "%3a": ":",
    "%3A": ":",
    "%3b": ";",
    "%3B": ";",
    "%3c": "<",
    "%3C": "<",
    "%3d": "=",
    "%3D": "=",
    "%3e": ">",
    "%3E": ">",
    "%3f": "?",
    "%3F": "?",
    "%40": "@",
    "%41": "A",
    "%42": "B",
    "%43": "C",
    "%44": "D",
    "%45": "E",
    "%46": "F",
    "%47": "G",
    "%48": "H",
    "%49": "I",
    "%4a": "J",
    "%4A": "J",
    "%4b": "K",
    "%4B": "K",
    "%4c": "L",
    "%4C": "L",
    "%4d": "M",
    "%4D": "M",
    "%4e": "N",
    "%4E": "N",
    "%4f": "O",
    "%4F": "O",
    "%50": "P",
    "%51": "Q",
    "%52": "R",
    "%53": "S",
    "%54": "T",
    "%55": "U",
    "%56": "V",
    "%57": "W",
    "%58": "X",
    "%59": "Y",
    "%5a": "Z",
    "%5A": "Z",
    "%5b": "[",
    "%5B": "[",
    "%5c": "\\",
    "%5C": "\\",
    "%5d": "]",
    "%5D": "]",
    "%5e": "^",
    "%5E": "^",
    "%5f": "_",
    "%5F": "_",
    "%60": "`",
    "%61": "a",
    "%62": "b",
    "%63": "c",
    "%64": "d",
    "%65": "e",
    "%66": "f",
    "%67": "g",
    "%68": "h",
    "%69": "i",
    "%6a": "j",
    "%6A": "j",
    "%6b": "k",
    "%6B": "k",
    "%6c": "l",
    "%6C": "l",
    "%6d": "m",
    "%6D": "m",
    "%6e": "n",
    "%6E": "n",
    "%6f": "o",
    "%6F": "o",
    "%70": "p",
    "%71": "q",
    "%72": "r",
    "%73": "s",
    "%74": "t",
    "%75": "u",
    "%76": "v",
    "%77": "w",
    "%78": "x",
    "%79": "y",
    "%7a": "z",
    "%7A": "z",
    "%7b": "{",
    "%7B": "{",
    "%7c": "|",
    "%7C": "|",
    "%7d": "}",
    "%7D": "}",
    "%7e": "~",
    "%7E": "~",
    "%7f": "",
    "%7F": "",
    "%80": "",
    "%81": "",
    "%82": "",
    "%83": "",
    "%84": "",
    "%85": "",
    "%86": "",
    "%87": "",
    "%88": "",
    "%89": "",
    "%8a": "",
    "%8A": "",
    "%8b": "",
    "%8B": "",
    "%8c": "",
    "%8C": "",
    "%8d": "",
    "%8D": "",
    "%8e": "",
    "%8E": "",
    "%8f": "",
    "%8F": "",
    "%90": "",
    "%91": "",
    "%92": "",
    "%93": "",
    "%94": "",
    "%95": "",
    "%96": "",
    "%97": "",
    "%98": "",
    "%99": "",
    "%9a": "",
    "%9A": "",
    "%9b": "",
    "%9B": "",
    "%9c": "",
    "%9C": "",
    "%9d": "",
    "%9D": "",
    "%9e": "",
    "%9E": "",
    "%9f": "",
    "%9F": "",
    "%a0": "",
    "%A0": "",
    "%a1": "",
    "%A1": "",
    "%a2": "",
    "%A2": "",
    "%a3": "",
    "%A3": "",
    "%a4": "",
    "%A4": "",
    "%a5": "",
    "%A5": "",
    "%a6": "",
    "%A6": "",
    "%a7": "",
    "%A7": "",
    "%a8": "",
    "%A8": "",
    "%a9": "",
    "%A9": "",
    "%aa": "",
    "%Aa": "",
    "%aA": "",
    "%AA": "",
    "%ab": "",
    "%Ab": "",
    "%aB": "",
    "%AB": "",
    "%ac": "",
    "%Ac": "",
    "%aC": "",
    "%AC": "",
    "%ad": "",
    "%Ad": "",
    "%aD": "",
    "%AD": "",
    "%ae": "",
    "%Ae": "",
    "%aE": "",
    "%AE": "",
    "%af": "",
    "%Af": "",
    "%aF": "",
    "%AF": "",
    "%b0": "",
    "%B0": "",
    "%b1": "",
    "%B1": "",
    "%b2": "",
    "%B2": "",
    "%b3": "",
    "%B3": "",
    "%b4": "",
    "%B4": "",
    "%b5": "",
    "%B5": "",
    "%b6": "",
    "%B6": "",
    "%b7": "",
    "%B7": "",
    "%b8": "",
    "%B8": "",
    "%b9": "",
    "%B9": "",
    "%ba": "",
    "%Ba": "",
    "%bA": "",
    "%BA": "",
    "%bb": "",
    "%Bb": "",
    "%bB": "",
    "%BB": "",
    "%bc": "",
    "%Bc": "",
    "%bC": "",
    "%BC": "",
    "%bd": "",
    "%Bd": "",
    "%bD": "",
    "%BD": "",
    "%be": "",
    "%Be": "",
    "%bE": "",
    "%BE": "",
    "%bf": "",
    "%Bf": "",
    "%bF": "",
    "%BF": "",
    "%c0": "",
    "%C0": "",
    "%c1": "",
    "%C1": "",
    "%c2": "",
    "%C2": "",
    "%c3": "",
    "%C3": "",
    "%c4": "",
    "%C4": "",
    "%c5": "",
    "%C5": "",
    "%c6": "",
    "%C6": "",
    "%c7": "",
    "%C7": "",
    "%c8": "",
    "%C8": "",
    "%c9": "",
    "%C9": "",
    "%ca": "",
    "%Ca": "",
    "%cA": "",
    "%CA": "",
    "%cb": "",
    "%Cb": "",
    "%cB": "",
    "%CB": "",
    "%cc": "",
    "%Cc": "",
    "%cC": "",
    "%CC": "",
    "%cd": "",
    "%Cd": "",
    "%cD": "",
    "%CD": "",
    "%ce": "",
    "%Ce": "",
    "%cE": "",
    "%CE": "",
    "%cf": "",
    "%Cf": "",
    "%cF": "",
    "%CF": "",
    "%d0": "",
    "%D0": "",
    "%d1": "",
    "%D1": "",
    "%d2": "",
    "%D2": "",
    "%d3": "",
    "%D3": "",
    "%d4": "",
    "%D4": "",
    "%d5": "",
    "%D5": "",
    "%d6": "",
    "%D6": "",
    "%d7": "",
    "%D7": "",
    "%d8": "",
    "%D8": "",
    "%d9": "",
    "%D9": "",
    "%da": "",
    "%Da": "",
    "%dA": "",
    "%DA": "",
    "%db": "",
    "%Db": "",
    "%dB": "",
    "%DB": "",
    "%dc": "",
    "%Dc": "",
    "%dC": "",
    "%DC": "",
    "%dd": "",
    "%Dd": "",
    "%dD": "",
    "%DD": "",
    "%de": "",
    "%De": "",
    "%dE": "",
    "%DE": "",
    "%df": "",
    "%Df": "",
    "%dF": "",
    "%DF": "",
    "%e0": "",
    "%E0": "",
    "%e1": "",
    "%E1": "",
    "%e2": "",
    "%E2": "",
    "%e3": "",
    "%E3": "",
    "%e4": "",
    "%E4": "",
    "%e5": "",
    "%E5": "",
    "%e6": "",
    "%E6": "",
    "%e7": "",
    "%E7": "",
    "%e8": "",
    "%E8": "",
    "%e9": "",
    "%E9": "",
    "%ea": "",
    "%Ea": "",
    "%eA": "",
    "%EA": "",
    "%eb": "",
    "%Eb": "",
    "%eB": "",
    "%EB": "",
    "%ec": "",
    "%Ec": "",
    "%eC": "",
    "%EC": "",
    "%ed": "",
    "%Ed": "",
    "%eD": "",
    "%ED": "",
    "%ee": "",
    "%Ee": "",
    "%eE": "",
    "%EE": "",
    "%ef": "",
    "%Ef": "",
    "%eF": "",
    "%EF": "",
    "%f0": "",
    "%F0": "",
    "%f1": "",
    "%F1": "",
    "%f2": "",
    "%F2": "",
    "%f3": "",
    "%F3": "",
    "%f4": "",
    "%F4": "",
    "%f5": "",
    "%F5": "",
    "%f6": "",
    "%F6": "",
    "%f7": "",
    "%F7": "",
    "%f8": "",
    "%F8": "",
    "%f9": "",
    "%F9": "",
    "%fa": "",
    "%Fa": "",
    "%fA": "",
    "%FA": "",
    "%fb": "",
    "%Fb": "",
    "%fB": "",
    "%FB": "",
    "%fc": "",
    "%Fc": "",
    "%fC": "",
    "%FC": "",
    "%fd": "",
    "%Fd": "",
    "%fD": "",
    "%FD": "",
    "%fe": "",
    "%Fe": "",
    "%fE": "",
    "%FE": "",
    "%ff": "",
    "%Ff": "",
    "%fF": "",
    "%FF": ""
  };
  function A(l) {
    return e[l];
  }
  const n = 0, i = 1, a = 2, o = 3;
  function s(l) {
    const c = [];
    let u = n, h = "", g = !1, d = !1, I = 0, y = "";
    const Q = l.length;
    for (var E = 0; E < Q; ++E) {
      const B = l[E];
      if (B === "\\" && g)
        if (d)
          d = !1;
        else {
          d = !0;
          continue;
        }
      else if (B === '"')
        if (d)
          d = !1;
        else {
          g ? (g = !1, u = n) : g = !0;
          continue;
        }
      else if (d && g && (y += "\\"), d = !1, (u === a || u === o) && B === "'") {
        u === a ? (u = o, h = y.substring(1)) : u = i, y = "";
        continue;
      } else if (u === n && (B === "*" || B === "=") && c.length) {
        u = B === "*" ? a : i, c[I] = [y, void 0], y = "";
        continue;
      } else if (!g && B === ";") {
        u = n, h ? (y.length && (y = r(
          y.replace(t, A),
          "binary",
          h
        )), h = "") : y.length && (y = r(y, "binary", "utf8")), c[I] === void 0 ? c[I] = y : c[I][1] = y, y = "", ++I;
        continue;
      } else if (!g && (B === " " || B === "	"))
        continue;
      y += B;
    }
    return h && y.length ? y = r(
      y.replace(t, A),
      "binary",
      h
    ) : y && (y = r(y, "binary", "utf8")), c[I] === void 0 ? y && (c[I] = y) : c[I][1] = y, c;
  }
  return Na = s, Na;
}
var Sa, rc;
function NC() {
  return rc || (rc = 1, Sa = function(t) {
    if (typeof t != "string")
      return "";
    for (var e = t.length - 1; e >= 0; --e)
      switch (t.charCodeAt(e)) {
        case 47:
        case 92:
          return t = t.slice(e + 1), t === ".." || t === "." ? "" : t;
      }
    return t === ".." || t === "." ? "" : t;
  }), Sa;
}
var Ua, nc;
function SC() {
  if (nc)
    return Ua;
  nc = 1;
  const { Readable: r } = L, { inherits: t } = L, e = ah(), A = oh(), n = bs(), i = NC(), a = ks(), o = /^boundary$/i, s = /^form-data$/i, l = /^charset$/i, c = /^filename$/i, u = /^name$/i;
  h.detect = /^multipart\/form-data/i;
  function h(I, y) {
    let Q, E;
    const B = this;
    let w;
    const C = y.limits, f = y.isPartAFile || ((U, Y, O) => Y === "application/octet-stream" || O !== void 0), p = y.parsedConType || [], m = y.defCharset || "utf8", R = y.preservePath, P = { highWaterMark: y.fileHwm };
    for (Q = 0, E = p.length; Q < E; ++Q)
      if (Array.isArray(p[Q]) && o.test(p[Q][0])) {
        w = p[Q][1];
        break;
      }
    function N() {
      W === 0 && T && !I._done && (T = !1, B.end());
    }
    if (typeof w != "string")
      throw new Error("Multipart: Boundary not found");
    const $ = a(C, "fieldSize", 1 * 1024 * 1024), V = a(C, "fileSize", 1 / 0), ne = a(C, "files", 1 / 0), _ = a(C, "fields", 1 / 0), X = a(C, "parts", 1 / 0), te = a(C, "headerPairs", 2e3), ee = a(C, "headerSize", 80 * 1024);
    let Z = 0, b = 0, W = 0, v, F, T = !1;
    this._needDrain = !1, this._pause = !1, this._cb = void 0, this._nparts = 0, this._boy = I;
    const S = {
      boundary: w,
      maxHeaderPairs: te,
      maxHeaderSize: ee,
      partHwm: P.highWaterMark,
      highWaterMark: y.highWaterMark
    };
    this.parser = new e(S), this.parser.on("drain", function() {
      if (B._needDrain = !1, B._cb && !B._pause) {
        const U = B._cb;
        B._cb = void 0, U();
      }
    }).on("part", function U(Y) {
      if (++B._nparts > X)
        return B.parser.removeListener("part", U), B.parser.on("part", g), I.hitPartsLimit = !0, I.emit("partsLimit"), g(Y);
      if (F) {
        const O = F;
        O.emit("end"), O.removeAllListeners("end");
      }
      Y.on("header", function(O) {
        let j, H, ie, ye, Ee, He, be = 0;
        if (O["content-type"] && (ie = A(O["content-type"][0]), ie[0])) {
          for (j = ie[0].toLowerCase(), Q = 0, E = ie.length; Q < E; ++Q)
            if (l.test(ie[Q][0])) {
              ye = ie[Q][1].toLowerCase();
              break;
            }
        }
        if (j === void 0 && (j = "text/plain"), ye === void 0 && (ye = m), O["content-disposition"]) {
          if (ie = A(O["content-disposition"][0]), !s.test(ie[0]))
            return g(Y);
          for (Q = 0, E = ie.length; Q < E; ++Q)
            u.test(ie[Q][0]) ? H = ie[Q][1] : c.test(ie[Q][0]) && (He = ie[Q][1], R || (He = i(He)));
        } else
          return g(Y);
        O["content-transfer-encoding"] ? Ee = O["content-transfer-encoding"][0].toLowerCase() : Ee = "7bit";
        let De, Ge;
        if (f(H, j, He)) {
          if (Z === ne)
            return I.hitFilesLimit || (I.hitFilesLimit = !0, I.emit("filesLimit")), g(Y);
          if (++Z, I.listenerCount("file") === 0) {
            B.parser._ignore();
            return;
          }
          ++W;
          const Qe = new d(P);
          v = Qe, Qe.on("end", function() {
            if (--W, B._pause = !1, N(), B._cb && !B._needDrain) {
              const Ce = B._cb;
              B._cb = void 0, Ce();
            }
          }), Qe._read = function(Ce) {
            if (B._pause && (B._pause = !1, B._cb && !B._needDrain)) {
              const pe = B._cb;
              B._cb = void 0, pe();
            }
          }, I.emit("file", H, Qe, He, Ee, j), De = function(Ce) {
            if ((be += Ce.length) > V) {
              const pe = V - be + Ce.length;
              pe > 0 && Qe.push(Ce.slice(0, pe)), Qe.truncated = !0, Qe.bytesRead = V, Y.removeAllListeners("data"), Qe.emit("limit");
              return;
            } else
              Qe.push(Ce) || (B._pause = !0);
            Qe.bytesRead = be;
          }, Ge = function() {
            v = void 0, Qe.push(null);
          };
        } else {
          if (b === _)
            return I.hitFieldsLimit || (I.hitFieldsLimit = !0, I.emit("fieldsLimit")), g(Y);
          ++b, ++W;
          let Qe = "", Ce = !1;
          F = Y, De = function(pe) {
            if ((be += pe.length) > $) {
              const sA = $ - (be - pe.length);
              Qe += pe.toString("binary", 0, sA), Ce = !0, Y.removeAllListeners("data");
            } else
              Qe += pe.toString("binary");
          }, Ge = function() {
            F = void 0, Qe.length && (Qe = n(Qe, "binary", ye)), I.emit("field", H, Qe, !1, Ce, Ee, j), --W, N();
          };
        }
        Y._readableState.sync = !1, Y.on("data", De), Y.on("end", Ge);
      }).on("error", function(O) {
        v && v.emit("error", O);
      });
    }).on("error", function(U) {
      I.emit("error", U);
    }).on("finish", function() {
      T = !0, N();
    });
  }
  h.prototype.write = function(I, y) {
    const Q = this.parser.write(I);
    Q && !this._pause ? y() : (this._needDrain = !Q, this._cb = y);
  }, h.prototype.end = function() {
    const I = this;
    I.parser.writable ? I.parser.end() : I._boy._done || process.nextTick(function() {
      I._boy._done = !0, I._boy.emit("finish");
    });
  };
  function g(I) {
    I.resume();
  }
  function d(I) {
    r.call(this, I), this.bytesRead = 0, this.truncated = !1;
  }
  return t(d, r), d.prototype._read = function(I) {
  }, Ua = h, Ua;
}
var Pa, ic;
function UC() {
  if (ic)
    return Pa;
  ic = 1;
  const r = /\+/g, t = [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    1,
    1,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
  ];
  function e() {
    this.buffer = void 0;
  }
  return e.prototype.write = function(A) {
    A = A.replace(r, " ");
    let n = "", i = 0, a = 0;
    const o = A.length;
    for (; i < o; ++i)
      this.buffer !== void 0 ? t[A.charCodeAt(i)] ? (this.buffer += A[i], ++a, this.buffer.length === 2 && (n += String.fromCharCode(parseInt(this.buffer, 16)), this.buffer = void 0)) : (n += "%" + this.buffer, this.buffer = void 0, --i) : A[i] === "%" && (i > a && (n += A.substring(a, i), a = i), this.buffer = "", ++a);
    return a < o && this.buffer === void 0 && (n += A.substring(a)), n;
  }, e.prototype.reset = function() {
    this.buffer = void 0;
  }, Pa = e, Pa;
}
var Ma, ac;
function PC() {
  if (ac)
    return Ma;
  ac = 1;
  const r = UC(), t = bs(), e = ks(), A = /^charset$/i;
  n.detect = /^application\/x-www-form-urlencoded/i;
  function n(i, a) {
    const o = a.limits, s = a.parsedConType;
    this.boy = i, this.fieldSizeLimit = e(o, "fieldSize", 1 * 1024 * 1024), this.fieldNameSizeLimit = e(o, "fieldNameSize", 100), this.fieldsLimit = e(o, "fields", 1 / 0);
    let l;
    for (var c = 0, u = s.length; c < u; ++c)
      if (Array.isArray(s[c]) && A.test(s[c][0])) {
        l = s[c][1].toLowerCase();
        break;
      }
    l === void 0 && (l = a.defCharset || "utf8"), this.decoder = new r(), this.charset = l, this._fields = 0, this._state = "key", this._checkingBytes = !0, this._bytesKey = 0, this._bytesVal = 0, this._key = "", this._val = "", this._keyTrunc = !1, this._valTrunc = !1, this._hitLimit = !1;
  }
  return n.prototype.write = function(i, a) {
    if (this._fields === this.fieldsLimit)
      return this.boy.hitFieldsLimit || (this.boy.hitFieldsLimit = !0, this.boy.emit("fieldsLimit")), a();
    let o, s, l, c = 0;
    const u = i.length;
    for (; c < u; )
      if (this._state === "key") {
        for (o = s = void 0, l = c; l < u; ++l) {
          if (this._checkingBytes || ++c, i[l] === 61) {
            o = l;
            break;
          } else if (i[l] === 38) {
            s = l;
            break;
          }
          if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
            this._hitLimit = !0;
            break;
          } else
            this._checkingBytes && ++this._bytesKey;
        }
        if (o !== void 0)
          o > c && (this._key += this.decoder.write(i.toString("binary", c, o))), this._state = "val", this._hitLimit = !1, this._checkingBytes = !0, this._val = "", this._bytesVal = 0, this._valTrunc = !1, this.decoder.reset(), c = o + 1;
        else if (s !== void 0) {
          ++this._fields;
          let h;
          const g = this._keyTrunc;
          if (s > c ? h = this._key += this.decoder.write(i.toString("binary", c, s)) : h = this._key, this._hitLimit = !1, this._checkingBytes = !0, this._key = "", this._bytesKey = 0, this._keyTrunc = !1, this.decoder.reset(), h.length && this.boy.emit(
            "field",
            t(h, "binary", this.charset),
            "",
            g,
            !1
          ), c = s + 1, this._fields === this.fieldsLimit)
            return a();
        } else
          this._hitLimit ? (l > c && (this._key += this.decoder.write(i.toString("binary", c, l))), c = l, (this._bytesKey = this._key.length) === this.fieldNameSizeLimit && (this._checkingBytes = !1, this._keyTrunc = !0)) : (c < u && (this._key += this.decoder.write(i.toString("binary", c))), c = u);
      } else {
        for (s = void 0, l = c; l < u; ++l) {
          if (this._checkingBytes || ++c, i[l] === 38) {
            s = l;
            break;
          }
          if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
            this._hitLimit = !0;
            break;
          } else
            this._checkingBytes && ++this._bytesVal;
        }
        if (s !== void 0) {
          if (++this._fields, s > c && (this._val += this.decoder.write(i.toString("binary", c, s))), this.boy.emit(
            "field",
            t(this._key, "binary", this.charset),
            t(this._val, "binary", this.charset),
            this._keyTrunc,
            this._valTrunc
          ), this._state = "key", this._hitLimit = !1, this._checkingBytes = !0, this._key = "", this._bytesKey = 0, this._keyTrunc = !1, this.decoder.reset(), c = s + 1, this._fields === this.fieldsLimit)
            return a();
        } else
          this._hitLimit ? (l > c && (this._val += this.decoder.write(i.toString("binary", c, l))), c = l, (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) && (this._checkingBytes = !1, this._valTrunc = !0)) : (c < u && (this._val += this.decoder.write(i.toString("binary", c))), c = u);
      }
    a();
  }, n.prototype.end = function() {
    this.boy._done || (this._state === "key" && this._key.length > 0 ? this.boy.emit(
      "field",
      t(this._key, "binary", this.charset),
      "",
      this._keyTrunc,
      !1
    ) : this._state === "val" && this.boy.emit(
      "field",
      t(this._key, "binary", this.charset),
      t(this._val, "binary", this.charset),
      this._keyTrunc,
      this._valTrunc
    ), this.boy._done = !0, this.boy.emit("finish"));
  }, Ma = n, Ma;
}
var oc;
function MC() {
  if (oc)
    return Yt.exports;
  oc = 1;
  const r = L.Writable, { inherits: t } = L, e = ah(), A = SC(), n = PC(), i = oh();
  function a(o) {
    if (!(this instanceof a))
      return new a(o);
    if (typeof o != "object")
      throw new TypeError("Busboy expected an options-Object.");
    if (typeof o.headers != "object")
      throw new TypeError("Busboy expected an options-Object with headers-attribute.");
    if (typeof o.headers["content-type"] != "string")
      throw new TypeError("Missing Content-Type-header.");
    const {
      headers: s,
      ...l
    } = o;
    this.opts = {
      autoDestroy: !1,
      ...l
    }, r.call(this, this.opts), this._done = !1, this._parser = this.getParserByHeaders(s), this._finished = !1;
  }
  return t(a, r), a.prototype.emit = function(o) {
    var s;
    if (o === "finish") {
      if (this._done) {
        if (this._finished)
          return;
      } else {
        (s = this._parser) == null || s.end();
        return;
      }
      this._finished = !0;
    }
    r.prototype.emit.apply(this, arguments);
  }, a.prototype.getParserByHeaders = function(o) {
    const s = i(o["content-type"]), l = {
      defCharset: this.opts.defCharset,
      fileHwm: this.opts.fileHwm,
      headers: o,
      highWaterMark: this.opts.highWaterMark,
      isPartAFile: this.opts.isPartAFile,
      limits: this.opts.limits,
      parsedConType: s,
      preservePath: this.opts.preservePath
    };
    if (A.detect.test(s[0]))
      return new A(this, l);
    if (n.detect.test(s[0]))
      return new n(this, l);
    throw new Error("Unsupported Content-Type.");
  }, a.prototype._write = function(o, s, l) {
    this._parser.write(o, l);
  }, Yt.exports = a, Yt.exports.default = a, Yt.exports.Busboy = a, Yt.exports.Dicer = e, Yt.exports;
}
var La, sc;
function Mt() {
  if (sc)
    return La;
  sc = 1;
  const { MessageChannel: r, receiveMessageOnPort: t } = L, e = ["GET", "HEAD", "POST"], A = new Set(e), n = [101, 204, 205, 304], i = [301, 302, 303, 307, 308], a = new Set(i), o = [
    "1",
    "7",
    "9",
    "11",
    "13",
    "15",
    "17",
    "19",
    "20",
    "21",
    "22",
    "23",
    "25",
    "37",
    "42",
    "43",
    "53",
    "69",
    "77",
    "79",
    "87",
    "95",
    "101",
    "102",
    "103",
    "104",
    "109",
    "110",
    "111",
    "113",
    "115",
    "117",
    "119",
    "123",
    "135",
    "137",
    "139",
    "143",
    "161",
    "179",
    "389",
    "427",
    "465",
    "512",
    "513",
    "514",
    "515",
    "526",
    "530",
    "531",
    "532",
    "540",
    "548",
    "554",
    "556",
    "563",
    "587",
    "601",
    "636",
    "989",
    "990",
    "993",
    "995",
    "1719",
    "1720",
    "1723",
    "2049",
    "3659",
    "4045",
    "5060",
    "5061",
    "6000",
    "6566",
    "6665",
    "6666",
    "6667",
    "6668",
    "6669",
    "6697",
    "10080"
  ], s = new Set(o), l = [
    "",
    "no-referrer",
    "no-referrer-when-downgrade",
    "same-origin",
    "origin",
    "strict-origin",
    "origin-when-cross-origin",
    "strict-origin-when-cross-origin",
    "unsafe-url"
  ], c = new Set(l), u = ["follow", "manual", "error"], h = ["GET", "HEAD", "OPTIONS", "TRACE"], g = new Set(h), d = ["navigate", "same-origin", "no-cors", "cors"], I = ["omit", "same-origin", "include"], y = [
    "default",
    "no-store",
    "reload",
    "no-cache",
    "force-cache",
    "only-if-cached"
  ], Q = [
    "content-encoding",
    "content-language",
    "content-location",
    "content-type",
    // See https://github.com/nodejs/undici/issues/2021
    // 'Content-Length' is a forbidden header name, which is typically
    // removed in the Headers implementation. However, undici doesn't
    // filter out headers, so we add it here.
    "content-length"
  ], E = [
    "half"
  ], B = ["CONNECT", "TRACE", "TRACK"], w = new Set(B), C = [
    "audio",
    "audioworklet",
    "font",
    "image",
    "manifest",
    "paintworklet",
    "script",
    "style",
    "track",
    "video",
    "xslt",
    ""
  ], f = new Set(C), p = globalThis.DOMException ?? (() => {
    try {
      atob("~");
    } catch (P) {
      return Object.getPrototypeOf(P).constructor;
    }
  })();
  let m;
  const R = globalThis.structuredClone ?? // https://github.com/nodejs/node/blob/b27ae24dcc4251bad726d9d84baf678d1f707fed/lib/internal/structured_clone.js
  // structuredClone was added in v17.0.0, but fetch supports v16.8
  function(N, $ = void 0) {
    if (arguments.length === 0)
      throw new TypeError("missing argument");
    return m || (m = new r()), m.port1.unref(), m.port2.unref(), m.port1.postMessage(N, $ == null ? void 0 : $.transfer), t(m.port2).message;
  };
  return La = {
    DOMException: p,
    structuredClone: R,
    subresource: C,
    forbiddenMethods: B,
    requestBodyHeader: Q,
    referrerPolicy: l,
    requestRedirect: u,
    requestMode: d,
    requestCredentials: I,
    requestCache: y,
    redirectStatus: i,
    corsSafeListedMethods: e,
    nullBodyStatus: n,
    safeMethods: h,
    badPorts: o,
    requestDuplex: E,
    subresourceSet: f,
    badPortsSet: s,
    redirectStatusSet: a,
    corsSafeListedMethodsSet: A,
    safeMethodsSet: g,
    forbiddenMethodsSet: w,
    referrerPolicySet: c
  }, La;
}
var Ha, cc;
function fn() {
  if (cc)
    return Ha;
  cc = 1;
  const r = Symbol.for("undici.globalOrigin.1");
  function t() {
    return globalThis[r];
  }
  function e(A) {
    if (A === void 0) {
      Object.defineProperty(globalThis, r, {
        value: void 0,
        writable: !0,
        enumerable: !1,
        configurable: !1
      });
      return;
    }
    const n = new URL(A);
    if (n.protocol !== "http:" && n.protocol !== "https:")
      throw new TypeError(`Only http & https urls are allowed, received ${n.protocol}`);
    Object.defineProperty(globalThis, r, {
      value: n,
      writable: !0,
      enumerable: !1,
      configurable: !1
    });
  }
  return Ha = {
    getGlobalOrigin: t,
    setGlobalOrigin: e
  }, Ha;
}
var Ga, lc;
function NA() {
  if (lc)
    return Ga;
  lc = 1;
  const { redirectStatusSet: r, referrerPolicySet: t, badPortsSet: e } = Mt(), { getGlobalOrigin: A } = fn(), { performance: n } = L, { isBlobLike: i, toUSVString: a, ReadableStreamFrom: o } = Ie, s = L, { isUint8Array: l } = L;
  let c = [], u;
  try {
    u = L;
    const k = ["sha256", "sha384", "sha512"];
    c = u.getHashes().filter((J) => k.includes(J));
  } catch {
  }
  function h(k) {
    const J = k.urlList, K = J.length;
    return K === 0 ? null : J[K - 1].toString();
  }
  function g(k, J) {
    if (!r.has(k.status))
      return null;
    let K = k.headersList.get("location");
    return K !== null && C(K) && (K = new URL(K, h(k))), K && !K.hash && (K.hash = J), K;
  }
  function d(k) {
    return k.urlList[k.urlList.length - 1];
  }
  function I(k) {
    const J = d(k);
    return Ne(J) && e.has(J.port) ? "blocked" : "allowed";
  }
  function y(k) {
    var J, K;
    return k instanceof Error || ((J = k == null ? void 0 : k.constructor) == null ? void 0 : J.name) === "Error" || ((K = k == null ? void 0 : k.constructor) == null ? void 0 : K.name) === "DOMException";
  }
  function Q(k) {
    for (let J = 0; J < k.length; ++J) {
      const K = k.charCodeAt(J);
      if (!(K === 9 || // HTAB
      K >= 32 && K <= 126 || // SP / VCHAR
      K >= 128 && K <= 255))
        return !1;
    }
    return !0;
  }
  function E(k) {
    switch (k) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return !1;
      default:
        return k >= 33 && k <= 126;
    }
  }
  function B(k) {
    if (k.length === 0)
      return !1;
    for (let J = 0; J < k.length; ++J)
      if (!E(k.charCodeAt(J)))
        return !1;
    return !0;
  }
  function w(k) {
    return B(k);
  }
  function C(k) {
    return !(k.startsWith("	") || k.startsWith(" ") || k.endsWith("	") || k.endsWith(" ") || k.includes("\0") || k.includes("\r") || k.includes(`
`));
  }
  function f(k, J) {
    const { headersList: K } = J, oe = (K.get("referrer-policy") ?? "").split(",");
    let Be = "";
    if (oe.length > 0)
      for (let We = oe.length; We !== 0; We--) {
        const AA = oe[We - 1].trim();
        if (t.has(AA)) {
          Be = AA;
          break;
        }
      }
    Be !== "" && (k.referrerPolicy = Be);
  }
  function p() {
    return "allowed";
  }
  function m() {
    return "success";
  }
  function R() {
    return "success";
  }
  function P(k) {
    let J = null;
    J = k.mode, k.headersList.set("sec-fetch-mode", J);
  }
  function N(k) {
    let J = k.origin;
    if (k.responseTainting === "cors" || k.mode === "websocket")
      J && k.headersList.append("origin", J);
    else if (k.method !== "GET" && k.method !== "HEAD") {
      switch (k.referrerPolicy) {
        case "no-referrer":
          J = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          k.origin && ue(k.origin) && !ue(d(k)) && (J = null);
          break;
        case "same-origin":
          U(k, d(k)) || (J = null);
          break;
      }
      J && k.headersList.append("origin", J);
    }
  }
  function $(k) {
    return n.now();
  }
  function V(k) {
    return {
      startTime: k.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: k.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null
    };
  }
  function ne() {
    return {
      referrerPolicy: "strict-origin-when-cross-origin"
    };
  }
  function _(k) {
    return {
      referrerPolicy: k.referrerPolicy
    };
  }
  function X(k) {
    const J = k.referrerPolicy;
    s(J);
    let K = null;
    if (k.referrer === "client") {
      const EA = A();
      if (!EA || EA.origin === "null")
        return "no-referrer";
      K = new URL(EA);
    } else
      k.referrer instanceof URL && (K = k.referrer);
    let oe = te(K);
    const Be = te(K, !0);
    oe.toString().length > 4096 && (oe = Be);
    const We = U(k, oe), AA = ee(oe) && !ee(k.url);
    switch (J) {
      case "origin":
        return Be ?? te(K, !0);
      case "unsafe-url":
        return oe;
      case "same-origin":
        return We ? Be : "no-referrer";
      case "origin-when-cross-origin":
        return We ? oe : Be;
      case "strict-origin-when-cross-origin": {
        const EA = d(k);
        return U(oe, EA) ? oe : ee(oe) && !ee(EA) ? "no-referrer" : Be;
      }
      case "strict-origin":
      case "no-referrer-when-downgrade":
      default:
        return AA ? "no-referrer" : Be;
    }
  }
  function te(k, J) {
    return s(k instanceof URL), k.protocol === "file:" || k.protocol === "about:" || k.protocol === "blank:" ? "no-referrer" : (k.username = "", k.password = "", k.hash = "", J && (k.pathname = "", k.search = ""), k);
  }
  function ee(k) {
    if (!(k instanceof URL))
      return !1;
    if (k.href === "about:blank" || k.href === "about:srcdoc" || k.protocol === "data:" || k.protocol === "file:")
      return !0;
    return J(k.origin);
    function J(K) {
      if (K == null || K === "null")
        return !1;
      const oe = new URL(K);
      return !!(oe.protocol === "https:" || oe.protocol === "wss:" || /^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(oe.hostname) || oe.hostname === "localhost" || oe.hostname.includes("localhost.") || oe.hostname.endsWith(".localhost"));
    }
  }
  function Z(k, J) {
    if (u === void 0)
      return !0;
    const K = W(J);
    if (K === "no metadata" || K.length === 0)
      return !0;
    const oe = v(K), Be = F(K, oe);
    for (const We of Be) {
      const AA = We.algo, EA = We.hash;
      let cA = u.createHash(AA).update(k).digest("base64");
      if (cA[cA.length - 1] === "=" && (cA[cA.length - 2] === "=" ? cA = cA.slice(0, -2) : cA = cA.slice(0, -1)), T(cA, EA))
        return !0;
    }
    return !1;
  }
  const b = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
  function W(k) {
    const J = [];
    let K = !0;
    for (const oe of k.split(" ")) {
      K = !1;
      const Be = b.exec(oe);
      if (Be === null || Be.groups === void 0 || Be.groups.algo === void 0)
        continue;
      const We = Be.groups.algo.toLowerCase();
      c.includes(We) && J.push(Be.groups);
    }
    return K === !0 ? "no metadata" : J;
  }
  function v(k) {
    let J = k[0].algo;
    if (J[3] === "5")
      return J;
    for (let K = 1; K < k.length; ++K) {
      const oe = k[K];
      if (oe.algo[3] === "5") {
        J = "sha512";
        break;
      } else {
        if (J[3] === "3")
          continue;
        oe.algo[3] === "3" && (J = "sha384");
      }
    }
    return J;
  }
  function F(k, J) {
    if (k.length === 1)
      return k;
    let K = 0;
    for (let oe = 0; oe < k.length; ++oe)
      k[oe].algo === J && (k[K++] = k[oe]);
    return k.length = K, k;
  }
  function T(k, J) {
    if (k.length !== J.length)
      return !1;
    for (let K = 0; K < k.length; ++K)
      if (k[K] !== J[K]) {
        if (k[K] === "+" && J[K] === "-" || k[K] === "/" && J[K] === "_")
          continue;
        return !1;
      }
    return !0;
  }
  function S(k) {
  }
  function U(k, J) {
    return k.origin === J.origin && k.origin === "null" || k.protocol === J.protocol && k.hostname === J.hostname && k.port === J.port;
  }
  function Y() {
    let k, J;
    return { promise: new Promise((oe, Be) => {
      k = oe, J = Be;
    }), resolve: k, reject: J };
  }
  function O(k) {
    return k.controller.state === "aborted";
  }
  function j(k) {
    return k.controller.state === "aborted" || k.controller.state === "terminated";
  }
  const H = {
    delete: "DELETE",
    DELETE: "DELETE",
    get: "GET",
    GET: "GET",
    head: "HEAD",
    HEAD: "HEAD",
    options: "OPTIONS",
    OPTIONS: "OPTIONS",
    post: "POST",
    POST: "POST",
    put: "PUT",
    PUT: "PUT"
  };
  Object.setPrototypeOf(H, null);
  function ie(k) {
    return H[k.toLowerCase()] ?? k;
  }
  function ye(k) {
    const J = JSON.stringify(k);
    if (J === void 0)
      throw new TypeError("Value is not JSON serializable");
    return s(typeof J == "string"), J;
  }
  const Ee = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function He(k, J, K) {
    const oe = {
      index: 0,
      kind: K,
      target: k
    }, Be = {
      next() {
        if (Object.getPrototypeOf(this) !== Be)
          throw new TypeError(
            `'next' called on an object that does not implement interface ${J} Iterator.`
          );
        const { index: We, kind: AA, target: EA } = oe, cA = EA(), wn = cA.length;
        if (We >= wn)
          return { value: void 0, done: !0 };
        const vn = cA[We];
        return oe.index = We + 1, be(vn, AA);
      },
      // The class string of an iterator prototype object for a given interface is the
      // result of concatenating the identifier of the interface and the string " Iterator".
      [Symbol.toStringTag]: `${J} Iterator`
    };
    return Object.setPrototypeOf(Be, Ee), Object.setPrototypeOf({}, Be);
  }
  function be(k, J) {
    let K;
    switch (J) {
      case "key": {
        K = k[0];
        break;
      }
      case "value": {
        K = k[1];
        break;
      }
      case "key+value": {
        K = k;
        break;
      }
    }
    return { value: K, done: !1 };
  }
  async function De(k, J, K) {
    const oe = J, Be = K;
    let We;
    try {
      We = k.stream.getReader();
    } catch (AA) {
      Be(AA);
      return;
    }
    try {
      const AA = await ft(We);
      oe(AA);
    } catch (AA) {
      Be(AA);
    }
  }
  let Ge = globalThis.ReadableStream;
  function Qe(k) {
    return Ge || (Ge = L.ReadableStream), k instanceof Ge || k[Symbol.toStringTag] === "ReadableStream" && typeof k.tee == "function";
  }
  const Ce = 65535;
  function pe(k) {
    return k.length < Ce ? String.fromCharCode(...k) : k.reduce((J, K) => J + String.fromCharCode(K), "");
  }
  function sA(k) {
    try {
      k.close();
    } catch (J) {
      if (!J.message.includes("Controller is already closed"))
        throw J;
    }
  }
  function Lt(k) {
    for (let J = 0; J < k.length; J++)
      s(k.charCodeAt(J) <= 255);
    return k;
  }
  async function ft(k) {
    const J = [];
    let K = 0;
    for (; ; ) {
      const { done: oe, value: Be } = await k.read();
      if (oe)
        return Buffer.concat(J, K);
      if (!l(Be))
        throw new TypeError("Received non-Uint8Array chunk");
      J.push(Be), K += Be.length;
    }
  }
  function Ht(k) {
    s("protocol" in k);
    const J = k.protocol;
    return J === "about:" || J === "blob:" || J === "data:";
  }
  function ue(k) {
    return typeof k == "string" ? k.startsWith("https:") : k.protocol === "https:";
  }
  function Ne(k) {
    s("protocol" in k);
    const J = k.protocol;
    return J === "http:" || J === "https:";
  }
  const SA = Object.hasOwn || ((k, J) => Object.prototype.hasOwnProperty.call(k, J));
  return Ga = {
    isAborted: O,
    isCancelled: j,
    createDeferredPromise: Y,
    ReadableStreamFrom: o,
    toUSVString: a,
    tryUpgradeRequestToAPotentiallyTrustworthyURL: S,
    coarsenedSharedCurrentTime: $,
    determineRequestsReferrer: X,
    makePolicyContainer: ne,
    clonePolicyContainer: _,
    appendFetchMetadata: P,
    appendRequestOriginHeader: N,
    TAOCheck: R,
    corsCheck: m,
    crossOriginResourcePolicyCheck: p,
    createOpaqueTimingInfo: V,
    setRequestReferrerPolicyOnRedirect: f,
    isValidHTTPToken: B,
    requestBadPort: I,
    requestCurrentURL: d,
    responseURL: h,
    responseLocationURL: g,
    isBlobLike: i,
    isURLPotentiallyTrustworthy: ee,
    isValidReasonPhrase: Q,
    sameOrigin: U,
    normalizeMethod: ie,
    serializeJavascriptValueToJSONString: ye,
    makeIterator: He,
    isValidHeaderName: w,
    isValidHeaderValue: C,
    hasOwn: SA,
    isErrorLike: y,
    fullyReadBody: De,
    bytesMatch: Z,
    isReadableStreamLike: Qe,
    readableStreamClose: sA,
    isomorphicEncode: Lt,
    isomorphicDecode: pe,
    urlIsLocal: Ht,
    urlHasHttpsScheme: ue,
    urlIsHttpHttpsScheme: Ne,
    readAllBytes: ft,
    normalizeMethodRecord: H,
    parseMetadata: W
  }, Ga;
}
var Wa, uc;
function Ct() {
  return uc || (uc = 1, Wa = {
    kUrl: Symbol("url"),
    kHeaders: Symbol("headers"),
    kSignal: Symbol("signal"),
    kState: Symbol("state"),
    kGuard: Symbol("guard"),
    kRealm: Symbol("realm")
  }), Wa;
}
var Ya, hc;
function QA() {
  if (hc)
    return Ya;
  hc = 1;
  const { types: r } = L, { hasOwn: t, toUSVString: e } = NA(), A = {};
  return A.converters = {}, A.util = {}, A.errors = {}, A.errors.exception = function(n) {
    return new TypeError(`${n.header}: ${n.message}`);
  }, A.errors.conversionFailed = function(n) {
    const i = n.types.length === 1 ? "" : " one of", a = `${n.argument} could not be converted to${i}: ${n.types.join(", ")}.`;
    return A.errors.exception({
      header: n.prefix,
      message: a
    });
  }, A.errors.invalidArgument = function(n) {
    return A.errors.exception({
      header: n.prefix,
      message: `"${n.value}" is an invalid ${n.type}.`
    });
  }, A.brandCheck = function(n, i, a = void 0) {
    if ((a == null ? void 0 : a.strict) !== !1 && !(n instanceof i))
      throw new TypeError("Illegal invocation");
    return (n == null ? void 0 : n[Symbol.toStringTag]) === i.prototype[Symbol.toStringTag];
  }, A.argumentLengthCheck = function({ length: n }, i, a) {
    if (n < i)
      throw A.errors.exception({
        message: `${i} argument${i !== 1 ? "s" : ""} required, but${n ? " only" : ""} ${n} found.`,
        ...a
      });
  }, A.illegalConstructor = function() {
    throw A.errors.exception({
      header: "TypeError",
      message: "Illegal constructor"
    });
  }, A.util.Type = function(n) {
    switch (typeof n) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object":
        return n === null ? "Null" : "Object";
    }
  }, A.util.ConvertToInt = function(n, i, a, o = {}) {
    let s, l;
    i === 64 ? (s = Math.pow(2, 53) - 1, a === "unsigned" ? l = 0 : l = Math.pow(-2, 53) + 1) : a === "unsigned" ? (l = 0, s = Math.pow(2, i) - 1) : (l = Math.pow(-2, i) - 1, s = Math.pow(2, i - 1) - 1);
    let c = Number(n);
    if (c === 0 && (c = 0), o.enforceRange === !0) {
      if (Number.isNaN(c) || c === Number.POSITIVE_INFINITY || c === Number.NEGATIVE_INFINITY)
        throw A.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${n} to an integer.`
        });
      if (c = A.util.IntegerPart(c), c < l || c > s)
        throw A.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${l}-${s}, got ${c}.`
        });
      return c;
    }
    return !Number.isNaN(c) && o.clamp === !0 ? (c = Math.min(Math.max(c, l), s), Math.floor(c) % 2 === 0 ? c = Math.floor(c) : c = Math.ceil(c), c) : Number.isNaN(c) || c === 0 && Object.is(0, c) || c === Number.POSITIVE_INFINITY || c === Number.NEGATIVE_INFINITY ? 0 : (c = A.util.IntegerPart(c), c = c % Math.pow(2, i), a === "signed" && c >= Math.pow(2, i) - 1 ? c - Math.pow(2, i) : c);
  }, A.util.IntegerPart = function(n) {
    const i = Math.floor(Math.abs(n));
    return n < 0 ? -1 * i : i;
  }, A.sequenceConverter = function(n) {
    return (i) => {
      var s;
      if (A.util.Type(i) !== "Object")
        throw A.errors.exception({
          header: "Sequence",
          message: `Value of type ${A.util.Type(i)} is not an Object.`
        });
      const a = (s = i == null ? void 0 : i[Symbol.iterator]) == null ? void 0 : s.call(i), o = [];
      if (a === void 0 || typeof a.next != "function")
        throw A.errors.exception({
          header: "Sequence",
          message: "Object is not an iterator."
        });
      for (; ; ) {
        const { done: l, value: c } = a.next();
        if (l)
          break;
        o.push(n(c));
      }
      return o;
    };
  }, A.recordConverter = function(n, i) {
    return (a) => {
      if (A.util.Type(a) !== "Object")
        throw A.errors.exception({
          header: "Record",
          message: `Value of type ${A.util.Type(a)} is not an Object.`
        });
      const o = {};
      if (!r.isProxy(a)) {
        const l = Object.keys(a);
        for (const c of l) {
          const u = n(c), h = i(a[c]);
          o[u] = h;
        }
        return o;
      }
      const s = Reflect.ownKeys(a);
      for (const l of s) {
        const c = Reflect.getOwnPropertyDescriptor(a, l);
        if (c != null && c.enumerable) {
          const u = n(l), h = i(a[l]);
          o[u] = h;
        }
      }
      return o;
    };
  }, A.interfaceConverter = function(n) {
    return (i, a = {}) => {
      if (a.strict !== !1 && !(i instanceof n))
        throw A.errors.exception({
          header: n.name,
          message: `Expected ${i} to be an instance of ${n.name}.`
        });
      return i;
    };
  }, A.dictionaryConverter = function(n) {
    return (i) => {
      const a = A.util.Type(i), o = {};
      if (a === "Null" || a === "Undefined")
        return o;
      if (a !== "Object")
        throw A.errors.exception({
          header: "Dictionary",
          message: `Expected ${i} to be one of: Null, Undefined, Object.`
        });
      for (const s of n) {
        const { key: l, defaultValue: c, required: u, converter: h } = s;
        if (u === !0 && !t(i, l))
          throw A.errors.exception({
            header: "Dictionary",
            message: `Missing required key "${l}".`
          });
        let g = i[l];
        const d = t(s, "defaultValue");
        if (d && g !== null && (g = g ?? c), u || d || g !== void 0) {
          if (g = h(g), s.allowedValues && !s.allowedValues.includes(g))
            throw A.errors.exception({
              header: "Dictionary",
              message: `${g} is not an accepted type. Expected one of ${s.allowedValues.join(", ")}.`
            });
          o[l] = g;
        }
      }
      return o;
    };
  }, A.nullableConverter = function(n) {
    return (i) => i === null ? i : n(i);
  }, A.converters.DOMString = function(n, i = {}) {
    if (n === null && i.legacyNullToEmptyString)
      return "";
    if (typeof n == "symbol")
      throw new TypeError("Could not convert argument of type symbol to string.");
    return String(n);
  }, A.converters.ByteString = function(n) {
    const i = A.converters.DOMString(n);
    for (let a = 0; a < i.length; a++)
      if (i.charCodeAt(a) > 255)
        throw new TypeError(
          `Cannot convert argument to a ByteString because the character at index ${a} has a value of ${i.charCodeAt(a)} which is greater than 255.`
        );
    return i;
  }, A.converters.USVString = e, A.converters.boolean = function(n) {
    return !!n;
  }, A.converters.any = function(n) {
    return n;
  }, A.converters["long long"] = function(n) {
    return A.util.ConvertToInt(n, 64, "signed");
  }, A.converters["unsigned long long"] = function(n) {
    return A.util.ConvertToInt(n, 64, "unsigned");
  }, A.converters["unsigned long"] = function(n) {
    return A.util.ConvertToInt(n, 32, "unsigned");
  }, A.converters["unsigned short"] = function(n, i) {
    return A.util.ConvertToInt(n, 16, "unsigned", i);
  }, A.converters.ArrayBuffer = function(n, i = {}) {
    if (A.util.Type(n) !== "Object" || !r.isAnyArrayBuffer(n))
      throw A.errors.conversionFailed({
        prefix: `${n}`,
        argument: `${n}`,
        types: ["ArrayBuffer"]
      });
    if (i.allowShared === !1 && r.isSharedArrayBuffer(n))
      throw A.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    return n;
  }, A.converters.TypedArray = function(n, i, a = {}) {
    if (A.util.Type(n) !== "Object" || !r.isTypedArray(n) || n.constructor.name !== i.name)
      throw A.errors.conversionFailed({
        prefix: `${i.name}`,
        argument: `${n}`,
        types: [i.name]
      });
    if (a.allowShared === !1 && r.isSharedArrayBuffer(n.buffer))
      throw A.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    return n;
  }, A.converters.DataView = function(n, i = {}) {
    if (A.util.Type(n) !== "Object" || !r.isDataView(n))
      throw A.errors.exception({
        header: "DataView",
        message: "Object is not a DataView."
      });
    if (i.allowShared === !1 && r.isSharedArrayBuffer(n.buffer))
      throw A.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed."
      });
    return n;
  }, A.converters.BufferSource = function(n, i = {}) {
    if (r.isAnyArrayBuffer(n))
      return A.converters.ArrayBuffer(n, i);
    if (r.isTypedArray(n))
      return A.converters.TypedArray(n, n.constructor);
    if (r.isDataView(n))
      return A.converters.DataView(n, i);
    throw new TypeError(`Could not convert ${n} to a BufferSource.`);
  }, A.converters["sequence<ByteString>"] = A.sequenceConverter(
    A.converters.ByteString
  ), A.converters["sequence<sequence<ByteString>>"] = A.sequenceConverter(
    A.converters["sequence<ByteString>"]
  ), A.converters["record<ByteString, ByteString>"] = A.recordConverter(
    A.converters.ByteString,
    A.converters.ByteString
  ), Ya = {
    webidl: A
  }, Ya;
}
var Ja, gc;
function JA() {
  if (gc)
    return Ja;
  gc = 1;
  const r = L, { atob: t } = L, { isomorphicDecode: e } = NA(), A = new TextEncoder(), n = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/, i = /(\u000A|\u000D|\u0009|\u0020)/, a = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
  function o(C) {
    r(C.protocol === "data:");
    let f = s(C, !0);
    f = f.slice(5);
    const p = { position: 0 };
    let m = c(
      ",",
      f,
      p
    );
    const R = m.length;
    if (m = w(m, !0, !0), p.position >= f.length)
      return "failure";
    p.position++;
    const P = f.slice(R + 1);
    let N = u(P);
    if (/;(\u0020){0,}base64$/i.test(m)) {
      const V = e(N);
      if (N = d(V), N === "failure")
        return "failure";
      m = m.slice(0, -6), m = m.replace(/(\u0020)+$/, ""), m = m.slice(0, -1);
    }
    m.startsWith(";") && (m = "text/plain" + m);
    let $ = g(m);
    return $ === "failure" && ($ = g("text/plain;charset=US-ASCII")), { mimeType: $, body: N };
  }
  function s(C, f = !1) {
    if (!f)
      return C.href;
    const p = C.href, m = C.hash.length;
    return m === 0 ? p : p.substring(0, p.length - m);
  }
  function l(C, f, p) {
    let m = "";
    for (; p.position < f.length && C(f[p.position]); )
      m += f[p.position], p.position++;
    return m;
  }
  function c(C, f, p) {
    const m = f.indexOf(C, p.position), R = p.position;
    return m === -1 ? (p.position = f.length, f.slice(R)) : (p.position = m, f.slice(R, p.position));
  }
  function u(C) {
    const f = A.encode(C);
    return h(f);
  }
  function h(C) {
    const f = [];
    for (let p = 0; p < C.length; p++) {
      const m = C[p];
      if (m !== 37)
        f.push(m);
      else if (m === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(C[p + 1], C[p + 2])))
        f.push(37);
      else {
        const R = String.fromCharCode(C[p + 1], C[p + 2]), P = Number.parseInt(R, 16);
        f.push(P), p += 2;
      }
    }
    return Uint8Array.from(f);
  }
  function g(C) {
    C = E(C, !0, !0);
    const f = { position: 0 }, p = c(
      "/",
      C,
      f
    );
    if (p.length === 0 || !n.test(p) || f.position > C.length)
      return "failure";
    f.position++;
    let m = c(
      ";",
      C,
      f
    );
    if (m = E(m, !1, !0), m.length === 0 || !n.test(m))
      return "failure";
    const R = p.toLowerCase(), P = m.toLowerCase(), N = {
      type: R,
      subtype: P,
      /** @type {Map<string, string>} */
      parameters: /* @__PURE__ */ new Map(),
      // https://mimesniff.spec.whatwg.org/#mime-type-essence
      essence: `${R}/${P}`
    };
    for (; f.position < C.length; ) {
      f.position++, l(
        // https://fetch.spec.whatwg.org/#http-whitespace
        (ne) => i.test(ne),
        C,
        f
      );
      let $ = l(
        (ne) => ne !== ";" && ne !== "=",
        C,
        f
      );
      if ($ = $.toLowerCase(), f.position < C.length) {
        if (C[f.position] === ";")
          continue;
        f.position++;
      }
      if (f.position > C.length)
        break;
      let V = null;
      if (C[f.position] === '"')
        V = I(C, f, !0), c(
          ";",
          C,
          f
        );
      else if (V = c(
        ";",
        C,
        f
      ), V = E(V, !1, !0), V.length === 0)
        continue;
      $.length !== 0 && n.test($) && (V.length === 0 || a.test(V)) && !N.parameters.has($) && N.parameters.set($, V);
    }
    return N;
  }
  function d(C) {
    if (C = C.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, ""), C.length % 4 === 0 && (C = C.replace(/=?=$/, "")), C.length % 4 === 1 || /[^+/0-9A-Za-z]/.test(C))
      return "failure";
    const f = t(C), p = new Uint8Array(f.length);
    for (let m = 0; m < f.length; m++)
      p[m] = f.charCodeAt(m);
    return p;
  }
  function I(C, f, p) {
    const m = f.position;
    let R = "";
    for (r(C[f.position] === '"'), f.position++; R += l(
      (N) => N !== '"' && N !== "\\",
      C,
      f
    ), !(f.position >= C.length); ) {
      const P = C[f.position];
      if (f.position++, P === "\\") {
        if (f.position >= C.length) {
          R += "\\";
          break;
        }
        R += C[f.position], f.position++;
      } else {
        r(P === '"');
        break;
      }
    }
    return p ? R : C.slice(m, f.position);
  }
  function y(C) {
    r(C !== "failure");
    const { parameters: f, essence: p } = C;
    let m = p;
    for (let [R, P] of f.entries())
      m += ";", m += R, m += "=", n.test(P) || (P = P.replace(/(\\|")/g, "\\$1"), P = '"' + P, P += '"'), m += P;
    return m;
  }
  function Q(C) {
    return C === "\r" || C === `
` || C === "	" || C === " ";
  }
  function E(C, f = !0, p = !0) {
    let m = 0, R = C.length - 1;
    if (f)
      for (; m < C.length && Q(C[m]); m++)
        ;
    if (p)
      for (; R > 0 && Q(C[R]); R--)
        ;
    return C.slice(m, R + 1);
  }
  function B(C) {
    return C === "\r" || C === `
` || C === "	" || C === "\f" || C === " ";
  }
  function w(C, f = !0, p = !0) {
    let m = 0, R = C.length - 1;
    if (f)
      for (; m < C.length && B(C[m]); m++)
        ;
    if (p)
      for (; R > 0 && B(C[R]); R--)
        ;
    return C.slice(m, R + 1);
  }
  return Ja = {
    dataURLProcessor: o,
    URLSerializer: s,
    collectASequenceOfCodePoints: l,
    collectASequenceOfCodePointsFast: c,
    stringPercentDecode: u,
    parseMIMEType: g,
    collectAnHTTPQuotedString: I,
    serializeAMimeType: y
  }, Ja;
}
var _a, Ec;
function Ts() {
  if (Ec)
    return _a;
  Ec = 1;
  const { Blob: r, File: t } = L, { types: e } = L, { kState: A } = Ct(), { isBlobLike: n } = NA(), { webidl: i } = QA(), { parseMIMEType: a, serializeAMimeType: o } = JA(), { kEnumerableProperty: s } = Ie, l = new TextEncoder();
  class c extends r {
    constructor(y, Q, E = {}) {
      i.argumentLengthCheck(arguments, 2, { header: "File constructor" }), y = i.converters["sequence<BlobPart>"](y), Q = i.converters.USVString(Q), E = i.converters.FilePropertyBag(E);
      const B = Q;
      let w = E.type, C;
      e: {
        if (w) {
          if (w = a(w), w === "failure") {
            w = "";
            break e;
          }
          w = o(w).toLowerCase();
        }
        C = E.lastModified;
      }
      super(h(y, E), { type: w }), this[A] = {
        name: B,
        lastModified: C,
        type: w
      };
    }
    get name() {
      return i.brandCheck(this, c), this[A].name;
    }
    get lastModified() {
      return i.brandCheck(this, c), this[A].lastModified;
    }
    get type() {
      return i.brandCheck(this, c), this[A].type;
    }
  }
  class u {
    constructor(y, Q, E = {}) {
      const B = Q, w = E.type, C = E.lastModified ?? Date.now();
      this[A] = {
        blobLike: y,
        name: B,
        type: w,
        lastModified: C
      };
    }
    stream(...y) {
      return i.brandCheck(this, u), this[A].blobLike.stream(...y);
    }
    arrayBuffer(...y) {
      return i.brandCheck(this, u), this[A].blobLike.arrayBuffer(...y);
    }
    slice(...y) {
      return i.brandCheck(this, u), this[A].blobLike.slice(...y);
    }
    text(...y) {
      return i.brandCheck(this, u), this[A].blobLike.text(...y);
    }
    get size() {
      return i.brandCheck(this, u), this[A].blobLike.size;
    }
    get type() {
      return i.brandCheck(this, u), this[A].blobLike.type;
    }
    get name() {
      return i.brandCheck(this, u), this[A].name;
    }
    get lastModified() {
      return i.brandCheck(this, u), this[A].lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
  }
  Object.defineProperties(c.prototype, {
    [Symbol.toStringTag]: {
      value: "File",
      configurable: !0
    },
    name: s,
    lastModified: s
  }), i.converters.Blob = i.interfaceConverter(r), i.converters.BlobPart = function(I, y) {
    if (i.util.Type(I) === "Object") {
      if (n(I))
        return i.converters.Blob(I, { strict: !1 });
      if (ArrayBuffer.isView(I) || e.isAnyArrayBuffer(I))
        return i.converters.BufferSource(I, y);
    }
    return i.converters.USVString(I, y);
  }, i.converters["sequence<BlobPart>"] = i.sequenceConverter(
    i.converters.BlobPart
  ), i.converters.FilePropertyBag = i.dictionaryConverter([
    {
      key: "lastModified",
      converter: i.converters["long long"],
      get defaultValue() {
        return Date.now();
      }
    },
    {
      key: "type",
      converter: i.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "endings",
      converter: (I) => (I = i.converters.DOMString(I), I = I.toLowerCase(), I !== "native" && (I = "transparent"), I),
      defaultValue: "transparent"
    }
  ]);
  function h(I, y) {
    const Q = [];
    for (const E of I)
      if (typeof E == "string") {
        let B = E;
        y.endings === "native" && (B = g(B)), Q.push(l.encode(B));
      } else
        e.isAnyArrayBuffer(E) || e.isTypedArray(E) ? E.buffer ? Q.push(
          new Uint8Array(E.buffer, E.byteOffset, E.byteLength)
        ) : Q.push(new Uint8Array(E)) : n(E) && Q.push(E);
    return Q;
  }
  function g(I) {
    let y = `
`;
    return process.platform === "win32" && (y = `\r
`), I.replace(/\r?\n/g, y);
  }
  function d(I) {
    return t && I instanceof t || I instanceof c || I && (typeof I.stream == "function" || typeof I.arrayBuffer == "function") && I[Symbol.toStringTag] === "File";
  }
  return _a = { File: c, FileLike: u, isFileLike: d }, _a;
}
var xa, Cc;
function Fs() {
  if (Cc)
    return xa;
  Cc = 1;
  const { isBlobLike: r, toUSVString: t, makeIterator: e } = NA(), { kState: A } = Ct(), { File: n, FileLike: i, isFileLike: a } = Ts(), { webidl: o } = QA(), { Blob: s, File: l } = L, c = l ?? n;
  class u {
    constructor(d) {
      if (d !== void 0)
        throw o.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"]
        });
      this[A] = [];
    }
    append(d, I, y = void 0) {
      if (o.brandCheck(this, u), o.argumentLengthCheck(arguments, 2, { header: "FormData.append" }), arguments.length === 3 && !r(I))
        throw new TypeError(
          "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
        );
      d = o.converters.USVString(d), I = r(I) ? o.converters.Blob(I, { strict: !1 }) : o.converters.USVString(I), y = arguments.length === 3 ? o.converters.USVString(y) : void 0;
      const Q = h(d, I, y);
      this[A].push(Q);
    }
    delete(d) {
      o.brandCheck(this, u), o.argumentLengthCheck(arguments, 1, { header: "FormData.delete" }), d = o.converters.USVString(d), this[A] = this[A].filter((I) => I.name !== d);
    }
    get(d) {
      o.brandCheck(this, u), o.argumentLengthCheck(arguments, 1, { header: "FormData.get" }), d = o.converters.USVString(d);
      const I = this[A].findIndex((y) => y.name === d);
      return I === -1 ? null : this[A][I].value;
    }
    getAll(d) {
      return o.brandCheck(this, u), o.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" }), d = o.converters.USVString(d), this[A].filter((I) => I.name === d).map((I) => I.value);
    }
    has(d) {
      return o.brandCheck(this, u), o.argumentLengthCheck(arguments, 1, { header: "FormData.has" }), d = o.converters.USVString(d), this[A].findIndex((I) => I.name === d) !== -1;
    }
    set(d, I, y = void 0) {
      if (o.brandCheck(this, u), o.argumentLengthCheck(arguments, 2, { header: "FormData.set" }), arguments.length === 3 && !r(I))
        throw new TypeError(
          "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
        );
      d = o.converters.USVString(d), I = r(I) ? o.converters.Blob(I, { strict: !1 }) : o.converters.USVString(I), y = arguments.length === 3 ? t(y) : void 0;
      const Q = h(d, I, y), E = this[A].findIndex((B) => B.name === d);
      E !== -1 ? this[A] = [
        ...this[A].slice(0, E),
        Q,
        ...this[A].slice(E + 1).filter((B) => B.name !== d)
      ] : this[A].push(Q);
    }
    entries() {
      return o.brandCheck(this, u), e(
        () => this[A].map((d) => [d.name, d.value]),
        "FormData",
        "key+value"
      );
    }
    keys() {
      return o.brandCheck(this, u), e(
        () => this[A].map((d) => [d.name, d.value]),
        "FormData",
        "key"
      );
    }
    values() {
      return o.brandCheck(this, u), e(
        () => this[A].map((d) => [d.name, d.value]),
        "FormData",
        "value"
      );
    }
    /**
     * @param {(value: string, key: string, self: FormData) => void} callbackFn
     * @param {unknown} thisArg
     */
    forEach(d, I = globalThis) {
      if (o.brandCheck(this, u), o.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" }), typeof d != "function")
        throw new TypeError(
          "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'."
        );
      for (const [y, Q] of this)
        d.apply(I, [Q, y, this]);
    }
  }
  u.prototype[Symbol.iterator] = u.prototype.entries, Object.defineProperties(u.prototype, {
    [Symbol.toStringTag]: {
      value: "FormData",
      configurable: !0
    }
  });
  function h(g, d, I) {
    if (g = Buffer.from(g).toString("utf8"), typeof d == "string")
      d = Buffer.from(d).toString("utf8");
    else if (a(d) || (d = d instanceof s ? new c([d], "blob", { type: d.type }) : new i(d, "blob", { type: d.type })), I !== void 0) {
      const y = {
        type: d.type,
        lastModified: d.lastModified
      };
      d = l && d instanceof l || d instanceof n ? new c([d], I, y) : new i(d, I, y);
    }
    return { name: g, value: d };
  }
  return xa = { FormData: u }, xa;
}
var Oa, fc;
function di() {
  if (fc)
    return Oa;
  fc = 1;
  const r = MC(), t = Ie, {
    ReadableStreamFrom: e,
    isBlobLike: A,
    isReadableStreamLike: n,
    readableStreamClose: i,
    createDeferredPromise: a,
    fullyReadBody: o
  } = NA(), { FormData: s } = Fs(), { kState: l } = Ct(), { webidl: c } = QA(), { DOMException: u, structuredClone: h } = Mt(), { Blob: g, File: d } = L, { kBodyUsed: I } = Re, y = L, { isErrored: Q } = Ie, { isUint8Array: E, isArrayBuffer: B } = L, { File: w } = Ts(), { parseMIMEType: C, serializeAMimeType: f } = JA();
  let p = globalThis.ReadableStream;
  const m = d ?? w, R = new TextEncoder(), P = new TextDecoder();
  function N(F, T = !1) {
    p || (p = L.ReadableStream);
    let S = null;
    F instanceof p ? S = F : A(F) ? S = F.stream() : S = new p({
      async pull(ie) {
        ie.enqueue(
          typeof Y == "string" ? R.encode(Y) : Y
        ), queueMicrotask(() => i(ie));
      },
      start() {
      },
      type: void 0
    }), y(n(S));
    let U = null, Y = null, O = null, j = null;
    if (typeof F == "string")
      Y = F, j = "text/plain;charset=UTF-8";
    else if (F instanceof URLSearchParams)
      Y = F.toString(), j = "application/x-www-form-urlencoded;charset=UTF-8";
    else if (B(F))
      Y = new Uint8Array(F.slice());
    else if (ArrayBuffer.isView(F))
      Y = new Uint8Array(F.buffer.slice(F.byteOffset, F.byteOffset + F.byteLength));
    else if (t.isFormDataLike(F)) {
      const ie = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, "0")}`, ye = `--${ie}\r
Content-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
      const Ee = (Ce) => Ce.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"), He = (Ce) => Ce.replace(/\r?\n|\r/g, `\r
`), be = [], De = new Uint8Array([13, 10]);
      O = 0;
      let Ge = !1;
      for (const [Ce, pe] of F)
        if (typeof pe == "string") {
          const sA = R.encode(ye + `; name="${Ee(He(Ce))}"\r
\r
${He(pe)}\r
`);
          be.push(sA), O += sA.byteLength;
        } else {
          const sA = R.encode(`${ye}; name="${Ee(He(Ce))}"` + (pe.name ? `; filename="${Ee(pe.name)}"` : "") + `\r
Content-Type: ${pe.type || "application/octet-stream"}\r
\r
`);
          be.push(sA, pe, De), typeof pe.size == "number" ? O += sA.byteLength + pe.size + De.byteLength : Ge = !0;
        }
      const Qe = R.encode(`--${ie}--`);
      be.push(Qe), O += Qe.byteLength, Ge && (O = null), Y = F, U = async function* () {
        for (const Ce of be)
          Ce.stream ? yield* Ce.stream() : yield Ce;
      }, j = "multipart/form-data; boundary=" + ie;
    } else if (A(F))
      Y = F, O = F.size, F.type && (j = F.type);
    else if (typeof F[Symbol.asyncIterator] == "function") {
      if (T)
        throw new TypeError("keepalive");
      if (t.isDisturbed(F) || F.locked)
        throw new TypeError(
          "Response body object should not be disturbed or locked"
        );
      S = F instanceof p ? F : e(F);
    }
    if ((typeof Y == "string" || t.isBuffer(Y)) && (O = Buffer.byteLength(Y)), U != null) {
      let ie;
      S = new p({
        async start() {
          ie = U(F)[Symbol.asyncIterator]();
        },
        async pull(ye) {
          const { value: Ee, done: He } = await ie.next();
          return He ? queueMicrotask(() => {
            ye.close();
          }) : Q(S) || ye.enqueue(new Uint8Array(Ee)), ye.desiredSize > 0;
        },
        async cancel(ye) {
          await ie.return();
        },
        type: void 0
      });
    }
    return [{ stream: S, source: Y, length: O }, j];
  }
  function $(F, T = !1) {
    return p || (p = L.ReadableStream), F instanceof p && (y(!t.isDisturbed(F), "The body has already been consumed."), y(!F.locked, "The stream is locked.")), N(F, T);
  }
  function V(F) {
    const [T, S] = F.stream.tee(), U = h(S, { transfer: [S] }), [, Y] = U.tee();
    return F.stream = T, {
      stream: Y,
      length: F.length,
      source: F.source
    };
  }
  async function* ne(F) {
    if (F)
      if (E(F))
        yield F;
      else {
        const T = F.stream;
        if (t.isDisturbed(T))
          throw new TypeError("The body has already been consumed.");
        if (T.locked)
          throw new TypeError("The stream is locked.");
        T[I] = !0, yield* T;
      }
  }
  function _(F) {
    if (F.aborted)
      throw new u("The operation was aborted.", "AbortError");
  }
  function X(F) {
    return {
      blob() {
        return ee(this, (S) => {
          let U = v(this);
          return U === "failure" ? U = "" : U && (U = f(U)), new g([S], { type: U });
        }, F);
      },
      arrayBuffer() {
        return ee(this, (S) => new Uint8Array(S).buffer, F);
      },
      text() {
        return ee(this, b, F);
      },
      json() {
        return ee(this, W, F);
      },
      async formData() {
        c.brandCheck(this, F), _(this[l]);
        const S = this.headers.get("Content-Type");
        if (/multipart\/form-data/.test(S)) {
          const U = {};
          for (const [H, ie] of this.headers)
            U[H.toLowerCase()] = ie;
          const Y = new s();
          let O;
          try {
            O = new r({
              headers: U,
              preservePath: !0
            });
          } catch (H) {
            throw new u(`${H}`, "AbortError");
          }
          O.on("field", (H, ie) => {
            Y.append(H, ie);
          }), O.on("file", (H, ie, ye, Ee, He) => {
            const be = [];
            if (Ee === "base64" || Ee.toLowerCase() === "base64") {
              let De = "";
              ie.on("data", (Ge) => {
                De += Ge.toString().replace(/[\r\n]/gm, "");
                const Qe = De.length - De.length % 4;
                be.push(Buffer.from(De.slice(0, Qe), "base64")), De = De.slice(Qe);
              }), ie.on("end", () => {
                be.push(Buffer.from(De, "base64")), Y.append(H, new m(be, ye, { type: He }));
              });
            } else
              ie.on("data", (De) => {
                be.push(De);
              }), ie.on("end", () => {
                Y.append(H, new m(be, ye, { type: He }));
              });
          });
          const j = new Promise((H, ie) => {
            O.on("finish", H), O.on("error", (ye) => ie(new TypeError(ye)));
          });
          if (this.body !== null)
            for await (const H of ne(this[l].body))
              O.write(H);
          return O.end(), await j, Y;
        } else if (/application\/x-www-form-urlencoded/.test(S)) {
          let U;
          try {
            let O = "";
            const j = new TextDecoder("utf-8", { ignoreBOM: !0 });
            for await (const H of ne(this[l].body)) {
              if (!E(H))
                throw new TypeError("Expected Uint8Array chunk");
              O += j.decode(H, { stream: !0 });
            }
            O += j.decode(), U = new URLSearchParams(O);
          } catch (O) {
            throw Object.assign(new TypeError(), { cause: O });
          }
          const Y = new s();
          for (const [O, j] of U)
            Y.append(O, j);
          return Y;
        } else
          throw await Promise.resolve(), _(this[l]), c.errors.exception({
            header: `${F.name}.formData`,
            message: "Could not parse content as FormData."
          });
      }
    };
  }
  function te(F) {
    Object.assign(F.prototype, X(F));
  }
  async function ee(F, T, S) {
    if (c.brandCheck(F, S), _(F[l]), Z(F[l].body))
      throw new TypeError("Body is unusable");
    const U = a(), Y = (j) => U.reject(j), O = (j) => {
      try {
        U.resolve(T(j));
      } catch (H) {
        Y(H);
      }
    };
    return F[l].body == null ? (O(new Uint8Array()), U.promise) : (await o(F[l].body, O, Y), U.promise);
  }
  function Z(F) {
    return F != null && (F.stream.locked || t.isDisturbed(F.stream));
  }
  function b(F) {
    return F.length === 0 ? "" : (F[0] === 239 && F[1] === 187 && F[2] === 191 && (F = F.subarray(3)), P.decode(F));
  }
  function W(F) {
    return JSON.parse(b(F));
  }
  function v(F) {
    const { headersList: T } = F[l], S = T.get("content-type");
    return S === null ? "failure" : C(S);
  }
  return Oa = {
    extractBody: N,
    safelyExtractBody: $,
    cloneBody: V,
    mixinBody: te
  }, Oa;
}
const {
  InvalidArgumentError: ve,
  NotSupportedError: LC
} = ke, _A = L, { kHTTP2BuildRequest: HC, kHTTP2CopyHeaders: GC, kHTTP1BuildRequest: WC } = Re, CA = Ie, sh = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/, ch = /[^\t\x20-\x7e\x80-\xff]/, YC = /[^\u0021-\u00ff]/, FA = Symbol("handler"), Oe = {};
let qa;
try {
  const r = L;
  Oe.create = r.channel("undici:request:create"), Oe.bodySent = r.channel("undici:request:bodySent"), Oe.headers = r.channel("undici:request:headers"), Oe.trailers = r.channel("undici:request:trailers"), Oe.error = r.channel("undici:request:error");
} catch {
  Oe.create = { hasSubscribers: !1 }, Oe.bodySent = { hasSubscribers: !1 }, Oe.headers = { hasSubscribers: !1 }, Oe.trailers = { hasSubscribers: !1 }, Oe.error = { hasSubscribers: !1 };
}
let JC = class rs {
  constructor(t, {
    path: e,
    method: A,
    body: n,
    headers: i,
    query: a,
    idempotent: o,
    blocking: s,
    upgrade: l,
    headersTimeout: c,
    bodyTimeout: u,
    reset: h,
    throwOnError: g,
    expectContinue: d
  }, I) {
    if (typeof e != "string")
      throw new ve("path must be a string");
    if (e[0] !== "/" && !(e.startsWith("http://") || e.startsWith("https://")) && A !== "CONNECT")
      throw new ve("path must be an absolute URL or start with a slash");
    if (YC.exec(e) !== null)
      throw new ve("invalid request path");
    if (typeof A != "string")
      throw new ve("method must be a string");
    if (sh.exec(A) === null)
      throw new ve("invalid request method");
    if (l && typeof l != "string")
      throw new ve("upgrade must be a string");
    if (c != null && (!Number.isFinite(c) || c < 0))
      throw new ve("invalid headersTimeout");
    if (u != null && (!Number.isFinite(u) || u < 0))
      throw new ve("invalid bodyTimeout");
    if (h != null && typeof h != "boolean")
      throw new ve("invalid reset");
    if (d != null && typeof d != "boolean")
      throw new ve("invalid expectContinue");
    if (this.headersTimeout = c, this.bodyTimeout = u, this.throwOnError = g === !0, this.method = A, this.abort = null, n == null)
      this.body = null;
    else if (CA.isStream(n)) {
      this.body = n;
      const y = this.body._readableState;
      (!y || !y.autoDestroy) && (this.endHandler = function() {
        CA.destroy(this);
      }, this.body.on("end", this.endHandler)), this.errorHandler = (Q) => {
        this.abort ? this.abort(Q) : this.error = Q;
      }, this.body.on("error", this.errorHandler);
    } else if (CA.isBuffer(n))
      this.body = n.byteLength ? n : null;
    else if (ArrayBuffer.isView(n))
      this.body = n.buffer.byteLength ? Buffer.from(n.buffer, n.byteOffset, n.byteLength) : null;
    else if (n instanceof ArrayBuffer)
      this.body = n.byteLength ? Buffer.from(n) : null;
    else if (typeof n == "string")
      this.body = n.length ? Buffer.from(n) : null;
    else if (CA.isFormDataLike(n) || CA.isIterable(n) || CA.isBlobLike(n))
      this.body = n;
    else
      throw new ve("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
    if (this.completed = !1, this.aborted = !1, this.upgrade = l || null, this.path = a ? CA.buildURL(e, a) : e, this.origin = t, this.idempotent = o ?? (A === "HEAD" || A === "GET"), this.blocking = s ?? !1, this.reset = h ?? null, this.host = null, this.contentLength = null, this.contentType = null, this.headers = "", this.expectContinue = d ?? !1, Array.isArray(i)) {
      if (i.length % 2 !== 0)
        throw new ve("headers array must be even");
      for (let y = 0; y < i.length; y += 2)
        Er(this, i[y], i[y + 1]);
    } else if (i && typeof i == "object") {
      const y = Object.keys(i);
      for (let Q = 0; Q < y.length; Q++) {
        const E = y[Q];
        Er(this, E, i[E]);
      }
    } else if (i != null)
      throw new ve("headers must be an object or an array");
    if (CA.isFormDataLike(this.body)) {
      if (CA.nodeMajor < 16 || CA.nodeMajor === 16 && CA.nodeMinor < 8)
        throw new ve("Form-Data bodies are only supported in node v16.8 and newer.");
      qa || (qa = di().extractBody);
      const [y, Q] = qa(n);
      this.contentType == null && (this.contentType = Q, this.headers += `content-type: ${Q}\r
`), this.body = y.stream, this.contentLength = y.length;
    } else
      CA.isBlobLike(n) && this.contentType == null && n.type && (this.contentType = n.type, this.headers += `content-type: ${n.type}\r
`);
    CA.validateHandler(I, A, l), this.servername = CA.getServerName(this.host), this[FA] = I, Oe.create.hasSubscribers && Oe.create.publish({ request: this });
  }
  onBodySent(t) {
    if (this[FA].onBodySent)
      try {
        return this[FA].onBodySent(t);
      } catch (e) {
        this.abort(e);
      }
  }
  onRequestSent() {
    if (Oe.bodySent.hasSubscribers && Oe.bodySent.publish({ request: this }), this[FA].onRequestSent)
      try {
        return this[FA].onRequestSent();
      } catch (t) {
        this.abort(t);
      }
  }
  onConnect(t) {
    if (_A(!this.aborted), _A(!this.completed), this.error)
      t(this.error);
    else
      return this.abort = t, this[FA].onConnect(t);
  }
  onHeaders(t, e, A, n) {
    _A(!this.aborted), _A(!this.completed), Oe.headers.hasSubscribers && Oe.headers.publish({ request: this, response: { statusCode: t, headers: e, statusText: n } });
    try {
      return this[FA].onHeaders(t, e, A, n);
    } catch (i) {
      this.abort(i);
    }
  }
  onData(t) {
    _A(!this.aborted), _A(!this.completed);
    try {
      return this[FA].onData(t);
    } catch (e) {
      return this.abort(e), !1;
    }
  }
  onUpgrade(t, e, A) {
    return _A(!this.aborted), _A(!this.completed), this[FA].onUpgrade(t, e, A);
  }
  onComplete(t) {
    this.onFinally(), _A(!this.aborted), this.completed = !0, Oe.trailers.hasSubscribers && Oe.trailers.publish({ request: this, trailers: t });
    try {
      return this[FA].onComplete(t);
    } catch (e) {
      this.onError(e);
    }
  }
  onError(t) {
    if (this.onFinally(), Oe.error.hasSubscribers && Oe.error.publish({ request: this, error: t }), !this.aborted)
      return this.aborted = !0, this[FA].onError(t);
  }
  onFinally() {
    this.errorHandler && (this.body.off("error", this.errorHandler), this.errorHandler = null), this.endHandler && (this.body.off("end", this.endHandler), this.endHandler = null);
  }
  // TODO: adjust to support H2
  addHeader(t, e) {
    return Er(this, t, e), this;
  }
  static [WC](t, e, A) {
    return new rs(t, e, A);
  }
  static [HC](t, e, A) {
    const n = e.headers;
    e = { ...e, headers: null };
    const i = new rs(t, e, A);
    if (i.headers = {}, Array.isArray(n)) {
      if (n.length % 2 !== 0)
        throw new ve("headers array must be even");
      for (let a = 0; a < n.length; a += 2)
        Er(i, n[a], n[a + 1], !0);
    } else if (n && typeof n == "object") {
      const a = Object.keys(n);
      for (let o = 0; o < a.length; o++) {
        const s = a[o];
        Er(i, s, n[s], !0);
      }
    } else if (n != null)
      throw new ve("headers must be an object or an array");
    return i;
  }
  static [GC](t) {
    const e = t.split(`\r
`), A = {};
    for (const n of e) {
      const [i, a] = n.split(": ");
      a == null || a.length === 0 || (A[i] ? A[i] += `,${a}` : A[i] = a);
    }
    return A;
  }
};
function Bt(r, t, e) {
  if (t && typeof t == "object")
    throw new ve(`invalid ${r} header`);
  if (t = t != null ? `${t}` : "", ch.exec(t) !== null)
    throw new ve(`invalid ${r} header`);
  return e ? t : `${r}: ${t}\r
`;
}
function Er(r, t, e, A = !1) {
  if (e && typeof e == "object" && !Array.isArray(e))
    throw new ve(`invalid ${t} header`);
  if (e === void 0)
    return;
  if (r.host === null && t.length === 4 && t.toLowerCase() === "host") {
    if (ch.exec(e) !== null)
      throw new ve(`invalid ${t} header`);
    r.host = e;
  } else if (r.contentLength === null && t.length === 14 && t.toLowerCase() === "content-length") {
    if (r.contentLength = parseInt(e, 10), !Number.isFinite(r.contentLength))
      throw new ve("invalid content-length header");
  } else if (r.contentType === null && t.length === 12 && t.toLowerCase() === "content-type")
    r.contentType = e, A ? r.headers[t] = Bt(t, e, A) : r.headers += Bt(t, e);
  else {
    if (t.length === 17 && t.toLowerCase() === "transfer-encoding")
      throw new ve("invalid transfer-encoding header");
    if (t.length === 10 && t.toLowerCase() === "connection") {
      const n = typeof e == "string" ? e.toLowerCase() : null;
      if (n !== "close" && n !== "keep-alive")
        throw new ve("invalid connection header");
      n === "close" && (r.reset = !0);
    } else {
      if (t.length === 10 && t.toLowerCase() === "keep-alive")
        throw new ve("invalid keep-alive header");
      if (t.length === 7 && t.toLowerCase() === "upgrade")
        throw new ve("invalid upgrade header");
      if (t.length === 6 && t.toLowerCase() === "expect")
        throw new LC("expect header not supported");
      if (sh.exec(t) === null)
        throw new ve("invalid header key");
      if (Array.isArray(e))
        for (let n = 0; n < e.length; n++)
          A ? r.headers[t] ? r.headers[t] += `,${Bt(t, e[n], A)}` : r.headers[t] = Bt(t, e[n], A) : r.headers += Bt(t, e[n]);
      else
        A ? r.headers[t] = Bt(t, e, A) : r.headers += Bt(t, e);
    }
  }
}
var _C = JC;
const xC = L;
let OC = class extends xC {
  dispatch() {
    throw new Error("not implemented");
  }
  close() {
    throw new Error("not implemented");
  }
  destroy() {
    throw new Error("not implemented");
  }
};
var Rs = OC;
const qC = Rs, {
  ClientDestroyedError: ja,
  ClientClosedError: jC,
  InvalidArgumentError: Jt
} = ke, { kDestroy: VC, kClose: $C, kDispatch: Va, kInterceptors: It } = Re, _t = Symbol("destroyed"), Cr = Symbol("closed"), xA = Symbol("onDestroyed"), xt = Symbol("onClosed"), Fn = Symbol("Intercepted Dispatch");
let XC = class extends qC {
  constructor() {
    super(), this[_t] = !1, this[xA] = null, this[Cr] = !1, this[xt] = [];
  }
  get destroyed() {
    return this[_t];
  }
  get closed() {
    return this[Cr];
  }
  get interceptors() {
    return this[It];
  }
  set interceptors(t) {
    if (t) {
      for (let e = t.length - 1; e >= 0; e--)
        if (typeof this[It][e] != "function")
          throw new Jt("interceptor must be an function");
    }
    this[It] = t;
  }
  close(t) {
    if (t === void 0)
      return new Promise((A, n) => {
        this.close((i, a) => i ? n(i) : A(a));
      });
    if (typeof t != "function")
      throw new Jt("invalid callback");
    if (this[_t]) {
      queueMicrotask(() => t(new ja(), null));
      return;
    }
    if (this[Cr]) {
      this[xt] ? this[xt].push(t) : queueMicrotask(() => t(null, null));
      return;
    }
    this[Cr] = !0, this[xt].push(t);
    const e = () => {
      const A = this[xt];
      this[xt] = null;
      for (let n = 0; n < A.length; n++)
        A[n](null, null);
    };
    this[$C]().then(() => this.destroy()).then(() => {
      queueMicrotask(e);
    });
  }
  destroy(t, e) {
    if (typeof t == "function" && (e = t, t = null), e === void 0)
      return new Promise((n, i) => {
        this.destroy(t, (a, o) => a ? (
          /* istanbul ignore next: should never error */
          i(a)
        ) : n(o));
      });
    if (typeof e != "function")
      throw new Jt("invalid callback");
    if (this[_t]) {
      this[xA] ? this[xA].push(e) : queueMicrotask(() => e(null, null));
      return;
    }
    t || (t = new ja()), this[_t] = !0, this[xA] = this[xA] || [], this[xA].push(e);
    const A = () => {
      const n = this[xA];
      this[xA] = null;
      for (let i = 0; i < n.length; i++)
        n[i](null, null);
    };
    this[VC](t).then(() => {
      queueMicrotask(A);
    });
  }
  [Fn](t, e) {
    if (!this[It] || this[It].length === 0)
      return this[Fn] = this[Va], this[Va](t, e);
    let A = this[Va].bind(this);
    for (let n = this[It].length - 1; n >= 0; n--)
      A = this[It][n](A);
    return this[Fn] = A, A(t, e);
  }
  dispatch(t, e) {
    if (!e || typeof e != "object")
      throw new Jt("handler must be an object");
    try {
      if (!t || typeof t != "object")
        throw new Jt("opts must be an object.");
      if (this[_t] || this[xA])
        throw new ja();
      if (this[Cr])
        throw new jC();
      return this[Fn](t, e);
    } catch (A) {
      if (typeof e.onError != "function")
        throw new Jt("invalid onError method");
      return e.onError(A), !1;
    }
  }
};
var pi = XC;
const ZC = L, Qc = L, lh = Ie, { InvalidArgumentError: KC, ConnectTimeoutError: zC } = ke;
let $a, ns;
se.FinalizationRegistry && !process.env.NODE_V8_COVERAGE ? ns = class {
  constructor(t) {
    this._maxCachedSessions = t, this._sessionCache = /* @__PURE__ */ new Map(), this._sessionRegistry = new se.FinalizationRegistry((e) => {
      if (this._sessionCache.size < this._maxCachedSessions)
        return;
      const A = this._sessionCache.get(e);
      A !== void 0 && A.deref() === void 0 && this._sessionCache.delete(e);
    });
  }
  get(t) {
    const e = this._sessionCache.get(t);
    return e ? e.deref() : null;
  }
  set(t, e) {
    this._maxCachedSessions !== 0 && (this._sessionCache.set(t, new WeakRef(e)), this._sessionRegistry.register(e, t));
  }
} : ns = class {
  constructor(t) {
    this._maxCachedSessions = t, this._sessionCache = /* @__PURE__ */ new Map();
  }
  get(t) {
    return this._sessionCache.get(t);
  }
  set(t, e) {
    if (this._maxCachedSessions !== 0) {
      if (this._sessionCache.size >= this._maxCachedSessions) {
        const { value: A } = this._sessionCache.keys().next();
        this._sessionCache.delete(A);
      }
      this._sessionCache.set(t, e);
    }
  }
};
function ef({ allowH2: r, maxCachedSessions: t, socketPath: e, timeout: A, ...n }) {
  if (t != null && (!Number.isInteger(t) || t < 0))
    throw new KC("maxCachedSessions must be a positive integer or zero");
  const i = { path: e, ...n }, a = new ns(t ?? 100);
  return A = A ?? 1e4, r = r ?? !1, function({ hostname: s, host: l, protocol: c, port: u, servername: h, localAddress: g, httpSocket: d }, I) {
    let y;
    if (c === "https:") {
      $a || ($a = L), h = h || i.servername || lh.getServerName(l) || null;
      const E = h || s, B = a.get(E) || null;
      Qc(E), y = $a.connect({
        highWaterMark: 16384,
        // TLS in node can't have bigger HWM anyway...
        ...i,
        servername: h,
        session: B,
        localAddress: g,
        // TODO(HTTP/2): Add support for h2c
        ALPNProtocols: r ? ["http/1.1", "h2"] : ["http/1.1"],
        socket: d,
        // upgrade socket connection
        port: u || 443,
        host: s
      }), y.on("session", function(w) {
        a.set(E, w);
      });
    } else
      Qc(!d, "httpSocket can only be sent on TLS update"), y = ZC.connect({
        highWaterMark: 64 * 1024,
        // Same as nodejs fs streams.
        ...i,
        localAddress: g,
        port: u || 80,
        host: s
      });
    if (i.keepAlive == null || i.keepAlive) {
      const E = i.keepAliveInitialDelay === void 0 ? 6e4 : i.keepAliveInitialDelay;
      y.setKeepAlive(!0, E);
    }
    const Q = Af(() => tf(y), A);
    return y.setNoDelay(!0).once(c === "https:" ? "secureConnect" : "connect", function() {
      if (Q(), I) {
        const E = I;
        I = null, E(null, this);
      }
    }).on("error", function(E) {
      if (Q(), I) {
        const B = I;
        I = null, B(E);
      }
    }), y;
  };
}
function Af(r, t) {
  if (!t)
    return () => {
    };
  let e = null, A = null;
  const n = setTimeout(() => {
    e = setImmediate(() => {
      process.platform === "win32" ? A = setImmediate(() => r()) : r();
    });
  }, t);
  return () => {
    clearTimeout(n), clearImmediate(e), clearImmediate(A);
  };
}
function tf(r) {
  lh.destroy(r, new zC());
}
var yi = ef, Xa = {}, fr = {}, Bc;
function rf() {
  if (Bc)
    return fr;
  Bc = 1, Object.defineProperty(fr, "__esModule", { value: !0 }), fr.enumToMap = void 0;
  function r(t) {
    const e = {};
    return Object.keys(t).forEach((A) => {
      const n = t[A];
      typeof n == "number" && (e[A] = n);
    }), e;
  }
  return fr.enumToMap = r, fr;
}
var Ic;
function nf() {
  return Ic || (Ic = 1, function(r) {
    Object.defineProperty(r, "__esModule", { value: !0 }), r.SPECIAL_HEADERS = r.HEADER_STATE = r.MINOR = r.MAJOR = r.CONNECTION_TOKEN_CHARS = r.HEADER_CHARS = r.TOKEN = r.STRICT_TOKEN = r.HEX = r.URL_CHAR = r.STRICT_URL_CHAR = r.USERINFO_CHARS = r.MARK = r.ALPHANUM = r.NUM = r.HEX_MAP = r.NUM_MAP = r.ALPHA = r.FINISH = r.H_METHOD_MAP = r.METHOD_MAP = r.METHODS_RTSP = r.METHODS_ICE = r.METHODS_HTTP = r.METHODS = r.LENIENT_FLAGS = r.FLAGS = r.TYPE = r.ERROR = void 0;
    const t = rf();
    (function(n) {
      n[n.OK = 0] = "OK", n[n.INTERNAL = 1] = "INTERNAL", n[n.STRICT = 2] = "STRICT", n[n.LF_EXPECTED = 3] = "LF_EXPECTED", n[n.UNEXPECTED_CONTENT_LENGTH = 4] = "UNEXPECTED_CONTENT_LENGTH", n[n.CLOSED_CONNECTION = 5] = "CLOSED_CONNECTION", n[n.INVALID_METHOD = 6] = "INVALID_METHOD", n[n.INVALID_URL = 7] = "INVALID_URL", n[n.INVALID_CONSTANT = 8] = "INVALID_CONSTANT", n[n.INVALID_VERSION = 9] = "INVALID_VERSION", n[n.INVALID_HEADER_TOKEN = 10] = "INVALID_HEADER_TOKEN", n[n.INVALID_CONTENT_LENGTH = 11] = "INVALID_CONTENT_LENGTH", n[n.INVALID_CHUNK_SIZE = 12] = "INVALID_CHUNK_SIZE", n[n.INVALID_STATUS = 13] = "INVALID_STATUS", n[n.INVALID_EOF_STATE = 14] = "INVALID_EOF_STATE", n[n.INVALID_TRANSFER_ENCODING = 15] = "INVALID_TRANSFER_ENCODING", n[n.CB_MESSAGE_BEGIN = 16] = "CB_MESSAGE_BEGIN", n[n.CB_HEADERS_COMPLETE = 17] = "CB_HEADERS_COMPLETE", n[n.CB_MESSAGE_COMPLETE = 18] = "CB_MESSAGE_COMPLETE", n[n.CB_CHUNK_HEADER = 19] = "CB_CHUNK_HEADER", n[n.CB_CHUNK_COMPLETE = 20] = "CB_CHUNK_COMPLETE", n[n.PAUSED = 21] = "PAUSED", n[n.PAUSED_UPGRADE = 22] = "PAUSED_UPGRADE", n[n.PAUSED_H2_UPGRADE = 23] = "PAUSED_H2_UPGRADE", n[n.USER = 24] = "USER";
    })(r.ERROR || (r.ERROR = {})), function(n) {
      n[n.BOTH = 0] = "BOTH", n[n.REQUEST = 1] = "REQUEST", n[n.RESPONSE = 2] = "RESPONSE";
    }(r.TYPE || (r.TYPE = {})), function(n) {
      n[n.CONNECTION_KEEP_ALIVE = 1] = "CONNECTION_KEEP_ALIVE", n[n.CONNECTION_CLOSE = 2] = "CONNECTION_CLOSE", n[n.CONNECTION_UPGRADE = 4] = "CONNECTION_UPGRADE", n[n.CHUNKED = 8] = "CHUNKED", n[n.UPGRADE = 16] = "UPGRADE", n[n.CONTENT_LENGTH = 32] = "CONTENT_LENGTH", n[n.SKIPBODY = 64] = "SKIPBODY", n[n.TRAILING = 128] = "TRAILING", n[n.TRANSFER_ENCODING = 512] = "TRANSFER_ENCODING";
    }(r.FLAGS || (r.FLAGS = {})), function(n) {
      n[n.HEADERS = 1] = "HEADERS", n[n.CHUNKED_LENGTH = 2] = "CHUNKED_LENGTH", n[n.KEEP_ALIVE = 4] = "KEEP_ALIVE";
    }(r.LENIENT_FLAGS || (r.LENIENT_FLAGS = {}));
    var e;
    (function(n) {
      n[n.DELETE = 0] = "DELETE", n[n.GET = 1] = "GET", n[n.HEAD = 2] = "HEAD", n[n.POST = 3] = "POST", n[n.PUT = 4] = "PUT", n[n.CONNECT = 5] = "CONNECT", n[n.OPTIONS = 6] = "OPTIONS", n[n.TRACE = 7] = "TRACE", n[n.COPY = 8] = "COPY", n[n.LOCK = 9] = "LOCK", n[n.MKCOL = 10] = "MKCOL", n[n.MOVE = 11] = "MOVE", n[n.PROPFIND = 12] = "PROPFIND", n[n.PROPPATCH = 13] = "PROPPATCH", n[n.SEARCH = 14] = "SEARCH", n[n.UNLOCK = 15] = "UNLOCK", n[n.BIND = 16] = "BIND", n[n.REBIND = 17] = "REBIND", n[n.UNBIND = 18] = "UNBIND", n[n.ACL = 19] = "ACL", n[n.REPORT = 20] = "REPORT", n[n.MKACTIVITY = 21] = "MKACTIVITY", n[n.CHECKOUT = 22] = "CHECKOUT", n[n.MERGE = 23] = "MERGE", n[n["M-SEARCH"] = 24] = "M-SEARCH", n[n.NOTIFY = 25] = "NOTIFY", n[n.SUBSCRIBE = 26] = "SUBSCRIBE", n[n.UNSUBSCRIBE = 27] = "UNSUBSCRIBE", n[n.PATCH = 28] = "PATCH", n[n.PURGE = 29] = "PURGE", n[n.MKCALENDAR = 30] = "MKCALENDAR", n[n.LINK = 31] = "LINK", n[n.UNLINK = 32] = "UNLINK", n[n.SOURCE = 33] = "SOURCE", n[n.PRI = 34] = "PRI", n[n.DESCRIBE = 35] = "DESCRIBE", n[n.ANNOUNCE = 36] = "ANNOUNCE", n[n.SETUP = 37] = "SETUP", n[n.PLAY = 38] = "PLAY", n[n.PAUSE = 39] = "PAUSE", n[n.TEARDOWN = 40] = "TEARDOWN", n[n.GET_PARAMETER = 41] = "GET_PARAMETER", n[n.SET_PARAMETER = 42] = "SET_PARAMETER", n[n.REDIRECT = 43] = "REDIRECT", n[n.RECORD = 44] = "RECORD", n[n.FLUSH = 45] = "FLUSH";
    })(e = r.METHODS || (r.METHODS = {})), r.METHODS_HTTP = [
      e.DELETE,
      e.GET,
      e.HEAD,
      e.POST,
      e.PUT,
      e.CONNECT,
      e.OPTIONS,
      e.TRACE,
      e.COPY,
      e.LOCK,
      e.MKCOL,
      e.MOVE,
      e.PROPFIND,
      e.PROPPATCH,
      e.SEARCH,
      e.UNLOCK,
      e.BIND,
      e.REBIND,
      e.UNBIND,
      e.ACL,
      e.REPORT,
      e.MKACTIVITY,
      e.CHECKOUT,
      e.MERGE,
      e["M-SEARCH"],
      e.NOTIFY,
      e.SUBSCRIBE,
      e.UNSUBSCRIBE,
      e.PATCH,
      e.PURGE,
      e.MKCALENDAR,
      e.LINK,
      e.UNLINK,
      e.PRI,
      // TODO(indutny): should we allow it with HTTP?
      e.SOURCE
    ], r.METHODS_ICE = [
      e.SOURCE
    ], r.METHODS_RTSP = [
      e.OPTIONS,
      e.DESCRIBE,
      e.ANNOUNCE,
      e.SETUP,
      e.PLAY,
      e.PAUSE,
      e.TEARDOWN,
      e.GET_PARAMETER,
      e.SET_PARAMETER,
      e.REDIRECT,
      e.RECORD,
      e.FLUSH,
      // For AirPlay
      e.GET,
      e.POST
    ], r.METHOD_MAP = t.enumToMap(e), r.H_METHOD_MAP = {}, Object.keys(r.METHOD_MAP).forEach((n) => {
      /^H/.test(n) && (r.H_METHOD_MAP[n] = r.METHOD_MAP[n]);
    }), function(n) {
      n[n.SAFE = 0] = "SAFE", n[n.SAFE_WITH_CB = 1] = "SAFE_WITH_CB", n[n.UNSAFE = 2] = "UNSAFE";
    }(r.FINISH || (r.FINISH = {})), r.ALPHA = [];
    for (let n = 65; n <= 90; n++)
      r.ALPHA.push(String.fromCharCode(n)), r.ALPHA.push(String.fromCharCode(n + 32));
    r.NUM_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9
    }, r.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15
    }, r.NUM = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9"
    ], r.ALPHANUM = r.ALPHA.concat(r.NUM), r.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"], r.USERINFO_CHARS = r.ALPHANUM.concat(r.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]), r.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~"
    ].concat(r.ALPHANUM), r.URL_CHAR = r.STRICT_URL_CHAR.concat(["	", "\f"]);
    for (let n = 128; n <= 255; n++)
      r.URL_CHAR.push(n);
    r.HEX = r.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]), r.STRICT_TOKEN = [
      "!",
      "#",
      "$",
      "%",
      "&",
      "'",
      "*",
      "+",
      "-",
      ".",
      "^",
      "_",
      "`",
      "|",
      "~"
    ].concat(r.ALPHANUM), r.TOKEN = r.STRICT_TOKEN.concat([" "]), r.HEADER_CHARS = ["	"];
    for (let n = 32; n <= 255; n++)
      n !== 127 && r.HEADER_CHARS.push(n);
    r.CONNECTION_TOKEN_CHARS = r.HEADER_CHARS.filter((n) => n !== 44), r.MAJOR = r.NUM_MAP, r.MINOR = r.MAJOR;
    var A;
    (function(n) {
      n[n.GENERAL = 0] = "GENERAL", n[n.CONNECTION = 1] = "CONNECTION", n[n.CONTENT_LENGTH = 2] = "CONTENT_LENGTH", n[n.TRANSFER_ENCODING = 3] = "TRANSFER_ENCODING", n[n.UPGRADE = 4] = "UPGRADE", n[n.CONNECTION_KEEP_ALIVE = 5] = "CONNECTION_KEEP_ALIVE", n[n.CONNECTION_CLOSE = 6] = "CONNECTION_CLOSE", n[n.CONNECTION_UPGRADE = 7] = "CONNECTION_UPGRADE", n[n.TRANSFER_ENCODING_CHUNKED = 8] = "TRANSFER_ENCODING_CHUNKED";
    })(A = r.HEADER_STATE || (r.HEADER_STATE = {})), r.SPECIAL_HEADERS = {
      connection: A.CONNECTION,
      "content-length": A.CONTENT_LENGTH,
      "proxy-connection": A.CONNECTION,
      "transfer-encoding": A.TRANSFER_ENCODING,
      upgrade: A.UPGRADE
    };
  }(Xa)), Xa;
}
const VA = Ie, { kBodyUsed: kr } = Re, Ds = L, { InvalidArgumentError: af } = ke, of = L, sf = [300, 301, 302, 303, 307, 308], dc = Symbol("body");
class pc {
  constructor(t) {
    this[dc] = t, this[kr] = !1;
  }
  async *[Symbol.asyncIterator]() {
    Ds(!this[kr], "disturbed"), this[kr] = !0, yield* this[dc];
  }
}
let cf = class {
  constructor(t, e, A, n) {
    if (e != null && (!Number.isInteger(e) || e < 0))
      throw new af("maxRedirections must be a positive number");
    VA.validateHandler(n, A.method, A.upgrade), this.dispatch = t, this.location = null, this.abort = null, this.opts = { ...A, maxRedirections: 0 }, this.maxRedirections = e, this.handler = n, this.history = [], VA.isStream(this.opts.body) ? (VA.bodyLength(this.opts.body) === 0 && this.opts.body.on("data", function() {
      Ds(!1);
    }), typeof this.opts.body.readableDidRead != "boolean" && (this.opts.body[kr] = !1, of.prototype.on.call(this.opts.body, "data", function() {
      this[kr] = !0;
    }))) : this.opts.body && typeof this.opts.body.pipeTo == "function" ? this.opts.body = new pc(this.opts.body) : this.opts.body && typeof this.opts.body != "string" && !ArrayBuffer.isView(this.opts.body) && VA.isIterable(this.opts.body) && (this.opts.body = new pc(this.opts.body));
  }
  onConnect(t) {
    this.abort = t, this.handler.onConnect(t, { history: this.history });
  }
  onUpgrade(t, e, A) {
    this.handler.onUpgrade(t, e, A);
  }
  onError(t) {
    this.handler.onError(t);
  }
  onHeaders(t, e, A, n) {
    if (this.location = this.history.length >= this.maxRedirections || VA.isDisturbed(this.opts.body) ? null : lf(t, e), this.opts.origin && this.history.push(new URL(this.opts.path, this.opts.origin)), !this.location)
      return this.handler.onHeaders(t, e, A, n);
    const { origin: i, pathname: a, search: o } = VA.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin))), s = o ? `${a}${o}` : a;
    this.opts.headers = uf(this.opts.headers, t === 303, this.opts.origin !== i), this.opts.path = s, this.opts.origin = i, this.opts.maxRedirections = 0, this.opts.query = null, t === 303 && this.opts.method !== "HEAD" && (this.opts.method = "GET", this.opts.body = null);
  }
  onData(t) {
    if (!this.location)
      return this.handler.onData(t);
  }
  onComplete(t) {
    this.location ? (this.location = null, this.abort = null, this.dispatch(this.opts, this)) : this.handler.onComplete(t);
  }
  onBodySent(t) {
    this.handler.onBodySent && this.handler.onBodySent(t);
  }
};
function lf(r, t) {
  if (sf.indexOf(r) === -1)
    return null;
  for (let e = 0; e < t.length; e += 2)
    if (t[e].toString().toLowerCase() === "location")
      return t[e + 1];
}
function yc(r, t, e) {
  if (r.length === 4)
    return VA.headerNameToString(r) === "host";
  if (t && VA.headerNameToString(r).startsWith("content-"))
    return !0;
  if (e && (r.length === 13 || r.length === 6 || r.length === 19)) {
    const A = VA.headerNameToString(r);
    return A === "authorization" || A === "cookie" || A === "proxy-authorization";
  }
  return !1;
}
function uf(r, t, e) {
  const A = [];
  if (Array.isArray(r))
    for (let n = 0; n < r.length; n += 2)
      yc(r[n], t, e) || A.push(r[n], r[n + 1]);
  else if (r && typeof r == "object")
    for (const n of Object.keys(r))
      yc(n, t, e) || A.push(n, r[n]);
  else
    Ds(r == null, "headers must be an object or an array");
  return A;
}
var uh = cf;
const hf = uh;
function gf({ maxRedirections: r }) {
  return (t) => function(A, n) {
    const { maxRedirections: i = r } = A;
    if (!i)
      return t(A, n);
    const a = new hf(t, i, A, n);
    return A = { ...A, maxRedirections: 0 }, t(A, a);
  };
}
var Ns = gf, Za, mc;
function wc() {
  return mc || (mc = 1, Za = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQDscBAAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxweHyAhIyUoP0BBREVGR0hJSktMTU9QUVJT3gNXWVtcXWBiZWZnaGlqa2xtb3BxcnN0dXZ3eHl6e3x9foABggGFAYYBhwGJAYsBjAGNAY4BjwGQAZEBlAGVAZYBlwGYAZkBmgGbAZwBnQGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAcYBxwHIAckBygHLAcwBzQHOAc8B0AHRAdIB0wHUAdUB1gHXAdgB2QHaAdsB3AHdAd4B4AHhAeIB4wHkAeUB5gHnAegB6QHqAesB7AHtAe4B7wHwAfEB8gHzAZkCpAKwAv4C/gILIAEiBCACRw3zAUHdASEQDP8DCyABIhAgAkcN3QFBwwEhEAz+AwsgASIBIAJHDZABQfcAIRAM/QMLIAEiASACRw2GAUHvACEQDPwDCyABIgEgAkcNf0HqACEQDPsDCyABIgEgAkcNe0HoACEQDPoDCyABIgEgAkcNeEHmACEQDPkDCyABIgEgAkcNGkEYIRAM+AMLIAEiASACRw0UQRIhEAz3AwsgASIBIAJHDVlBxQAhEAz2AwsgASIBIAJHDUpBPyEQDPUDCyABIgEgAkcNSEE8IRAM9AMLIAEiASACRw1BQTEhEAzzAwsgAC0ALkEBRg3rAwyHAgsgACABIgEgAhDAgICAAEEBRw3mASAAQgA3AyAM5wELIAAgASIBIAIQtICAgAAiEA3nASABIQEM9QILAkAgASIBIAJHDQBBBiEQDPADCyAAIAFBAWoiASACELuAgIAAIhAN6AEgASEBDDELIABCADcDIEESIRAM1QMLIAEiECACRw0rQR0hEAztAwsCQCABIgEgAkYNACABQQFqIQFBECEQDNQDC0EHIRAM7AMLIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN5QFBCCEQDOsDCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEUIRAM0gMLQQkhEAzqAwsgASEBIAApAyBQDeQBIAEhAQzyAgsCQCABIgEgAkcNAEELIRAM6QMLIAAgAUEBaiIBIAIQtoCAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3lASABIQEM8gILIAAgASIBIAIQuICAgAAiEA3mASABIQEMDQsgACABIgEgAhC6gICAACIQDecBIAEhAQzwAgsCQCABIgEgAkcNAEEPIRAM5QMLIAEtAAAiEEE7Rg0IIBBBDUcN6AEgAUEBaiEBDO8CCyAAIAEiASACELqAgIAAIhAN6AEgASEBDPICCwNAAkAgAS0AAEHwtYCAAGotAAAiEEEBRg0AIBBBAkcN6wEgACgCBCEQIABBADYCBCAAIBAgAUEBaiIBELmAgIAAIhAN6gEgASEBDPQCCyABQQFqIgEgAkcNAAtBEiEQDOIDCyAAIAEiASACELqAgIAAIhAN6QEgASEBDAoLIAEiASACRw0GQRshEAzgAwsCQCABIgEgAkcNAEEWIRAM4AMLIABBioCAgAA2AgggACABNgIEIAAgASACELiAgIAAIhAN6gEgASEBQSAhEAzGAwsCQCABIgEgAkYNAANAAkAgAS0AAEHwt4CAAGotAAAiEEECRg0AAkAgEEF/ag4E5QHsAQDrAewBCyABQQFqIQFBCCEQDMgDCyABQQFqIgEgAkcNAAtBFSEQDN8DC0EVIRAM3gMLA0ACQCABLQAAQfC5gIAAai0AACIQQQJGDQAgEEF/ag4E3gHsAeAB6wHsAQsgAUEBaiIBIAJHDQALQRghEAzdAwsCQCABIgEgAkYNACAAQYuAgIAANgIIIAAgATYCBCABIQFBByEQDMQDC0EZIRAM3AMLIAFBAWohAQwCCwJAIAEiFCACRw0AQRohEAzbAwsgFCEBAkAgFC0AAEFzag4U3QLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gLuAu4C7gIA7gILQQAhECAAQQA2AhwgAEGvi4CAADYCECAAQQI2AgwgACAUQQFqNgIUDNoDCwJAIAEtAAAiEEE7Rg0AIBBBDUcN6AEgAUEBaiEBDOUCCyABQQFqIQELQSIhEAy/AwsCQCABIhAgAkcNAEEcIRAM2AMLQgAhESAQIQEgEC0AAEFQag435wHmAQECAwQFBgcIAAAAAAAAAAkKCwwNDgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADxAREhMUAAtBHiEQDL0DC0ICIREM5QELQgMhEQzkAQtCBCERDOMBC0IFIREM4gELQgYhEQzhAQtCByERDOABC0IIIREM3wELQgkhEQzeAQtCCiERDN0BC0ILIREM3AELQgwhEQzbAQtCDSERDNoBC0IOIREM2QELQg8hEQzYAQtCCiERDNcBC0ILIREM1gELQgwhEQzVAQtCDSERDNQBC0IOIREM0wELQg8hEQzSAQtCACERAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAQLQAAQVBqDjflAeQBAAECAwQFBgfmAeYB5gHmAeYB5gHmAQgJCgsMDeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gHmAeYB5gEODxAREhPmAQtCAiERDOQBC0IDIREM4wELQgQhEQziAQtCBSERDOEBC0IGIREM4AELQgchEQzfAQtCCCERDN4BC0IJIREM3QELQgohEQzcAQtCCyERDNsBC0IMIREM2gELQg0hEQzZAQtCDiERDNgBC0IPIREM1wELQgohEQzWAQtCCyERDNUBC0IMIREM1AELQg0hEQzTAQtCDiERDNIBC0IPIREM0QELIABCACAAKQMgIhEgAiABIhBrrSISfSITIBMgEVYbNwMgIBEgElYiFEUN0gFBHyEQDMADCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEkIRAMpwMLQSAhEAy/AwsgACABIhAgAhC+gICAAEF/ag4FtgEAxQIB0QHSAQtBESEQDKQDCyAAQQE6AC8gECEBDLsDCyABIgEgAkcN0gFBJCEQDLsDCyABIg0gAkcNHkHGACEQDLoDCyAAIAEiASACELKAgIAAIhAN1AEgASEBDLUBCyABIhAgAkcNJkHQACEQDLgDCwJAIAEiASACRw0AQSghEAy4AwsgAEEANgIEIABBjICAgAA2AgggACABIAEQsYCAgAAiEA3TASABIQEM2AELAkAgASIQIAJHDQBBKSEQDLcDCyAQLQAAIgFBIEYNFCABQQlHDdMBIBBBAWohAQwVCwJAIAEiASACRg0AIAFBAWohAQwXC0EqIRAMtQMLAkAgASIQIAJHDQBBKyEQDLUDCwJAIBAtAAAiAUEJRg0AIAFBIEcN1QELIAAtACxBCEYN0wEgECEBDJEDCwJAIAEiASACRw0AQSwhEAy0AwsgAS0AAEEKRw3VASABQQFqIQEMyQILIAEiDiACRw3VAUEvIRAMsgMLA0ACQCABLQAAIhBBIEYNAAJAIBBBdmoOBADcAdwBANoBCyABIQEM4AELIAFBAWoiASACRw0AC0ExIRAMsQMLQTIhECABIhQgAkYNsAMgAiAUayAAKAIAIgFqIRUgFCABa0EDaiEWAkADQCAULQAAIhdBIHIgFyAXQb9/akH/AXFBGkkbQf8BcSABQfC7gIAAai0AAEcNAQJAIAFBA0cNAEEGIQEMlgMLIAFBAWohASAUQQFqIhQgAkcNAAsgACAVNgIADLEDCyAAQQA2AgAgFCEBDNkBC0EzIRAgASIUIAJGDa8DIAIgFGsgACgCACIBaiEVIBQgAWtBCGohFgJAA0AgFC0AACIXQSByIBcgF0G/f2pB/wFxQRpJG0H/AXEgAUH0u4CAAGotAABHDQECQCABQQhHDQBBBSEBDJUDCyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFTYCAAywAwsgAEEANgIAIBQhAQzYAQtBNCEQIAEiFCACRg2uAyACIBRrIAAoAgAiAWohFSAUIAFrQQVqIRYCQANAIBQtAAAiF0EgciAXIBdBv39qQf8BcUEaSRtB/wFxIAFB0MKAgABqLQAARw0BAkAgAUEFRw0AQQchAQyUAwsgAUEBaiEBIBRBAWoiFCACRw0ACyAAIBU2AgAMrwMLIABBADYCACAUIQEM1wELAkAgASIBIAJGDQADQAJAIAEtAABBgL6AgABqLQAAIhBBAUYNACAQQQJGDQogASEBDN0BCyABQQFqIgEgAkcNAAtBMCEQDK4DC0EwIRAMrQMLAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgRg0AIBBBdmoOBNkB2gHaAdkB2gELIAFBAWoiASACRw0AC0E4IRAMrQMLQTghEAysAwsDQAJAIAEtAAAiEEEgRg0AIBBBCUcNAwsgAUEBaiIBIAJHDQALQTwhEAyrAwsDQAJAIAEtAAAiEEEgRg0AAkACQCAQQXZqDgTaAQEB2gEACyAQQSxGDdsBCyABIQEMBAsgAUEBaiIBIAJHDQALQT8hEAyqAwsgASEBDNsBC0HAACEQIAEiFCACRg2oAyACIBRrIAAoAgAiAWohFiAUIAFrQQZqIRcCQANAIBQtAABBIHIgAUGAwICAAGotAABHDQEgAUEGRg2OAyABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAypAwsgAEEANgIAIBQhAQtBNiEQDI4DCwJAIAEiDyACRw0AQcEAIRAMpwMLIABBjICAgAA2AgggACAPNgIEIA8hASAALQAsQX9qDgTNAdUB1wHZAYcDCyABQQFqIQEMzAELAkAgASIBIAJGDQADQAJAIAEtAAAiEEEgciAQIBBBv39qQf8BcUEaSRtB/wFxIhBBCUYNACAQQSBGDQACQAJAAkACQCAQQZ1/ag4TAAMDAwMDAwMBAwMDAwMDAwMDAgMLIAFBAWohAUExIRAMkQMLIAFBAWohAUEyIRAMkAMLIAFBAWohAUEzIRAMjwMLIAEhAQzQAQsgAUEBaiIBIAJHDQALQTUhEAylAwtBNSEQDKQDCwJAIAEiASACRg0AA0ACQCABLQAAQYC8gIAAai0AAEEBRg0AIAEhAQzTAQsgAUEBaiIBIAJHDQALQT0hEAykAwtBPSEQDKMDCyAAIAEiASACELCAgIAAIhAN1gEgASEBDAELIBBBAWohAQtBPCEQDIcDCwJAIAEiASACRw0AQcIAIRAMoAMLAkADQAJAIAEtAABBd2oOGAAC/gL+AoQD/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4C/gL+Av4CAP4CCyABQQFqIgEgAkcNAAtBwgAhEAygAwsgAUEBaiEBIAAtAC1BAXFFDb0BIAEhAQtBLCEQDIUDCyABIgEgAkcN0wFBxAAhEAydAwsDQAJAIAEtAABBkMCAgABqLQAAQQFGDQAgASEBDLcCCyABQQFqIgEgAkcNAAtBxQAhEAycAwsgDS0AACIQQSBGDbMBIBBBOkcNgQMgACgCBCEBIABBADYCBCAAIAEgDRCvgICAACIBDdABIA1BAWohAQyzAgtBxwAhECABIg0gAkYNmgMgAiANayAAKAIAIgFqIRYgDSABa0EFaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGQwoCAAGotAABHDYADIAFBBUYN9AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMmgMLQcgAIRAgASINIAJGDZkDIAIgDWsgACgCACIBaiEWIA0gAWtBCWohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBlsKAgABqLQAARw3/AgJAIAFBCUcNAEECIQEM9QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJkDCwJAIAEiDSACRw0AQckAIRAMmQMLAkACQCANLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGSf2oOBwCAA4ADgAOAA4ADAYADCyANQQFqIQFBPiEQDIADCyANQQFqIQFBPyEQDP8CC0HKACEQIAEiDSACRg2XAyACIA1rIAAoAgAiAWohFiANIAFrQQFqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQaDCgIAAai0AAEcN/QIgAUEBRg3wAiABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyXAwtBywAhECABIg0gAkYNlgMgAiANayAAKAIAIgFqIRYgDSABa0EOaiEXA0AgDS0AACIUQSByIBQgFEG/f2pB/wFxQRpJG0H/AXEgAUGiwoCAAGotAABHDfwCIAFBDkYN8AIgAUEBaiEBIA1BAWoiDSACRw0ACyAAIBY2AgAMlgMLQcwAIRAgASINIAJGDZUDIAIgDWsgACgCACIBaiEWIA0gAWtBD2ohFwNAIA0tAAAiFEEgciAUIBRBv39qQf8BcUEaSRtB/wFxIAFBwMKAgABqLQAARw37AgJAIAFBD0cNAEEDIQEM8QILIAFBAWohASANQQFqIg0gAkcNAAsgACAWNgIADJUDC0HNACEQIAEiDSACRg2UAyACIA1rIAAoAgAiAWohFiANIAFrQQVqIRcDQCANLQAAIhRBIHIgFCAUQb9/akH/AXFBGkkbQf8BcSABQdDCgIAAai0AAEcN+gICQCABQQVHDQBBBCEBDPACCyABQQFqIQEgDUEBaiINIAJHDQALIAAgFjYCAAyUAwsCQCABIg0gAkcNAEHOACEQDJQDCwJAAkACQAJAIA0tAAAiAUEgciABIAFBv39qQf8BcUEaSRtB/wFxQZ1/ag4TAP0C/QL9Av0C/QL9Av0C/QL9Av0C/QL9AgH9Av0C/QICA/0CCyANQQFqIQFBwQAhEAz9AgsgDUEBaiEBQcIAIRAM/AILIA1BAWohAUHDACEQDPsCCyANQQFqIQFBxAAhEAz6AgsCQCABIgEgAkYNACAAQY2AgIAANgIIIAAgATYCBCABIQFBxQAhEAz6AgtBzwAhEAySAwsgECEBAkACQCAQLQAAQXZqDgQBqAKoAgCoAgsgEEEBaiEBC0EnIRAM+AILAkAgASIBIAJHDQBB0QAhEAyRAwsCQCABLQAAQSBGDQAgASEBDI0BCyABQQFqIQEgAC0ALUEBcUUNxwEgASEBDIwBCyABIhcgAkcNyAFB0gAhEAyPAwtB0wAhECABIhQgAkYNjgMgAiAUayAAKAIAIgFqIRYgFCABa0EBaiEXA0AgFC0AACABQdbCgIAAai0AAEcNzAEgAUEBRg3HASABQQFqIQEgFEEBaiIUIAJHDQALIAAgFjYCAAyOAwsCQCABIgEgAkcNAEHVACEQDI4DCyABLQAAQQpHDcwBIAFBAWohAQzHAQsCQCABIgEgAkcNAEHWACEQDI0DCwJAAkAgAS0AAEF2ag4EAM0BzQEBzQELIAFBAWohAQzHAQsgAUEBaiEBQcoAIRAM8wILIAAgASIBIAIQroCAgAAiEA3LASABIQFBzQAhEAzyAgsgAC0AKUEiRg2FAwymAgsCQCABIgEgAkcNAEHbACEQDIoDC0EAIRRBASEXQQEhFkEAIRACQAJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4K1AHTAQABAgMEBQYI1QELQQIhEAwGC0EDIRAMBQtBBCEQDAQLQQUhEAwDC0EGIRAMAgtBByEQDAELQQghEAtBACEXQQAhFkEAIRQMzAELQQkhEEEBIRRBACEXQQAhFgzLAQsCQCABIgEgAkcNAEHdACEQDIkDCyABLQAAQS5HDcwBIAFBAWohAQymAgsgASIBIAJHDcwBQd8AIRAMhwMLAkAgASIBIAJGDQAgAEGOgICAADYCCCAAIAE2AgQgASEBQdAAIRAM7gILQeAAIRAMhgMLQeEAIRAgASIBIAJGDYUDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHiwoCAAGotAABHDc0BIBRBA0YNzAEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhQMLQeIAIRAgASIBIAJGDYQDIAIgAWsgACgCACIUaiEWIAEgFGtBAmohFwNAIAEtAAAgFEHmwoCAAGotAABHDcwBIBRBAkYNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMhAMLQeMAIRAgASIBIAJGDYMDIAIgAWsgACgCACIUaiEWIAEgFGtBA2ohFwNAIAEtAAAgFEHpwoCAAGotAABHDcsBIBRBA0YNzgEgFEEBaiEUIAFBAWoiASACRw0ACyAAIBY2AgAMgwMLAkAgASIBIAJHDQBB5QAhEAyDAwsgACABQQFqIgEgAhCogICAACIQDc0BIAEhAUHWACEQDOkCCwJAIAEiASACRg0AA0ACQCABLQAAIhBBIEYNAAJAAkACQCAQQbh/ag4LAAHPAc8BzwHPAc8BzwHPAc8BAs8BCyABQQFqIQFB0gAhEAztAgsgAUEBaiEBQdMAIRAM7AILIAFBAWohAUHUACEQDOsCCyABQQFqIgEgAkcNAAtB5AAhEAyCAwtB5AAhEAyBAwsDQAJAIAEtAABB8MKAgABqLQAAIhBBAUYNACAQQX5qDgPPAdAB0QHSAQsgAUEBaiIBIAJHDQALQeYAIRAMgAMLAkAgASIBIAJGDQAgAUEBaiEBDAMLQecAIRAM/wILA0ACQCABLQAAQfDEgIAAai0AACIQQQFGDQACQCAQQX5qDgTSAdMB1AEA1QELIAEhAUHXACEQDOcCCyABQQFqIgEgAkcNAAtB6AAhEAz+AgsCQCABIgEgAkcNAEHpACEQDP4CCwJAIAEtAAAiEEF2ag4augHVAdUBvAHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHVAdUB1QHKAdUB1QEA0wELIAFBAWohAQtBBiEQDOMCCwNAAkAgAS0AAEHwxoCAAGotAABBAUYNACABIQEMngILIAFBAWoiASACRw0AC0HqACEQDPsCCwJAIAEiASACRg0AIAFBAWohAQwDC0HrACEQDPoCCwJAIAEiASACRw0AQewAIRAM+gILIAFBAWohAQwBCwJAIAEiASACRw0AQe0AIRAM+QILIAFBAWohAQtBBCEQDN4CCwJAIAEiFCACRw0AQe4AIRAM9wILIBQhAQJAAkACQCAULQAAQfDIgIAAai0AAEF/ag4H1AHVAdYBAJwCAQLXAQsgFEEBaiEBDAoLIBRBAWohAQzNAQtBACEQIABBADYCHCAAQZuSgIAANgIQIABBBzYCDCAAIBRBAWo2AhQM9gILAkADQAJAIAEtAABB8MiAgABqLQAAIhBBBEYNAAJAAkAgEEF/ag4H0gHTAdQB2QEABAHZAQsgASEBQdoAIRAM4AILIAFBAWohAUHcACEQDN8CCyABQQFqIgEgAkcNAAtB7wAhEAz2AgsgAUEBaiEBDMsBCwJAIAEiFCACRw0AQfAAIRAM9QILIBQtAABBL0cN1AEgFEEBaiEBDAYLAkAgASIUIAJHDQBB8QAhEAz0AgsCQCAULQAAIgFBL0cNACAUQQFqIQFB3QAhEAzbAgsgAUF2aiIEQRZLDdMBQQEgBHRBiYCAAnFFDdMBDMoCCwJAIAEiASACRg0AIAFBAWohAUHeACEQDNoCC0HyACEQDPICCwJAIAEiFCACRw0AQfQAIRAM8gILIBQhAQJAIBQtAABB8MyAgABqLQAAQX9qDgPJApQCANQBC0HhACEQDNgCCwJAIAEiFCACRg0AA0ACQCAULQAAQfDKgIAAai0AACIBQQNGDQACQCABQX9qDgLLAgDVAQsgFCEBQd8AIRAM2gILIBRBAWoiFCACRw0AC0HzACEQDPECC0HzACEQDPACCwJAIAEiASACRg0AIABBj4CAgAA2AgggACABNgIEIAEhAUHgACEQDNcCC0H1ACEQDO8CCwJAIAEiASACRw0AQfYAIRAM7wILIABBj4CAgAA2AgggACABNgIEIAEhAQtBAyEQDNQCCwNAIAEtAABBIEcNwwIgAUEBaiIBIAJHDQALQfcAIRAM7AILAkAgASIBIAJHDQBB+AAhEAzsAgsgAS0AAEEgRw3OASABQQFqIQEM7wELIAAgASIBIAIQrICAgAAiEA3OASABIQEMjgILAkAgASIEIAJHDQBB+gAhEAzqAgsgBC0AAEHMAEcN0QEgBEEBaiEBQRMhEAzPAQsCQCABIgQgAkcNAEH7ACEQDOkCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRADQCAELQAAIAFB8M6AgABqLQAARw3QASABQQVGDc4BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQfsAIRAM6AILAkAgASIEIAJHDQBB/AAhEAzoAgsCQAJAIAQtAABBvX9qDgwA0QHRAdEB0QHRAdEB0QHRAdEB0QEB0QELIARBAWohAUHmACEQDM8CCyAEQQFqIQFB5wAhEAzOAgsCQCABIgQgAkcNAEH9ACEQDOcCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDc8BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH9ACEQDOcCCyAAQQA2AgAgEEEBaiEBQRAhEAzMAQsCQCABIgQgAkcNAEH+ACEQDOYCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUH2zoCAAGotAABHDc4BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH+ACEQDOYCCyAAQQA2AgAgEEEBaiEBQRYhEAzLAQsCQCABIgQgAkcNAEH/ACEQDOUCCyACIARrIAAoAgAiAWohFCAEIAFrQQNqIRACQANAIAQtAAAgAUH8zoCAAGotAABHDc0BIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEH/ACEQDOUCCyAAQQA2AgAgEEEBaiEBQQUhEAzKAQsCQCABIgQgAkcNAEGAASEQDOQCCyAELQAAQdkARw3LASAEQQFqIQFBCCEQDMkBCwJAIAEiBCACRw0AQYEBIRAM4wILAkACQCAELQAAQbJ/ag4DAMwBAcwBCyAEQQFqIQFB6wAhEAzKAgsgBEEBaiEBQewAIRAMyQILAkAgASIEIAJHDQBBggEhEAziAgsCQAJAIAQtAABBuH9qDggAywHLAcsBywHLAcsBAcsBCyAEQQFqIQFB6gAhEAzJAgsgBEEBaiEBQe0AIRAMyAILAkAgASIEIAJHDQBBgwEhEAzhAgsgAiAEayAAKAIAIgFqIRAgBCABa0ECaiEUAkADQCAELQAAIAFBgM+AgABqLQAARw3JASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBA2AgBBgwEhEAzhAgtBACEQIABBADYCACAUQQFqIQEMxgELAkAgASIEIAJHDQBBhAEhEAzgAgsgAiAEayAAKAIAIgFqIRQgBCABa0EEaiEQAkADQCAELQAAIAFBg8+AgABqLQAARw3IASABQQRGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBhAEhEAzgAgsgAEEANgIAIBBBAWohAUEjIRAMxQELAkAgASIEIAJHDQBBhQEhEAzfAgsCQAJAIAQtAABBtH9qDggAyAHIAcgByAHIAcgBAcgBCyAEQQFqIQFB7wAhEAzGAgsgBEEBaiEBQfAAIRAMxQILAkAgASIEIAJHDQBBhgEhEAzeAgsgBC0AAEHFAEcNxQEgBEEBaiEBDIMCCwJAIAEiBCACRw0AQYcBIRAM3QILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQYjPgIAAai0AAEcNxQEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYcBIRAM3QILIABBADYCACAQQQFqIQFBLSEQDMIBCwJAIAEiBCACRw0AQYgBIRAM3AILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNxAEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYgBIRAM3AILIABBADYCACAQQQFqIQFBKSEQDMEBCwJAIAEiASACRw0AQYkBIRAM2wILQQEhECABLQAAQd8ARw3AASABQQFqIQEMgQILAkAgASIEIAJHDQBBigEhEAzaAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQA0AgBC0AACABQYzPgIAAai0AAEcNwQEgAUEBRg2vAiABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGKASEQDNkCCwJAIAEiBCACRw0AQYsBIRAM2QILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQY7PgIAAai0AAEcNwQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYsBIRAM2QILIABBADYCACAQQQFqIQFBAiEQDL4BCwJAIAEiBCACRw0AQYwBIRAM2AILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNwAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQYwBIRAM2AILIABBADYCACAQQQFqIQFBHyEQDL0BCwJAIAEiBCACRw0AQY0BIRAM1wILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfLPgIAAai0AAEcNvwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQY0BIRAM1wILIABBADYCACAQQQFqIQFBCSEQDLwBCwJAIAEiBCACRw0AQY4BIRAM1gILAkACQCAELQAAQbd/ag4HAL8BvwG/Ab8BvwEBvwELIARBAWohAUH4ACEQDL0CCyAEQQFqIQFB+QAhEAy8AgsCQCABIgQgAkcNAEGPASEQDNUCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGRz4CAAGotAABHDb0BIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGPASEQDNUCCyAAQQA2AgAgEEEBaiEBQRghEAy6AQsCQCABIgQgAkcNAEGQASEQDNQCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUGXz4CAAGotAABHDbwBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGQASEQDNQCCyAAQQA2AgAgEEEBaiEBQRchEAy5AQsCQCABIgQgAkcNAEGRASEQDNMCCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUGaz4CAAGotAABHDbsBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGRASEQDNMCCyAAQQA2AgAgEEEBaiEBQRUhEAy4AQsCQCABIgQgAkcNAEGSASEQDNICCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGhz4CAAGotAABHDboBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGSASEQDNICCyAAQQA2AgAgEEEBaiEBQR4hEAy3AQsCQCABIgQgAkcNAEGTASEQDNECCyAELQAAQcwARw24ASAEQQFqIQFBCiEQDLYBCwJAIAQgAkcNAEGUASEQDNACCwJAAkAgBC0AAEG/f2oODwC5AbkBuQG5AbkBuQG5AbkBuQG5AbkBuQG5AQG5AQsgBEEBaiEBQf4AIRAMtwILIARBAWohAUH/ACEQDLYCCwJAIAQgAkcNAEGVASEQDM8CCwJAAkAgBC0AAEG/f2oOAwC4AQG4AQsgBEEBaiEBQf0AIRAMtgILIARBAWohBEGAASEQDLUCCwJAIAQgAkcNAEGWASEQDM4CCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUGnz4CAAGotAABHDbYBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGWASEQDM4CCyAAQQA2AgAgEEEBaiEBQQshEAyzAQsCQCAEIAJHDQBBlwEhEAzNAgsCQAJAAkACQCAELQAAQVNqDiMAuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AbgBuAG4AQG4AbgBuAG4AbgBArgBuAG4AQO4AQsgBEEBaiEBQfsAIRAMtgILIARBAWohAUH8ACEQDLUCCyAEQQFqIQRBgQEhEAy0AgsgBEEBaiEEQYIBIRAMswILAkAgBCACRw0AQZgBIRAMzAILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQanPgIAAai0AAEcNtAEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZgBIRAMzAILIABBADYCACAQQQFqIQFBGSEQDLEBCwJAIAQgAkcNAEGZASEQDMsCCyACIARrIAAoAgAiAWohFCAEIAFrQQVqIRACQANAIAQtAAAgAUGuz4CAAGotAABHDbMBIAFBBUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGZASEQDMsCCyAAQQA2AgAgEEEBaiEBQQYhEAywAQsCQCAEIAJHDQBBmgEhEAzKAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBtM+AgABqLQAARw2yASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBmgEhEAzKAgsgAEEANgIAIBBBAWohAUEcIRAMrwELAkAgBCACRw0AQZsBIRAMyQILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbbPgIAAai0AAEcNsQEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZsBIRAMyQILIABBADYCACAQQQFqIQFBJyEQDK4BCwJAIAQgAkcNAEGcASEQDMgCCwJAAkAgBC0AAEGsf2oOAgABsQELIARBAWohBEGGASEQDK8CCyAEQQFqIQRBhwEhEAyuAgsCQCAEIAJHDQBBnQEhEAzHAgsgAiAEayAAKAIAIgFqIRQgBCABa0EBaiEQAkADQCAELQAAIAFBuM+AgABqLQAARw2vASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBnQEhEAzHAgsgAEEANgIAIBBBAWohAUEmIRAMrAELAkAgBCACRw0AQZ4BIRAMxgILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQbrPgIAAai0AAEcNrgEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQZ4BIRAMxgILIABBADYCACAQQQFqIQFBAyEQDKsBCwJAIAQgAkcNAEGfASEQDMUCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDa0BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGfASEQDMUCCyAAQQA2AgAgEEEBaiEBQQwhEAyqAQsCQCAEIAJHDQBBoAEhEAzEAgsgAiAEayAAKAIAIgFqIRQgBCABa0EDaiEQAkADQCAELQAAIAFBvM+AgABqLQAARw2sASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBoAEhEAzEAgsgAEEANgIAIBBBAWohAUENIRAMqQELAkAgBCACRw0AQaEBIRAMwwILAkACQCAELQAAQbp/ag4LAKwBrAGsAawBrAGsAawBrAGsAQGsAQsgBEEBaiEEQYsBIRAMqgILIARBAWohBEGMASEQDKkCCwJAIAQgAkcNAEGiASEQDMICCyAELQAAQdAARw2pASAEQQFqIQQM6QELAkAgBCACRw0AQaMBIRAMwQILAkACQCAELQAAQbd/ag4HAaoBqgGqAaoBqgEAqgELIARBAWohBEGOASEQDKgCCyAEQQFqIQFBIiEQDKYBCwJAIAQgAkcNAEGkASEQDMACCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHAz4CAAGotAABHDagBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGkASEQDMACCyAAQQA2AgAgEEEBaiEBQR0hEAylAQsCQCAEIAJHDQBBpQEhEAy/AgsCQAJAIAQtAABBrn9qDgMAqAEBqAELIARBAWohBEGQASEQDKYCCyAEQQFqIQFBBCEQDKQBCwJAIAQgAkcNAEGmASEQDL4CCwJAAkACQAJAAkAgBC0AAEG/f2oOFQCqAaoBqgGqAaoBqgGqAaoBqgGqAQGqAaoBAqoBqgEDqgGqAQSqAQsgBEEBaiEEQYgBIRAMqAILIARBAWohBEGJASEQDKcCCyAEQQFqIQRBigEhEAymAgsgBEEBaiEEQY8BIRAMpQILIARBAWohBEGRASEQDKQCCwJAIAQgAkcNAEGnASEQDL0CCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHtz4CAAGotAABHDaUBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGnASEQDL0CCyAAQQA2AgAgEEEBaiEBQREhEAyiAQsCQCAEIAJHDQBBqAEhEAy8AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBws+AgABqLQAARw2kASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBqAEhEAy8AgsgAEEANgIAIBBBAWohAUEsIRAMoQELAkAgBCACRw0AQakBIRAMuwILIAIgBGsgACgCACIBaiEUIAQgAWtBBGohEAJAA0AgBC0AACABQcXPgIAAai0AAEcNowEgAUEERg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQakBIRAMuwILIABBADYCACAQQQFqIQFBKyEQDKABCwJAIAQgAkcNAEGqASEQDLoCCyACIARrIAAoAgAiAWohFCAEIAFrQQJqIRACQANAIAQtAAAgAUHKz4CAAGotAABHDaIBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGqASEQDLoCCyAAQQA2AgAgEEEBaiEBQRQhEAyfAQsCQCAEIAJHDQBBqwEhEAy5AgsCQAJAAkACQCAELQAAQb5/ag4PAAECpAGkAaQBpAGkAaQBpAGkAaQBpAGkAQOkAQsgBEEBaiEEQZMBIRAMogILIARBAWohBEGUASEQDKECCyAEQQFqIQRBlQEhEAygAgsgBEEBaiEEQZYBIRAMnwILAkAgBCACRw0AQawBIRAMuAILIAQtAABBxQBHDZ8BIARBAWohBAzgAQsCQCAEIAJHDQBBrQEhEAy3AgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFBzc+AgABqLQAARw2fASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBrQEhEAy3AgsgAEEANgIAIBBBAWohAUEOIRAMnAELAkAgBCACRw0AQa4BIRAMtgILIAQtAABB0ABHDZ0BIARBAWohAUElIRAMmwELAkAgBCACRw0AQa8BIRAMtQILIAIgBGsgACgCACIBaiEUIAQgAWtBCGohEAJAA0AgBC0AACABQdDPgIAAai0AAEcNnQEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQa8BIRAMtQILIABBADYCACAQQQFqIQFBKiEQDJoBCwJAIAQgAkcNAEGwASEQDLQCCwJAAkAgBC0AAEGrf2oOCwCdAZ0BnQGdAZ0BnQGdAZ0BnQEBnQELIARBAWohBEGaASEQDJsCCyAEQQFqIQRBmwEhEAyaAgsCQCAEIAJHDQBBsQEhEAyzAgsCQAJAIAQtAABBv39qDhQAnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBnAGcAZwBAZwBCyAEQQFqIQRBmQEhEAyaAgsgBEEBaiEEQZwBIRAMmQILAkAgBCACRw0AQbIBIRAMsgILIAIgBGsgACgCACIBaiEUIAQgAWtBA2ohEAJAA0AgBC0AACABQdnPgIAAai0AAEcNmgEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbIBIRAMsgILIABBADYCACAQQQFqIQFBISEQDJcBCwJAIAQgAkcNAEGzASEQDLECCyACIARrIAAoAgAiAWohFCAEIAFrQQZqIRACQANAIAQtAAAgAUHdz4CAAGotAABHDZkBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEGzASEQDLECCyAAQQA2AgAgEEEBaiEBQRohEAyWAQsCQCAEIAJHDQBBtAEhEAywAgsCQAJAAkAgBC0AAEG7f2oOEQCaAZoBmgGaAZoBmgGaAZoBmgEBmgGaAZoBmgGaAQKaAQsgBEEBaiEEQZ0BIRAMmAILIARBAWohBEGeASEQDJcCCyAEQQFqIQRBnwEhEAyWAgsCQCAEIAJHDQBBtQEhEAyvAgsgAiAEayAAKAIAIgFqIRQgBCABa0EFaiEQAkADQCAELQAAIAFB5M+AgABqLQAARw2XASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBtQEhEAyvAgsgAEEANgIAIBBBAWohAUEoIRAMlAELAkAgBCACRw0AQbYBIRAMrgILIAIgBGsgACgCACIBaiEUIAQgAWtBAmohEAJAA0AgBC0AACABQerPgIAAai0AAEcNlgEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbYBIRAMrgILIABBADYCACAQQQFqIQFBByEQDJMBCwJAIAQgAkcNAEG3ASEQDK0CCwJAAkAgBC0AAEG7f2oODgCWAZYBlgGWAZYBlgGWAZYBlgGWAZYBlgEBlgELIARBAWohBEGhASEQDJQCCyAEQQFqIQRBogEhEAyTAgsCQCAEIAJHDQBBuAEhEAysAgsgAiAEayAAKAIAIgFqIRQgBCABa0ECaiEQAkADQCAELQAAIAFB7c+AgABqLQAARw2UASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBQ2AgBBuAEhEAysAgsgAEEANgIAIBBBAWohAUESIRAMkQELAkAgBCACRw0AQbkBIRAMqwILIAIgBGsgACgCACIBaiEUIAQgAWtBAWohEAJAA0AgBC0AACABQfDPgIAAai0AAEcNkwEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAUNgIAQbkBIRAMqwILIABBADYCACAQQQFqIQFBICEQDJABCwJAIAQgAkcNAEG6ASEQDKoCCyACIARrIAAoAgAiAWohFCAEIAFrQQFqIRACQANAIAQtAAAgAUHyz4CAAGotAABHDZIBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG6ASEQDKoCCyAAQQA2AgAgEEEBaiEBQQ8hEAyPAQsCQCAEIAJHDQBBuwEhEAypAgsCQAJAIAQtAABBt39qDgcAkgGSAZIBkgGSAQGSAQsgBEEBaiEEQaUBIRAMkAILIARBAWohBEGmASEQDI8CCwJAIAQgAkcNAEG8ASEQDKgCCyACIARrIAAoAgAiAWohFCAEIAFrQQdqIRACQANAIAQtAAAgAUH0z4CAAGotAABHDZABIAFBB0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgFDYCAEG8ASEQDKgCCyAAQQA2AgAgEEEBaiEBQRshEAyNAQsCQCAEIAJHDQBBvQEhEAynAgsCQAJAAkAgBC0AAEG+f2oOEgCRAZEBkQGRAZEBkQGRAZEBkQEBkQGRAZEBkQGRAZEBApEBCyAEQQFqIQRBpAEhEAyPAgsgBEEBaiEEQacBIRAMjgILIARBAWohBEGoASEQDI0CCwJAIAQgAkcNAEG+ASEQDKYCCyAELQAAQc4ARw2NASAEQQFqIQQMzwELAkAgBCACRw0AQb8BIRAMpQILAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBC0AAEG/f2oOFQABAgOcAQQFBpwBnAGcAQcICQoLnAEMDQ4PnAELIARBAWohAUHoACEQDJoCCyAEQQFqIQFB6QAhEAyZAgsgBEEBaiEBQe4AIRAMmAILIARBAWohAUHyACEQDJcCCyAEQQFqIQFB8wAhEAyWAgsgBEEBaiEBQfYAIRAMlQILIARBAWohAUH3ACEQDJQCCyAEQQFqIQFB+gAhEAyTAgsgBEEBaiEEQYMBIRAMkgILIARBAWohBEGEASEQDJECCyAEQQFqIQRBhQEhEAyQAgsgBEEBaiEEQZIBIRAMjwILIARBAWohBEGYASEQDI4CCyAEQQFqIQRBoAEhEAyNAgsgBEEBaiEEQaMBIRAMjAILIARBAWohBEGqASEQDIsCCwJAIAQgAkYNACAAQZCAgIAANgIIIAAgBDYCBEGrASEQDIsCC0HAASEQDKMCCyAAIAUgAhCqgICAACIBDYsBIAUhAQxcCwJAIAYgAkYNACAGQQFqIQUMjQELQcIBIRAMoQILA0ACQCAQLQAAQXZqDgSMAQAAjwEACyAQQQFqIhAgAkcNAAtBwwEhEAygAgsCQCAHIAJGDQAgAEGRgICAADYCCCAAIAc2AgQgByEBQQEhEAyHAgtBxAEhEAyfAgsCQCAHIAJHDQBBxQEhEAyfAgsCQAJAIActAABBdmoOBAHOAc4BAM4BCyAHQQFqIQYMjQELIAdBAWohBQyJAQsCQCAHIAJHDQBBxgEhEAyeAgsCQAJAIActAABBdmoOFwGPAY8BAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAQCPAQsgB0EBaiEHC0GwASEQDIQCCwJAIAggAkcNAEHIASEQDJ0CCyAILQAAQSBHDY0BIABBADsBMiAIQQFqIQFBswEhEAyDAgsgASEXAkADQCAXIgcgAkYNASAHLQAAQVBqQf8BcSIQQQpPDcwBAkAgAC8BMiIUQZkzSw0AIAAgFEEKbCIUOwEyIBBB//8DcyAUQf7/A3FJDQAgB0EBaiEXIAAgFCAQaiIQOwEyIBBB//8DcUHoB0kNAQsLQQAhECAAQQA2AhwgAEHBiYCAADYCECAAQQ02AgwgACAHQQFqNgIUDJwCC0HHASEQDJsCCyAAIAggAhCugICAACIQRQ3KASAQQRVHDYwBIABByAE2AhwgACAINgIUIABByZeAgAA2AhAgAEEVNgIMQQAhEAyaAgsCQCAJIAJHDQBBzAEhEAyaAgtBACEUQQEhF0EBIRZBACEQAkACQAJAAkACQAJAAkACQAJAIAktAABBUGoOCpYBlQEAAQIDBAUGCJcBC0ECIRAMBgtBAyEQDAULQQQhEAwEC0EFIRAMAwtBBiEQDAILQQchEAwBC0EIIRALQQAhF0EAIRZBACEUDI4BC0EJIRBBASEUQQAhF0EAIRYMjQELAkAgCiACRw0AQc4BIRAMmQILIAotAABBLkcNjgEgCkEBaiEJDMoBCyALIAJHDY4BQdABIRAMlwILAkAgCyACRg0AIABBjoCAgAA2AgggACALNgIEQbcBIRAM/gELQdEBIRAMlgILAkAgBCACRw0AQdIBIRAMlgILIAIgBGsgACgCACIQaiEUIAQgEGtBBGohCwNAIAQtAAAgEEH8z4CAAGotAABHDY4BIBBBBEYN6QEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB0gEhEAyVAgsgACAMIAIQrICAgAAiAQ2NASAMIQEMuAELAkAgBCACRw0AQdQBIRAMlAILIAIgBGsgACgCACIQaiEUIAQgEGtBAWohDANAIAQtAAAgEEGB0ICAAGotAABHDY8BIBBBAUYNjgEgEEEBaiEQIARBAWoiBCACRw0ACyAAIBQ2AgBB1AEhEAyTAgsCQCAEIAJHDQBB1gEhEAyTAgsgAiAEayAAKAIAIhBqIRQgBCAQa0ECaiELA0AgBC0AACAQQYPQgIAAai0AAEcNjgEgEEECRg2QASAQQQFqIRAgBEEBaiIEIAJHDQALIAAgFDYCAEHWASEQDJICCwJAIAQgAkcNAEHXASEQDJICCwJAAkAgBC0AAEG7f2oOEACPAY8BjwGPAY8BjwGPAY8BjwGPAY8BjwGPAY8BAY8BCyAEQQFqIQRBuwEhEAz5AQsgBEEBaiEEQbwBIRAM+AELAkAgBCACRw0AQdgBIRAMkQILIAQtAABByABHDYwBIARBAWohBAzEAQsCQCAEIAJGDQAgAEGQgICAADYCCCAAIAQ2AgRBvgEhEAz3AQtB2QEhEAyPAgsCQCAEIAJHDQBB2gEhEAyPAgsgBC0AAEHIAEYNwwEgAEEBOgAoDLkBCyAAQQI6AC8gACAEIAIQpoCAgAAiEA2NAUHCASEQDPQBCyAALQAoQX9qDgK3AbkBuAELA0ACQCAELQAAQXZqDgQAjgGOAQCOAQsgBEEBaiIEIAJHDQALQd0BIRAMiwILIABBADoALyAALQAtQQRxRQ2EAgsgAEEAOgAvIABBAToANCABIQEMjAELIBBBFUYN2gEgAEEANgIcIAAgATYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAMiAILAkAgACAQIAIQtICAgAAiBA0AIBAhAQyBAgsCQCAEQRVHDQAgAEEDNgIcIAAgEDYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMiAILIABBADYCHCAAIBA2AhQgAEGnjoCAADYCECAAQRI2AgxBACEQDIcCCyAQQRVGDdYBIABBADYCHCAAIAE2AhQgAEHajYCAADYCECAAQRQ2AgxBACEQDIYCCyAAKAIEIRcgAEEANgIEIBAgEadqIhYhASAAIBcgECAWIBQbIhAQtYCAgAAiFEUNjQEgAEEHNgIcIAAgEDYCFCAAIBQ2AgxBACEQDIUCCyAAIAAvATBBgAFyOwEwIAEhAQtBKiEQDOoBCyAQQRVGDdEBIABBADYCHCAAIAE2AhQgAEGDjICAADYCECAAQRM2AgxBACEQDIICCyAQQRVGDc8BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDIECCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyNAQsgAEEMNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDIACCyAQQRVGDcwBIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDP8BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyMAQsgAEENNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDP4BCyAQQRVGDckBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDP0BCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyLAQsgAEEONgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPwBCyAAQQA2AhwgACABNgIUIABBwJWAgAA2AhAgAEECNgIMQQAhEAz7AQsgEEEVRg3FASAAQQA2AhwgACABNgIUIABBxoyAgAA2AhAgAEEjNgIMQQAhEAz6AQsgAEEQNgIcIAAgATYCFCAAIBA2AgxBACEQDPkBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQzxAQsgAEERNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPgBCyAQQRVGDcEBIABBADYCHCAAIAE2AhQgAEHGjICAADYCECAAQSM2AgxBACEQDPcBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQuYCAgAAiEA0AIAFBAWohAQyIAQsgAEETNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPYBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQuYCAgAAiBA0AIAFBAWohAQztAQsgAEEUNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPUBCyAQQRVGDb0BIABBADYCHCAAIAE2AhQgAEGaj4CAADYCECAAQSI2AgxBACEQDPQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQt4CAgAAiEA0AIAFBAWohAQyGAQsgAEEWNgIcIAAgEDYCDCAAIAFBAWo2AhRBACEQDPMBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQt4CAgAAiBA0AIAFBAWohAQzpAQsgAEEXNgIcIAAgBDYCDCAAIAFBAWo2AhRBACEQDPIBCyAAQQA2AhwgACABNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzxAQtCASERCyAQQQFqIQECQCAAKQMgIhJC//////////8PVg0AIAAgEkIEhiARhDcDICABIQEMhAELIABBADYCHCAAIAE2AhQgAEGtiYCAADYCECAAQQw2AgxBACEQDO8BCyAAQQA2AhwgACAQNgIUIABBzZOAgAA2AhAgAEEMNgIMQQAhEAzuAQsgACgCBCEXIABBADYCBCAQIBGnaiIWIQEgACAXIBAgFiAUGyIQELWAgIAAIhRFDXMgAEEFNgIcIAAgEDYCFCAAIBQ2AgxBACEQDO0BCyAAQQA2AhwgACAQNgIUIABBqpyAgAA2AhAgAEEPNgIMQQAhEAzsAQsgACAQIAIQtICAgAAiAQ0BIBAhAQtBDiEQDNEBCwJAIAFBFUcNACAAQQI2AhwgACAQNgIUIABBsJiAgAA2AhAgAEEVNgIMQQAhEAzqAQsgAEEANgIcIAAgEDYCFCAAQaeOgIAANgIQIABBEjYCDEEAIRAM6QELIAFBAWohEAJAIAAvATAiAUGAAXFFDQACQCAAIBAgAhC7gICAACIBDQAgECEBDHALIAFBFUcNugEgAEEFNgIcIAAgEDYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAM6QELAkAgAUGgBHFBoARHDQAgAC0ALUECcQ0AIABBADYCHCAAIBA2AhQgAEGWk4CAADYCECAAQQQ2AgxBACEQDOkBCyAAIBAgAhC9gICAABogECEBAkACQAJAAkACQCAAIBAgAhCzgICAAA4WAgEABAQEBAQEBAQEBAQEBAQEBAQEAwQLIABBAToALgsgACAALwEwQcAAcjsBMCAQIQELQSYhEAzRAQsgAEEjNgIcIAAgEDYCFCAAQaWWgIAANgIQIABBFTYCDEEAIRAM6QELIABBADYCHCAAIBA2AhQgAEHVi4CAADYCECAAQRE2AgxBACEQDOgBCyAALQAtQQFxRQ0BQcMBIRAMzgELAkAgDSACRg0AA0ACQCANLQAAQSBGDQAgDSEBDMQBCyANQQFqIg0gAkcNAAtBJSEQDOcBC0ElIRAM5gELIAAoAgQhBCAAQQA2AgQgACAEIA0Qr4CAgAAiBEUNrQEgAEEmNgIcIAAgBDYCDCAAIA1BAWo2AhRBACEQDOUBCyAQQRVGDasBIABBADYCHCAAIAE2AhQgAEH9jYCAADYCECAAQR02AgxBACEQDOQBCyAAQSc2AhwgACABNgIUIAAgEDYCDEEAIRAM4wELIBAhAUEBIRQCQAJAAkACQAJAAkACQCAALQAsQX5qDgcGBQUDAQIABQsgACAALwEwQQhyOwEwDAMLQQIhFAwBC0EEIRQLIABBAToALCAAIAAvATAgFHI7ATALIBAhAQtBKyEQDMoBCyAAQQA2AhwgACAQNgIUIABBq5KAgAA2AhAgAEELNgIMQQAhEAziAQsgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDEEAIRAM4QELIABBADoALCAQIQEMvQELIBAhAUEBIRQCQAJAAkACQAJAIAAtACxBe2oOBAMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEUDAELQQQhFAsgAEEBOgAsIAAgAC8BMCAUcjsBMAsgECEBC0EpIRAMxQELIABBADYCHCAAIAE2AhQgAEHwlICAADYCECAAQQM2AgxBACEQDN0BCwJAIA4tAABBDUcNACAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA5BAWohAQx1CyAAQSw2AhwgACABNgIMIAAgDkEBajYCFEEAIRAM3QELIAAtAC1BAXFFDQFBxAEhEAzDAQsCQCAOIAJHDQBBLSEQDNwBCwJAAkADQAJAIA4tAABBdmoOBAIAAAMACyAOQQFqIg4gAkcNAAtBLSEQDN0BCyAAKAIEIQEgAEEANgIEAkAgACABIA4QsYCAgAAiAQ0AIA4hAQx0CyAAQSw2AhwgACAONgIUIAAgATYCDEEAIRAM3AELIAAoAgQhASAAQQA2AgQCQCAAIAEgDhCxgICAACIBDQAgDkEBaiEBDHMLIABBLDYCHCAAIAE2AgwgACAOQQFqNgIUQQAhEAzbAQsgACgCBCEEIABBADYCBCAAIAQgDhCxgICAACIEDaABIA4hAQzOAQsgEEEsRw0BIAFBAWohEEEBIQECQAJAAkACQAJAIAAtACxBe2oOBAMBAgQACyAQIQEMBAtBAiEBDAELQQQhAQsgAEEBOgAsIAAgAC8BMCABcjsBMCAQIQEMAQsgACAALwEwQQhyOwEwIBAhAQtBOSEQDL8BCyAAQQA6ACwgASEBC0E0IRAMvQELIAAgAC8BMEEgcjsBMCABIQEMAgsgACgCBCEEIABBADYCBAJAIAAgBCABELGAgIAAIgQNACABIQEMxwELIABBNzYCHCAAIAE2AhQgACAENgIMQQAhEAzUAQsgAEEIOgAsIAEhAQtBMCEQDLkBCwJAIAAtAChBAUYNACABIQEMBAsgAC0ALUEIcUUNkwEgASEBDAMLIAAtADBBIHENlAFBxQEhEAy3AQsCQCAPIAJGDQACQANAAkAgDy0AAEFQaiIBQf8BcUEKSQ0AIA8hAUE1IRAMugELIAApAyAiEUKZs+bMmbPmzBlWDQEgACARQgp+IhE3AyAgESABrUL/AYMiEkJ/hVYNASAAIBEgEnw3AyAgD0EBaiIPIAJHDQALQTkhEAzRAQsgACgCBCECIABBADYCBCAAIAIgD0EBaiIEELGAgIAAIgINlQEgBCEBDMMBC0E5IRAMzwELAkAgAC8BMCIBQQhxRQ0AIAAtAChBAUcNACAALQAtQQhxRQ2QAQsgACABQff7A3FBgARyOwEwIA8hAQtBNyEQDLQBCyAAIAAvATBBEHI7ATAMqwELIBBBFUYNiwEgAEEANgIcIAAgATYCFCAAQfCOgIAANgIQIABBHDYCDEEAIRAMywELIABBwwA2AhwgACABNgIMIAAgDUEBajYCFEEAIRAMygELAkAgAS0AAEE6Rw0AIAAoAgQhECAAQQA2AgQCQCAAIBAgARCvgICAACIQDQAgAUEBaiEBDGMLIABBwwA2AhwgACAQNgIMIAAgAUEBajYCFEEAIRAMygELIABBADYCHCAAIAE2AhQgAEGxkYCAADYCECAAQQo2AgxBACEQDMkBCyAAQQA2AhwgACABNgIUIABBoJmAgAA2AhAgAEEeNgIMQQAhEAzIAQsgAEEANgIACyAAQYASOwEqIAAgF0EBaiIBIAIQqICAgAAiEA0BIAEhAQtBxwAhEAysAQsgEEEVRw2DASAAQdEANgIcIAAgATYCFCAAQeOXgIAANgIQIABBFTYCDEEAIRAMxAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDF4LIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMwwELIABBADYCHCAAIBQ2AhQgAEHBqICAADYCECAAQQc2AgwgAEEANgIAQQAhEAzCAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMXQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAzBAQtBACEQIABBADYCHCAAIAE2AhQgAEGAkYCAADYCECAAQQk2AgwMwAELIBBBFUYNfSAAQQA2AhwgACABNgIUIABBlI2AgAA2AhAgAEEhNgIMQQAhEAy/AQtBASEWQQAhF0EAIRRBASEQCyAAIBA6ACsgAUEBaiEBAkACQCAALQAtQRBxDQACQAJAAkAgAC0AKg4DAQACBAsgFkUNAwwCCyAUDQEMAgsgF0UNAQsgACgCBCEQIABBADYCBAJAIAAgECABEK2AgIAAIhANACABIQEMXAsgAEHYADYCHCAAIAE2AhQgACAQNgIMQQAhEAy+AQsgACgCBCEEIABBADYCBAJAIAAgBCABEK2AgIAAIgQNACABIQEMrQELIABB2QA2AhwgACABNgIUIAAgBDYCDEEAIRAMvQELIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCtgICAACIEDQAgASEBDKsBCyAAQdoANgIcIAAgATYCFCAAIAQ2AgxBACEQDLwBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQypAQsgAEHcADYCHCAAIAE2AhQgACAENgIMQQAhEAy7AQsCQCABLQAAQVBqIhBB/wFxQQpPDQAgACAQOgAqIAFBAWohAUHPACEQDKIBCyAAKAIEIQQgAEEANgIEAkAgACAEIAEQrYCAgAAiBA0AIAEhAQynAQsgAEHeADYCHCAAIAE2AhQgACAENgIMQQAhEAy6AQsgAEEANgIAIBdBAWohAQJAIAAtAClBI08NACABIQEMWQsgAEEANgIcIAAgATYCFCAAQdOJgIAANgIQIABBCDYCDEEAIRAMuQELIABBADYCAAtBACEQIABBADYCHCAAIAE2AhQgAEGQs4CAADYCECAAQQg2AgwMtwELIABBADYCACAXQQFqIQECQCAALQApQSFHDQAgASEBDFYLIABBADYCHCAAIAE2AhQgAEGbioCAADYCECAAQQg2AgxBACEQDLYBCyAAQQA2AgAgF0EBaiEBAkAgAC0AKSIQQV1qQQtPDQAgASEBDFULAkAgEEEGSw0AQQEgEHRBygBxRQ0AIAEhAQxVC0EAIRAgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDAy1AQsgEEEVRg1xIABBADYCHCAAIAE2AhQgAEG5jYCAADYCECAAQRo2AgxBACEQDLQBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxUCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLMBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdIANgIcIAAgATYCFCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8="), Za;
}
var Ka, vc;
function Ef() {
  return vc || (vc = 1, Ka = "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw=="), Ka;
}
const Ae = L, hh = L, Cf = L, { pipeline: ff } = L, ae = Ie, za = FC, is = _C, Qf = pi, {
  RequestContentLengthMismatchError: $A,
  ResponseContentLengthMismatchError: Bf,
  InvalidArgumentError: Je,
  RequestAbortedError: Ss,
  HeadersTimeoutError: If,
  HeadersOverflowError: df,
  SocketError: rr,
  InformationalError: GA,
  BodyTimeoutError: pf,
  HTTPParserError: yf,
  ResponseExceededMaxSizeError: mf,
  ClientDestroyedError: wf
} = ke, vf = yi, {
  kUrl: ze,
  kReset: hA,
  kServerName: ot,
  kClient: WA,
  kBusy: as,
  kParser: Me,
  kConnect: kf,
  kBlocking: nr,
  kResuming: kt,
  kRunning: Ue,
  kPending: Nt,
  kSize: Ft,
  kWriting: XA,
  kQueue: Te,
  kConnected: bf,
  kConnecting: $t,
  kNeedDrain: ut,
  kNoRef: mr,
  kKeepAliveDefaultTimeout: os,
  kHostHeader: gh,
  kPendingIdx: pA,
  kRunningIdx: Fe,
  kError: eA,
  kPipelining: ht,
  kSocket: Le,
  kKeepAliveTimeoutValue: Tr,
  kMaxHeadersSize: Ai,
  kKeepAliveMaxTimeout: Eh,
  kKeepAliveTimeoutThreshold: Ch,
  kHeadersTimeout: fh,
  kBodyTimeout: Qh,
  kStrictContentLength: Fr,
  kConnector: wr,
  kMaxRedirections: Tf,
  kMaxRequests: Rr,
  kCounter: Bh,
  kClose: Ff,
  kDestroy: Rf,
  kDispatch: Df,
  kInterceptors: Nf,
  kLocalAddress: vr,
  kMaxResponseSize: Ih,
  kHTTPConnVersion: YA,
  // HTTP2
  kHost: dh,
  kHTTP2Session: yA,
  kHTTP2SessionState: hi,
  kHTTP2BuildRequest: Sf,
  kHTTP2CopyHeaders: Uf,
  kHTTP1BuildRequest: Pf
} = Re;
let gi;
try {
  gi = L;
} catch {
  gi = { constants: {} };
}
const {
  constants: {
    HTTP2_HEADER_AUTHORITY: Mf,
    HTTP2_HEADER_METHOD: Lf,
    HTTP2_HEADER_PATH: Hf,
    HTTP2_HEADER_SCHEME: Gf,
    HTTP2_HEADER_CONTENT_LENGTH: Wf,
    HTTP2_HEADER_EXPECT: Yf,
    HTTP2_HEADER_STATUS: Jf
  }
} = gi;
let kc = !1;
const Rn = Buffer[Symbol.species], st = Symbol("kClosedResolve"), oA = {};
try {
  const r = L;
  oA.sendHeaders = r.channel("undici:client:sendHeaders"), oA.beforeConnect = r.channel("undici:client:beforeConnect"), oA.connectError = r.channel("undici:client:connectError"), oA.connected = r.channel("undici:client:connected");
} catch {
  oA.sendHeaders = { hasSubscribers: !1 }, oA.beforeConnect = { hasSubscribers: !1 }, oA.connectError = { hasSubscribers: !1 }, oA.connected = { hasSubscribers: !1 };
}
let _f = class extends Qf {
  /**
   *
   * @param {string|URL} url
   * @param {import('../types/client').Client.Options} options
   */
  constructor(t, {
    interceptors: e,
    maxHeaderSize: A,
    headersTimeout: n,
    socketTimeout: i,
    requestTimeout: a,
    connectTimeout: o,
    bodyTimeout: s,
    idleTimeout: l,
    keepAlive: c,
    keepAliveTimeout: u,
    maxKeepAliveTimeout: h,
    keepAliveMaxTimeout: g,
    keepAliveTimeoutThreshold: d,
    socketPath: I,
    pipelining: y,
    tls: Q,
    strictContentLength: E,
    maxCachedSessions: B,
    maxRedirections: w,
    connect: C,
    maxRequestsPerClient: f,
    localAddress: p,
    maxResponseSize: m,
    autoSelectFamily: R,
    autoSelectFamilyAttemptTimeout: P,
    // h2
    allowH2: N,
    maxConcurrentStreams: $
  } = {}) {
    if (super(), c !== void 0)
      throw new Je("unsupported keepAlive, use pipelining=0 instead");
    if (i !== void 0)
      throw new Je("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
    if (a !== void 0)
      throw new Je("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
    if (l !== void 0)
      throw new Je("unsupported idleTimeout, use keepAliveTimeout instead");
    if (h !== void 0)
      throw new Je("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
    if (A != null && !Number.isFinite(A))
      throw new Je("invalid maxHeaderSize");
    if (I != null && typeof I != "string")
      throw new Je("invalid socketPath");
    if (o != null && (!Number.isFinite(o) || o < 0))
      throw new Je("invalid connectTimeout");
    if (u != null && (!Number.isFinite(u) || u <= 0))
      throw new Je("invalid keepAliveTimeout");
    if (g != null && (!Number.isFinite(g) || g <= 0))
      throw new Je("invalid keepAliveMaxTimeout");
    if (d != null && !Number.isFinite(d))
      throw new Je("invalid keepAliveTimeoutThreshold");
    if (n != null && (!Number.isInteger(n) || n < 0))
      throw new Je("headersTimeout must be a positive integer or zero");
    if (s != null && (!Number.isInteger(s) || s < 0))
      throw new Je("bodyTimeout must be a positive integer or zero");
    if (C != null && typeof C != "function" && typeof C != "object")
      throw new Je("connect must be a function or an object");
    if (w != null && (!Number.isInteger(w) || w < 0))
      throw new Je("maxRedirections must be a positive number");
    if (f != null && (!Number.isInteger(f) || f < 0))
      throw new Je("maxRequestsPerClient must be a positive number");
    if (p != null && (typeof p != "string" || hh.isIP(p) === 0))
      throw new Je("localAddress must be valid string IP address");
    if (m != null && (!Number.isInteger(m) || m < -1))
      throw new Je("maxResponseSize must be a positive number");
    if (P != null && (!Number.isInteger(P) || P < -1))
      throw new Je("autoSelectFamilyAttemptTimeout must be a positive number");
    if (N != null && typeof N != "boolean")
      throw new Je("allowH2 must be a valid boolean value");
    if ($ != null && (typeof $ != "number" || $ < 1))
      throw new Je("maxConcurrentStreams must be a possitive integer, greater than 0");
    typeof C != "function" && (C = vf({
      ...Q,
      maxCachedSessions: B,
      allowH2: N,
      socketPath: I,
      timeout: o,
      ...ae.nodeHasAutoSelectFamily && R ? { autoSelectFamily: R, autoSelectFamilyAttemptTimeout: P } : void 0,
      ...C
    })), this[Nf] = e && e.Client && Array.isArray(e.Client) ? e.Client : [Vf({ maxRedirections: w })], this[ze] = ae.parseOrigin(t), this[wr] = C, this[Le] = null, this[ht] = y ?? 1, this[Ai] = A || Cf.maxHeaderSize, this[os] = u ?? 4e3, this[Eh] = g ?? 6e5, this[Ch] = d ?? 1e3, this[Tr] = this[os], this[ot] = null, this[vr] = p ?? null, this[kt] = 0, this[ut] = 0, this[gh] = `host: ${this[ze].hostname}${this[ze].port ? `:${this[ze].port}` : ""}\r
`, this[Qh] = s ?? 3e5, this[fh] = n ?? 3e5, this[Fr] = E ?? !0, this[Tf] = w, this[Rr] = f, this[st] = null, this[Ih] = m > -1 ? m : -1, this[YA] = "h1", this[yA] = null, this[hi] = N ? {
      // streams: null, // Fixed queue of streams - For future support of `push`
      openStreams: 0,
      // Keep track of them to decide wether or not unref the session
      maxConcurrentStreams: $ ?? 100
      // Max peerConcurrentStreams for a Node h2 server
    } : null, this[dh] = `${this[ze].hostname}${this[ze].port ? `:${this[ze].port}` : ""}`, this[Te] = [], this[Fe] = 0, this[pA] = 0;
  }
  get pipelining() {
    return this[ht];
  }
  set pipelining(t) {
    this[ht] = t, mA(this, !0);
  }
  get [Nt]() {
    return this[Te].length - this[pA];
  }
  get [Ue]() {
    return this[pA] - this[Fe];
  }
  get [Ft]() {
    return this[Te].length - this[Fe];
  }
  get [bf]() {
    return !!this[Le] && !this[$t] && !this[Le].destroyed;
  }
  get [as]() {
    const t = this[Le];
    return t && (t[hA] || t[XA] || t[nr]) || this[Ft] >= (this[ht] || 1) || this[Nt] > 0;
  }
  /* istanbul ignore: only used for test */
  [kf](t) {
    wh(this), this.once("connect", t);
  }
  [Df](t, e) {
    const A = t.origin || this[ze].origin, n = this[YA] === "h2" ? is[Sf](A, t, e) : is[Pf](A, t, e);
    return this[Te].push(n), this[kt] || (ae.bodyLength(n.body) == null && ae.isIterable(n.body) ? (this[kt] = 1, process.nextTick(mA, this)) : mA(this, !0)), this[kt] && this[ut] !== 2 && this[as] && (this[ut] = 2), this[ut] < 2;
  }
  async [Ff]() {
    return new Promise((t) => {
      this[Ft] ? this[st] = t : t(null);
    });
  }
  async [Rf](t) {
    return new Promise((e) => {
      const A = this[Te].splice(this[pA]);
      for (let i = 0; i < A.length; i++) {
        const a = A[i];
        gA(this, a, t);
      }
      const n = () => {
        this[st] && (this[st](), this[st] = null), e();
      };
      this[yA] != null && (ae.destroy(this[yA], t), this[yA] = null, this[hi] = null), this[Le] ? ae.destroy(this[Le].on("close", n), t) : queueMicrotask(n), mA(this);
    });
  }
};
function xf(r) {
  Ae(r.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), this[Le][eA] = r, mi(this[WA], r);
}
function Of(r, t, e) {
  const A = new GA(`HTTP/2: "frameError" received - type ${r}, code ${t}`);
  e === 0 && (this[Le][eA] = A, mi(this[WA], A));
}
function qf() {
  ae.destroy(this, new rr("other side closed")), ae.destroy(this[Le], new rr("other side closed"));
}
function jf(r) {
  const t = this[WA], e = new GA(`HTTP/2: "GOAWAY" frame received with code ${r}`);
  if (t[Le] = null, t[yA] = null, t.destroyed) {
    Ae(this[Nt] === 0);
    const A = t[Te].splice(t[Fe]);
    for (let n = 0; n < A.length; n++) {
      const i = A[n];
      gA(this, i, e);
    }
  } else if (t[Ue] > 0) {
    const A = t[Te][t[Fe]];
    t[Te][t[Fe]++] = null, gA(t, A, e);
  }
  t[pA] = t[Fe], Ae(t[Ue] === 0), t.emit(
    "disconnect",
    t[ze],
    [t],
    e
  ), mA(t);
}
const PA = nf(), Vf = Ns, $f = Buffer.alloc(0);
async function Xf() {
  const r = process.env.JEST_WORKER_ID ? wc() : void 0;
  let t;
  try {
    t = await WebAssembly.compile(Buffer.from(Ef(), "base64"));
  } catch {
    t = await WebAssembly.compile(Buffer.from(r || wc(), "base64"));
  }
  return await WebAssembly.instantiate(t, {
    env: {
      /* eslint-disable camelcase */
      wasm_on_url: (e, A, n) => 0,
      wasm_on_status: (e, A, n) => {
        Ae.strictEqual(Ve.ptr, e);
        const i = A - HA + LA.byteOffset;
        return Ve.onStatus(new Rn(LA.buffer, i, n)) || 0;
      },
      wasm_on_message_begin: (e) => (Ae.strictEqual(Ve.ptr, e), Ve.onMessageBegin() || 0),
      wasm_on_header_field: (e, A, n) => {
        Ae.strictEqual(Ve.ptr, e);
        const i = A - HA + LA.byteOffset;
        return Ve.onHeaderField(new Rn(LA.buffer, i, n)) || 0;
      },
      wasm_on_header_value: (e, A, n) => {
        Ae.strictEqual(Ve.ptr, e);
        const i = A - HA + LA.byteOffset;
        return Ve.onHeaderValue(new Rn(LA.buffer, i, n)) || 0;
      },
      wasm_on_headers_complete: (e, A, n, i) => (Ae.strictEqual(Ve.ptr, e), Ve.onHeadersComplete(A, !!n, !!i) || 0),
      wasm_on_body: (e, A, n) => {
        Ae.strictEqual(Ve.ptr, e);
        const i = A - HA + LA.byteOffset;
        return Ve.onBody(new Rn(LA.buffer, i, n)) || 0;
      },
      wasm_on_message_complete: (e) => (Ae.strictEqual(Ve.ptr, e), Ve.onMessageComplete() || 0)
      /* eslint-enable camelcase */
    }
  });
}
let eo = null, ss = Xf();
ss.catch();
let Ve = null, LA = null, Dn = 0, HA = null;
const ir = 1, ti = 2, cs = 3;
class Zf {
  constructor(t, e, { exports: A }) {
    Ae(Number.isFinite(t[Ai]) && t[Ai] > 0), this.llhttp = A, this.ptr = this.llhttp.llhttp_alloc(PA.TYPE.RESPONSE), this.client = t, this.socket = e, this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.statusCode = null, this.statusText = "", this.upgrade = !1, this.headers = [], this.headersSize = 0, this.headersMaxSize = t[Ai], this.shouldKeepAlive = !1, this.paused = !1, this.resume = this.resume.bind(this), this.bytesRead = 0, this.keepAlive = "", this.contentLength = "", this.connection = "", this.maxResponseSize = t[Ih];
  }
  setTimeout(t, e) {
    this.timeoutType = e, t !== this.timeoutValue ? (za.clearTimeout(this.timeout), t ? (this.timeout = za.setTimeout(Kf, t, this), this.timeout.unref && this.timeout.unref()) : this.timeout = null, this.timeoutValue = t) : this.timeout && this.timeout.refresh && this.timeout.refresh();
  }
  resume() {
    this.socket.destroyed || !this.paused || (Ae(this.ptr != null), Ae(Ve == null), this.llhttp.llhttp_resume(this.ptr), Ae(this.timeoutType === ti), this.timeout && this.timeout.refresh && this.timeout.refresh(), this.paused = !1, this.execute(this.socket.read() || $f), this.readMore());
  }
  readMore() {
    for (; !this.paused && this.ptr; ) {
      const t = this.socket.read();
      if (t === null)
        break;
      this.execute(t);
    }
  }
  execute(t) {
    Ae(this.ptr != null), Ae(Ve == null), Ae(!this.paused);
    const { socket: e, llhttp: A } = this;
    t.length > Dn && (HA && A.free(HA), Dn = Math.ceil(t.length / 4096) * 4096, HA = A.malloc(Dn)), new Uint8Array(A.memory.buffer, HA, Dn).set(t);
    try {
      let n;
      try {
        LA = t, Ve = this, n = A.llhttp_execute(this.ptr, HA, t.length);
      } catch (a) {
        throw a;
      } finally {
        Ve = null, LA = null;
      }
      const i = A.llhttp_get_error_pos(this.ptr) - HA;
      if (n === PA.ERROR.PAUSED_UPGRADE)
        this.onUpgrade(t.slice(i));
      else if (n === PA.ERROR.PAUSED)
        this.paused = !0, e.unshift(t.slice(i));
      else if (n !== PA.ERROR.OK) {
        const a = A.llhttp_get_error_reason(this.ptr);
        let o = "";
        if (a) {
          const s = new Uint8Array(A.memory.buffer, a).indexOf(0);
          o = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(A.memory.buffer, a, s).toString() + ")";
        }
        throw new yf(o, PA.ERROR[n], t.slice(i));
      }
    } catch (n) {
      ae.destroy(e, n);
    }
  }
  destroy() {
    Ae(this.ptr != null), Ae(Ve == null), this.llhttp.llhttp_free(this.ptr), this.ptr = null, za.clearTimeout(this.timeout), this.timeout = null, this.timeoutValue = null, this.timeoutType = null, this.paused = !1;
  }
  onStatus(t) {
    this.statusText = t.toString();
  }
  onMessageBegin() {
    const { socket: t, client: e } = this;
    if (t.destroyed || !e[Te][e[Fe]])
      return -1;
  }
  onHeaderField(t) {
    const e = this.headers.length;
    e & 1 ? this.headers[e - 1] = Buffer.concat([this.headers[e - 1], t]) : this.headers.push(t), this.trackHeader(t.length);
  }
  onHeaderValue(t) {
    let e = this.headers.length;
    (e & 1) === 1 ? (this.headers.push(t), e += 1) : this.headers[e - 1] = Buffer.concat([this.headers[e - 1], t]);
    const A = this.headers[e - 2];
    A.length === 10 && A.toString().toLowerCase() === "keep-alive" ? this.keepAlive += t.toString() : A.length === 10 && A.toString().toLowerCase() === "connection" ? this.connection += t.toString() : A.length === 14 && A.toString().toLowerCase() === "content-length" && (this.contentLength += t.toString()), this.trackHeader(t.length);
  }
  trackHeader(t) {
    this.headersSize += t, this.headersSize >= this.headersMaxSize && ae.destroy(this.socket, new df());
  }
  onUpgrade(t) {
    const { upgrade: e, client: A, socket: n, headers: i, statusCode: a } = this;
    Ae(e);
    const o = A[Te][A[Fe]];
    Ae(o), Ae(!n.destroyed), Ae(n === A[Le]), Ae(!this.paused), Ae(o.upgrade || o.method === "CONNECT"), this.statusCode = null, this.statusText = "", this.shouldKeepAlive = null, Ae(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, n.unshift(t), n[Me].destroy(), n[Me] = null, n[WA] = null, n[eA] = null, n.removeListener("error", yh).removeListener("readable", ph).removeListener("end", mh).removeListener("close", ls), A[Le] = null, A[Te][A[Fe]++] = null, A.emit("disconnect", A[ze], [A], new GA("upgrade"));
    try {
      o.onUpgrade(a, i, n);
    } catch (s) {
      ae.destroy(n, s);
    }
    mA(A);
  }
  onHeadersComplete(t, e, A) {
    const { client: n, socket: i, headers: a, statusText: o } = this;
    if (i.destroyed)
      return -1;
    const s = n[Te][n[Fe]];
    if (!s)
      return -1;
    if (Ae(!this.upgrade), Ae(this.statusCode < 200), t === 100)
      return ae.destroy(i, new rr("bad response", ae.getSocketInfo(i))), -1;
    if (e && !s.upgrade)
      return ae.destroy(i, new rr("bad upgrade", ae.getSocketInfo(i))), -1;
    if (Ae.strictEqual(this.timeoutType, ir), this.statusCode = t, this.shouldKeepAlive = A || // Override llhttp value which does not allow keepAlive for HEAD.
    s.method === "HEAD" && !i[hA] && this.connection.toLowerCase() === "keep-alive", this.statusCode >= 200) {
      const c = s.bodyTimeout != null ? s.bodyTimeout : n[Qh];
      this.setTimeout(c, ti);
    } else
      this.timeout && this.timeout.refresh && this.timeout.refresh();
    if (s.method === "CONNECT")
      return Ae(n[Ue] === 1), this.upgrade = !0, 2;
    if (e)
      return Ae(n[Ue] === 1), this.upgrade = !0, 2;
    if (Ae(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, this.shouldKeepAlive && n[ht]) {
      const c = this.keepAlive ? ae.parseKeepAliveTimeout(this.keepAlive) : null;
      if (c != null) {
        const u = Math.min(
          c - n[Ch],
          n[Eh]
        );
        u <= 0 ? i[hA] = !0 : n[Tr] = u;
      } else
        n[Tr] = n[os];
    } else
      i[hA] = !0;
    const l = s.onHeaders(t, a, this.resume, o) === !1;
    return s.aborted ? -1 : s.method === "HEAD" || t < 200 ? 1 : (i[nr] && (i[nr] = !1, mA(n)), l ? PA.ERROR.PAUSED : 0);
  }
  onBody(t) {
    const { client: e, socket: A, statusCode: n, maxResponseSize: i } = this;
    if (A.destroyed)
      return -1;
    const a = e[Te][e[Fe]];
    if (Ae(a), Ae.strictEqual(this.timeoutType, ti), this.timeout && this.timeout.refresh && this.timeout.refresh(), Ae(n >= 200), i > -1 && this.bytesRead + t.length > i)
      return ae.destroy(A, new mf()), -1;
    if (this.bytesRead += t.length, a.onData(t) === !1)
      return PA.ERROR.PAUSED;
  }
  onMessageComplete() {
    const { client: t, socket: e, statusCode: A, upgrade: n, headers: i, contentLength: a, bytesRead: o, shouldKeepAlive: s } = this;
    if (e.destroyed && (!A || s))
      return -1;
    if (n)
      return;
    const l = t[Te][t[Fe]];
    if (Ae(l), Ae(A >= 100), this.statusCode = null, this.statusText = "", this.bytesRead = 0, this.contentLength = "", this.keepAlive = "", this.connection = "", Ae(this.headers.length % 2 === 0), this.headers = [], this.headersSize = 0, !(A < 200)) {
      if (l.method !== "HEAD" && a && o !== parseInt(a, 10))
        return ae.destroy(e, new Bf()), -1;
      if (l.onComplete(i), t[Te][t[Fe]++] = null, e[XA])
        return Ae.strictEqual(t[Ue], 0), ae.destroy(e, new GA("reset")), PA.ERROR.PAUSED;
      if (s) {
        if (e[hA] && t[Ue] === 0)
          return ae.destroy(e, new GA("reset")), PA.ERROR.PAUSED;
        t[ht] === 1 ? setImmediate(mA, t) : mA(t);
      } else
        return ae.destroy(e, new GA("reset")), PA.ERROR.PAUSED;
    }
  }
}
function Kf(r) {
  const { socket: t, timeoutType: e, client: A } = r;
  e === ir ? (!t[XA] || t.writableNeedDrain || A[Ue] > 1) && (Ae(!r.paused, "cannot be paused while waiting for headers"), ae.destroy(t, new If())) : e === ti ? r.paused || ae.destroy(t, new pf()) : e === cs && (Ae(A[Ue] === 0 && A[Tr]), ae.destroy(t, new GA("socket idle timeout")));
}
function ph() {
  const { [Me]: r } = this;
  r && r.readMore();
}
function yh(r) {
  const { [WA]: t, [Me]: e } = this;
  if (Ae(r.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), t[YA] !== "h2" && r.code === "ECONNRESET" && e.statusCode && !e.shouldKeepAlive) {
    e.onMessageComplete();
    return;
  }
  this[eA] = r, mi(this[WA], r);
}
function mi(r, t) {
  if (r[Ue] === 0 && t.code !== "UND_ERR_INFO" && t.code !== "UND_ERR_SOCKET") {
    Ae(r[pA] === r[Fe]);
    const e = r[Te].splice(r[Fe]);
    for (let A = 0; A < e.length; A++) {
      const n = e[A];
      gA(r, n, t);
    }
    Ae(r[Ft] === 0);
  }
}
function mh() {
  const { [Me]: r, [WA]: t } = this;
  if (t[YA] !== "h2" && r.statusCode && !r.shouldKeepAlive) {
    r.onMessageComplete();
    return;
  }
  ae.destroy(this, new rr("other side closed", ae.getSocketInfo(this)));
}
function ls() {
  const { [WA]: r, [Me]: t } = this;
  r[YA] === "h1" && t && (!this[eA] && t.statusCode && !t.shouldKeepAlive && t.onMessageComplete(), this[Me].destroy(), this[Me] = null);
  const e = this[eA] || new rr("closed", ae.getSocketInfo(this));
  if (r[Le] = null, r.destroyed) {
    Ae(r[Nt] === 0);
    const A = r[Te].splice(r[Fe]);
    for (let n = 0; n < A.length; n++) {
      const i = A[n];
      gA(r, i, e);
    }
  } else if (r[Ue] > 0 && e.code !== "UND_ERR_INFO") {
    const A = r[Te][r[Fe]];
    r[Te][r[Fe]++] = null, gA(r, A, e);
  }
  r[pA] = r[Fe], Ae(r[Ue] === 0), r.emit("disconnect", r[ze], [r], e), mA(r);
}
async function wh(r) {
  Ae(!r[$t]), Ae(!r[Le]);
  let { host: t, hostname: e, protocol: A, port: n } = r[ze];
  if (e[0] === "[") {
    const i = e.indexOf("]");
    Ae(i !== -1);
    const a = e.substring(1, i);
    Ae(hh.isIP(a)), e = a;
  }
  r[$t] = !0, oA.beforeConnect.hasSubscribers && oA.beforeConnect.publish({
    connectParams: {
      host: t,
      hostname: e,
      protocol: A,
      port: n,
      servername: r[ot],
      localAddress: r[vr]
    },
    connector: r[wr]
  });
  try {
    const i = await new Promise((o, s) => {
      r[wr]({
        host: t,
        hostname: e,
        protocol: A,
        port: n,
        servername: r[ot],
        localAddress: r[vr]
      }, (l, c) => {
        l ? s(l) : o(c);
      });
    });
    if (r.destroyed) {
      ae.destroy(i.on("error", () => {
      }), new wf());
      return;
    }
    if (r[$t] = !1, Ae(i), i.alpnProtocol === "h2") {
      kc || (kc = !0, process.emitWarning("H2 support is experimental, expect them to change at any time.", {
        code: "UNDICI-H2"
      }));
      const o = gi.connect(r[ze], {
        createConnection: () => i,
        peerMaxConcurrentStreams: r[hi].maxConcurrentStreams
      });
      r[YA] = "h2", o[WA] = r, o[Le] = i, o.on("error", xf), o.on("frameError", Of), o.on("end", qf), o.on("goaway", jf), o.on("close", ls), o.unref(), r[yA] = o, i[yA] = o;
    } else
      eo || (eo = await ss, ss = null), i[mr] = !1, i[XA] = !1, i[hA] = !1, i[nr] = !1, i[Me] = new Zf(r, i, eo);
    i[Bh] = 0, i[Rr] = r[Rr], i[WA] = r, i[eA] = null, i.on("error", yh).on("readable", ph).on("end", mh).on("close", ls), r[Le] = i, oA.connected.hasSubscribers && oA.connected.publish({
      connectParams: {
        host: t,
        hostname: e,
        protocol: A,
        port: n,
        servername: r[ot],
        localAddress: r[vr]
      },
      connector: r[wr],
      socket: i
    }), r.emit("connect", r[ze], [r]);
  } catch (i) {
    if (r.destroyed)
      return;
    if (r[$t] = !1, oA.connectError.hasSubscribers && oA.connectError.publish({
      connectParams: {
        host: t,
        hostname: e,
        protocol: A,
        port: n,
        servername: r[ot],
        localAddress: r[vr]
      },
      connector: r[wr],
      error: i
    }), i.code === "ERR_TLS_CERT_ALTNAME_INVALID")
      for (Ae(r[Ue] === 0); r[Nt] > 0 && r[Te][r[pA]].servername === r[ot]; ) {
        const a = r[Te][r[pA]++];
        gA(r, a, i);
      }
    else
      mi(r, i);
    r.emit("connectionError", r[ze], [r], i);
  }
  mA(r);
}
function bc(r) {
  r[ut] = 0, r.emit("drain", r[ze], [r]);
}
function mA(r, t) {
  r[kt] !== 2 && (r[kt] = 2, zf(r, t), r[kt] = 0, r[Fe] > 256 && (r[Te].splice(0, r[Fe]), r[pA] -= r[Fe], r[Fe] = 0));
}
function zf(r, t) {
  for (; ; ) {
    if (r.destroyed) {
      Ae(r[Nt] === 0);
      return;
    }
    if (r[st] && !r[Ft]) {
      r[st](), r[st] = null;
      return;
    }
    const e = r[Le];
    if (e && !e.destroyed && e.alpnProtocol !== "h2") {
      if (r[Ft] === 0 ? !e[mr] && e.unref && (e.unref(), e[mr] = !0) : e[mr] && e.ref && (e.ref(), e[mr] = !1), r[Ft] === 0)
        e[Me].timeoutType !== cs && e[Me].setTimeout(r[Tr], cs);
      else if (r[Ue] > 0 && e[Me].statusCode < 200 && e[Me].timeoutType !== ir) {
        const n = r[Te][r[Fe]], i = n.headersTimeout != null ? n.headersTimeout : r[fh];
        e[Me].setTimeout(i, ir);
      }
    }
    if (r[as])
      r[ut] = 2;
    else if (r[ut] === 2) {
      t ? (r[ut] = 1, process.nextTick(bc, r)) : bc(r);
      continue;
    }
    if (r[Nt] === 0 || r[Ue] >= (r[ht] || 1))
      return;
    const A = r[Te][r[pA]];
    if (r[ze].protocol === "https:" && r[ot] !== A.servername) {
      if (r[Ue] > 0)
        return;
      if (r[ot] = A.servername, e && e.servername !== A.servername) {
        ae.destroy(e, new GA("servername changed"));
        return;
      }
    }
    if (r[$t])
      return;
    if (!e && !r[yA]) {
      wh(r);
      return;
    }
    if (e.destroyed || e[XA] || e[hA] || e[nr] || r[Ue] > 0 && !A.idempotent || r[Ue] > 0 && (A.upgrade || A.method === "CONNECT") || r[Ue] > 0 && ae.bodyLength(A.body) !== 0 && (ae.isStream(A.body) || ae.isAsyncIterable(A.body)))
      return;
    !A.aborted && eQ(r, A) ? r[pA]++ : r[Te].splice(r[pA], 1);
  }
}
function vh(r) {
  return r !== "GET" && r !== "HEAD" && r !== "OPTIONS" && r !== "TRACE" && r !== "CONNECT";
}
function eQ(r, t) {
  if (r[YA] === "h2") {
    AQ(r, r[yA], t);
    return;
  }
  const { body: e, method: A, path: n, host: i, upgrade: a, headers: o, blocking: s, reset: l } = t, c = A === "PUT" || A === "POST" || A === "PATCH";
  e && typeof e.read == "function" && e.read(0);
  const u = ae.bodyLength(e);
  let h = u;
  if (h === null && (h = t.contentLength), h === 0 && !c && (h = null), vh(A) && h > 0 && t.contentLength !== null && t.contentLength !== h) {
    if (r[Fr])
      return gA(r, t, new $A()), !1;
    process.emitWarning(new $A());
  }
  const g = r[Le];
  try {
    t.onConnect((I) => {
      t.aborted || t.completed || (gA(r, t, I || new Ss()), ae.destroy(g, new GA("aborted")));
    });
  } catch (I) {
    gA(r, t, I);
  }
  if (t.aborted)
    return !1;
  A === "HEAD" && (g[hA] = !0), (a || A === "CONNECT") && (g[hA] = !0), l != null && (g[hA] = l), r[Rr] && g[Bh]++ >= r[Rr] && (g[hA] = !0), s && (g[nr] = !0);
  let d = `${A} ${n} HTTP/1.1\r
`;
  return typeof i == "string" ? d += `host: ${i}\r
` : d += r[gh], a ? d += `connection: upgrade\r
upgrade: ${a}\r
` : r[ht] && !g[hA] ? d += `connection: keep-alive\r
` : d += `connection: close\r
`, o && (d += o), oA.sendHeaders.hasSubscribers && oA.sendHeaders.publish({ request: t, headers: d, socket: g }), !e || u === 0 ? (h === 0 ? g.write(`${d}content-length: 0\r
\r
`, "latin1") : (Ae(h === null, "no body must not have content length"), g.write(`${d}\r
`, "latin1")), t.onRequestSent()) : ae.isBuffer(e) ? (Ae(h === e.byteLength, "buffer body must have content length"), g.cork(), g.write(`${d}content-length: ${h}\r
\r
`, "latin1"), g.write(e), g.uncork(), t.onBodySent(e), t.onRequestSent(), c || (g[hA] = !0)) : ae.isBlobLike(e) ? typeof e.stream == "function" ? Ei({ body: e.stream(), client: r, request: t, socket: g, contentLength: h, header: d, expectsPayload: c }) : bh({ body: e, client: r, request: t, socket: g, contentLength: h, header: d, expectsPayload: c }) : ae.isStream(e) ? kh({ body: e, client: r, request: t, socket: g, contentLength: h, header: d, expectsPayload: c }) : ae.isIterable(e) ? Ei({ body: e, client: r, request: t, socket: g, contentLength: h, header: d, expectsPayload: c }) : Ae(!1), !0;
}
function AQ(r, t, e) {
  const { body: A, method: n, path: i, host: a, upgrade: o, expectContinue: s, signal: l, headers: c } = e;
  let u;
  if (typeof c == "string" ? u = is[Uf](c.trim()) : u = c, o)
    return gA(r, e, new Error("Upgrade not supported for H2")), !1;
  try {
    e.onConnect((E) => {
      e.aborted || e.completed || gA(r, e, E || new Ss());
    });
  } catch (E) {
    gA(r, e, E);
  }
  if (e.aborted)
    return !1;
  let h;
  const g = r[hi];
  if (u[Mf] = a || r[dh], u[Lf] = n, n === "CONNECT")
    return t.ref(), h = t.request(u, { endStream: !1, signal: l }), h.id && !h.pending ? (e.onUpgrade(null, null, h), ++g.openStreams) : h.once("ready", () => {
      e.onUpgrade(null, null, h), ++g.openStreams;
    }), h.once("close", () => {
      g.openStreams -= 1, g.openStreams === 0 && t.unref();
    }), !0;
  u[Hf] = i, u[Gf] = "https";
  const d = n === "PUT" || n === "POST" || n === "PATCH";
  A && typeof A.read == "function" && A.read(0);
  let I = ae.bodyLength(A);
  if (I == null && (I = e.contentLength), (I === 0 || !d) && (I = null), vh(n) && I > 0 && e.contentLength != null && e.contentLength !== I) {
    if (r[Fr])
      return gA(r, e, new $A()), !1;
    process.emitWarning(new $A());
  }
  I != null && (Ae(A, "no body must not have content length"), u[Wf] = `${I}`), t.ref();
  const y = n === "GET" || n === "HEAD";
  return s ? (u[Yf] = "100-continue", h = t.request(u, { endStream: y, signal: l }), h.once("continue", Q)) : (h = t.request(u, {
    endStream: y,
    signal: l
  }), Q()), ++g.openStreams, h.once("response", (E) => {
    const { [Jf]: B, ...w } = E;
    e.onHeaders(Number(B), w, h.resume.bind(h), "") === !1 && h.pause();
  }), h.once("end", () => {
    e.onComplete([]);
  }), h.on("data", (E) => {
    e.onData(E) === !1 && h.pause();
  }), h.once("close", () => {
    g.openStreams -= 1, g.openStreams === 0 && t.unref();
  }), h.once("error", function(E) {
    r[yA] && !r[yA].destroyed && !this.closed && !this.destroyed && (g.streams -= 1, ae.destroy(h, E));
  }), h.once("frameError", (E, B) => {
    const w = new GA(`HTTP/2: "frameError" received - type ${E}, code ${B}`);
    gA(r, e, w), r[yA] && !r[yA].destroyed && !this.closed && !this.destroyed && (g.streams -= 1, ae.destroy(h, w));
  }), !0;
  function Q() {
    A ? ae.isBuffer(A) ? (Ae(I === A.byteLength, "buffer body must have content length"), h.cork(), h.write(A), h.uncork(), h.end(), e.onBodySent(A), e.onRequestSent()) : ae.isBlobLike(A) ? typeof A.stream == "function" ? Ei({
      client: r,
      request: e,
      contentLength: I,
      h2stream: h,
      expectsPayload: d,
      body: A.stream(),
      socket: r[Le],
      header: ""
    }) : bh({
      body: A,
      client: r,
      request: e,
      contentLength: I,
      expectsPayload: d,
      h2stream: h,
      header: "",
      socket: r[Le]
    }) : ae.isStream(A) ? kh({
      body: A,
      client: r,
      request: e,
      contentLength: I,
      expectsPayload: d,
      socket: r[Le],
      h2stream: h,
      header: ""
    }) : ae.isIterable(A) ? Ei({
      body: A,
      client: r,
      request: e,
      contentLength: I,
      expectsPayload: d,
      header: "",
      h2stream: h,
      socket: r[Le]
    }) : Ae(!1) : e.onRequestSent();
  }
}
function kh({ h2stream: r, body: t, client: e, request: A, socket: n, contentLength: i, header: a, expectsPayload: o }) {
  if (Ae(i !== 0 || e[Ue] === 0, "stream body cannot be pipelined"), e[YA] === "h2") {
    let y = function(Q) {
      A.onBodySent(Q);
    };
    var d = y;
    const I = ff(
      t,
      r,
      (Q) => {
        Q ? (ae.destroy(t, Q), ae.destroy(r, Q)) : A.onRequestSent();
      }
    );
    I.on("data", y), I.once("end", () => {
      I.removeListener("data", y), ae.destroy(I);
    });
    return;
  }
  let s = !1;
  const l = new Th({ socket: n, request: A, contentLength: i, client: e, expectsPayload: o, header: a }), c = function(I) {
    if (!s)
      try {
        !l.write(I) && this.pause && this.pause();
      } catch (y) {
        ae.destroy(this, y);
      }
  }, u = function() {
    s || t.resume && t.resume();
  }, h = function() {
    if (s)
      return;
    const I = new Ss();
    queueMicrotask(() => g(I));
  }, g = function(I) {
    if (!s) {
      if (s = !0, Ae(n.destroyed || n[XA] && e[Ue] <= 1), n.off("drain", u).off("error", g), t.removeListener("data", c).removeListener("end", g).removeListener("error", g).removeListener("close", h), !I)
        try {
          l.end();
        } catch (y) {
          I = y;
        }
      l.destroy(I), I && (I.code !== "UND_ERR_INFO" || I.message !== "reset") ? ae.destroy(t, I) : ae.destroy(t);
    }
  };
  t.on("data", c).on("end", g).on("error", g).on("close", h), t.resume && t.resume(), n.on("drain", u).on("error", g);
}
async function bh({ h2stream: r, body: t, client: e, request: A, socket: n, contentLength: i, header: a, expectsPayload: o }) {
  Ae(i === t.size, "blob body must have content length");
  const s = e[YA] === "h2";
  try {
    if (i != null && i !== t.size)
      throw new $A();
    const l = Buffer.from(await t.arrayBuffer());
    s ? (r.cork(), r.write(l), r.uncork()) : (n.cork(), n.write(`${a}content-length: ${i}\r
\r
`, "latin1"), n.write(l), n.uncork()), A.onBodySent(l), A.onRequestSent(), o || (n[hA] = !0), mA(e);
  } catch (l) {
    ae.destroy(s ? r : n, l);
  }
}
async function Ei({ h2stream: r, body: t, client: e, request: A, socket: n, contentLength: i, header: a, expectsPayload: o }) {
  Ae(i !== 0 || e[Ue] === 0, "iterator body cannot be pipelined");
  let s = null;
  function l() {
    if (s) {
      const h = s;
      s = null, h();
    }
  }
  const c = () => new Promise((h, g) => {
    Ae(s === null), n[eA] ? g(n[eA]) : s = h;
  });
  if (e[YA] === "h2") {
    r.on("close", l).on("drain", l);
    try {
      for await (const h of t) {
        if (n[eA])
          throw n[eA];
        const g = r.write(h);
        A.onBodySent(h), g || await c();
      }
    } catch (h) {
      r.destroy(h);
    } finally {
      A.onRequestSent(), r.end(), r.off("close", l).off("drain", l);
    }
    return;
  }
  n.on("close", l).on("drain", l);
  const u = new Th({ socket: n, request: A, contentLength: i, client: e, expectsPayload: o, header: a });
  try {
    for await (const h of t) {
      if (n[eA])
        throw n[eA];
      u.write(h) || await c();
    }
    u.end();
  } catch (h) {
    u.destroy(h);
  } finally {
    n.off("close", l).off("drain", l);
  }
}
class Th {
  constructor({ socket: t, request: e, contentLength: A, client: n, expectsPayload: i, header: a }) {
    this.socket = t, this.request = e, this.contentLength = A, this.client = n, this.bytesWritten = 0, this.expectsPayload = i, this.header = a, t[XA] = !0;
  }
  write(t) {
    const { socket: e, request: A, contentLength: n, client: i, bytesWritten: a, expectsPayload: o, header: s } = this;
    if (e[eA])
      throw e[eA];
    if (e.destroyed)
      return !1;
    const l = Buffer.byteLength(t);
    if (!l)
      return !0;
    if (n !== null && a + l > n) {
      if (i[Fr])
        throw new $A();
      process.emitWarning(new $A());
    }
    e.cork(), a === 0 && (o || (e[hA] = !0), n === null ? e.write(`${s}transfer-encoding: chunked\r
`, "latin1") : e.write(`${s}content-length: ${n}\r
\r
`, "latin1")), n === null && e.write(`\r
${l.toString(16)}\r
`, "latin1"), this.bytesWritten += l;
    const c = e.write(t);
    return e.uncork(), A.onBodySent(t), c || e[Me].timeout && e[Me].timeoutType === ir && e[Me].timeout.refresh && e[Me].timeout.refresh(), c;
  }
  end() {
    const { socket: t, contentLength: e, client: A, bytesWritten: n, expectsPayload: i, header: a, request: o } = this;
    if (o.onRequestSent(), t[XA] = !1, t[eA])
      throw t[eA];
    if (!t.destroyed) {
      if (n === 0 ? i ? t.write(`${a}content-length: 0\r
\r
`, "latin1") : t.write(`${a}\r
`, "latin1") : e === null && t.write(`\r
0\r
\r
`, "latin1"), e !== null && n !== e) {
        if (A[Fr])
          throw new $A();
        process.emitWarning(new $A());
      }
      t[Me].timeout && t[Me].timeoutType === ir && t[Me].timeout.refresh && t[Me].timeout.refresh(), mA(A);
    }
  }
  destroy(t) {
    const { socket: e, client: A } = this;
    e[XA] = !1, t && (Ae(A[Ue] <= 1, "pipeline should only contain this request"), ae.destroy(e, t));
  }
}
function gA(r, t, e) {
  try {
    t.onError(e), Ae(t.aborted);
  } catch (A) {
    r.emit("error", A);
  }
}
var wi = _f;
const Fh = 2048, Ao = Fh - 1;
class Tc {
  constructor() {
    this.bottom = 0, this.top = 0, this.list = new Array(Fh), this.next = null;
  }
  isEmpty() {
    return this.top === this.bottom;
  }
  isFull() {
    return (this.top + 1 & Ao) === this.bottom;
  }
  push(t) {
    this.list[this.top] = t, this.top = this.top + 1 & Ao;
  }
  shift() {
    const t = this.list[this.bottom];
    return t === void 0 ? null : (this.list[this.bottom] = void 0, this.bottom = this.bottom + 1 & Ao, t);
  }
}
var tQ = class {
  constructor() {
    this.head = this.tail = new Tc();
  }
  isEmpty() {
    return this.head.isEmpty();
  }
  push(t) {
    this.head.isFull() && (this.head = this.head.next = new Tc()), this.head.push(t);
  }
  shift() {
    const t = this.tail, e = t.shift();
    return t.isEmpty() && t.next !== null && (this.tail = t.next), e;
  }
};
const { kFree: rQ, kConnected: nQ, kPending: iQ, kQueued: aQ, kRunning: oQ, kSize: sQ } = Re, dt = Symbol("pool");
let cQ = class {
  constructor(t) {
    this[dt] = t;
  }
  get connected() {
    return this[dt][nQ];
  }
  get free() {
    return this[dt][rQ];
  }
  get pending() {
    return this[dt][iQ];
  }
  get queued() {
    return this[dt][aQ];
  }
  get running() {
    return this[dt][oQ];
  }
  get size() {
    return this[dt][sQ];
  }
};
var lQ = cQ;
const uQ = pi, hQ = tQ, { kConnected: to, kSize: Fc, kRunning: Rc, kPending: Dc, kQueued: Qr, kBusy: gQ, kFree: EQ, kUrl: CQ, kClose: fQ, kDestroy: QQ, kDispatch: BQ } = Re, IQ = lQ, fA = Symbol("clients"), uA = Symbol("needDrain"), Br = Symbol("queue"), ro = Symbol("closed resolve"), no = Symbol("onDrain"), Nc = Symbol("onConnect"), Sc = Symbol("onDisconnect"), Uc = Symbol("onConnectionError"), us = Symbol("get dispatcher"), Rh = Symbol("add client"), Dh = Symbol("remove client"), Pc = Symbol("stats");
let dQ = class extends uQ {
  constructor() {
    super(), this[Br] = new hQ(), this[fA] = [], this[Qr] = 0;
    const t = this;
    this[no] = function(A, n) {
      const i = t[Br];
      let a = !1;
      for (; !a; ) {
        const o = i.shift();
        if (!o)
          break;
        t[Qr]--, a = !this.dispatch(o.opts, o.handler);
      }
      this[uA] = a, !this[uA] && t[uA] && (t[uA] = !1, t.emit("drain", A, [t, ...n])), t[ro] && i.isEmpty() && Promise.all(t[fA].map((o) => o.close())).then(t[ro]);
    }, this[Nc] = (e, A) => {
      t.emit("connect", e, [t, ...A]);
    }, this[Sc] = (e, A, n) => {
      t.emit("disconnect", e, [t, ...A], n);
    }, this[Uc] = (e, A, n) => {
      t.emit("connectionError", e, [t, ...A], n);
    }, this[Pc] = new IQ(this);
  }
  get [gQ]() {
    return this[uA];
  }
  get [to]() {
    return this[fA].filter((t) => t[to]).length;
  }
  get [EQ]() {
    return this[fA].filter((t) => t[to] && !t[uA]).length;
  }
  get [Dc]() {
    let t = this[Qr];
    for (const { [Dc]: e } of this[fA])
      t += e;
    return t;
  }
  get [Rc]() {
    let t = 0;
    for (const { [Rc]: e } of this[fA])
      t += e;
    return t;
  }
  get [Fc]() {
    let t = this[Qr];
    for (const { [Fc]: e } of this[fA])
      t += e;
    return t;
  }
  get stats() {
    return this[Pc];
  }
  async [fQ]() {
    return this[Br].isEmpty() ? Promise.all(this[fA].map((t) => t.close())) : new Promise((t) => {
      this[ro] = t;
    });
  }
  async [QQ](t) {
    for (; ; ) {
      const e = this[Br].shift();
      if (!e)
        break;
      e.handler.onError(t);
    }
    return Promise.all(this[fA].map((e) => e.destroy(t)));
  }
  [BQ](t, e) {
    const A = this[us]();
    return A ? A.dispatch(t, e) || (A[uA] = !0, this[uA] = !this[us]()) : (this[uA] = !0, this[Br].push({ opts: t, handler: e }), this[Qr]++), !this[uA];
  }
  [Rh](t) {
    return t.on("drain", this[no]).on("connect", this[Nc]).on("disconnect", this[Sc]).on("connectionError", this[Uc]), this[fA].push(t), this[uA] && process.nextTick(() => {
      this[uA] && this[no](t[CQ], [this, t]);
    }), this;
  }
  [Dh](t) {
    t.close(() => {
      const e = this[fA].indexOf(t);
      e !== -1 && this[fA].splice(e, 1);
    }), this[uA] = this[fA].some((e) => !e[uA] && e.closed !== !0 && e.destroyed !== !0);
  }
};
var Nh = {
  PoolBase: dQ,
  kClients: fA,
  kNeedDrain: uA,
  kAddClient: Rh,
  kRemoveClient: Dh,
  kGetDispatcher: us
};
const {
  PoolBase: pQ,
  kClients: Mc,
  kNeedDrain: yQ,
  kAddClient: mQ,
  kGetDispatcher: wQ
} = Nh, vQ = wi, {
  InvalidArgumentError: io
} = ke, ao = Ie, { kUrl: Lc, kInterceptors: kQ } = Re, bQ = yi, oo = Symbol("options"), so = Symbol("connections"), Hc = Symbol("factory");
function TQ(r, t) {
  return new vQ(r, t);
}
let FQ = class extends pQ {
  constructor(t, {
    connections: e,
    factory: A = TQ,
    connect: n,
    connectTimeout: i,
    tls: a,
    maxCachedSessions: o,
    socketPath: s,
    autoSelectFamily: l,
    autoSelectFamilyAttemptTimeout: c,
    allowH2: u,
    ...h
  } = {}) {
    if (super(), e != null && (!Number.isFinite(e) || e < 0))
      throw new io("invalid connections");
    if (typeof A != "function")
      throw new io("factory must be a function.");
    if (n != null && typeof n != "function" && typeof n != "object")
      throw new io("connect must be a function or an object");
    typeof n != "function" && (n = bQ({
      ...a,
      maxCachedSessions: o,
      allowH2: u,
      socketPath: s,
      timeout: i,
      ...ao.nodeHasAutoSelectFamily && l ? { autoSelectFamily: l, autoSelectFamilyAttemptTimeout: c } : void 0,
      ...n
    })), this[kQ] = h.interceptors && h.interceptors.Pool && Array.isArray(h.interceptors.Pool) ? h.interceptors.Pool : [], this[so] = e || null, this[Lc] = ao.parseOrigin(t), this[oo] = { ...ao.deepClone(h), connect: n, allowH2: u }, this[oo].interceptors = h.interceptors ? { ...h.interceptors } : void 0, this[Hc] = A;
  }
  [wQ]() {
    let t = this[Mc].find((e) => !e[yQ]);
    return t || ((!this[so] || this[Mc].length < this[so]) && (t = this[Hc](this[Lc], this[oo]), this[mQ](t)), t);
  }
};
var Qn = FQ;
const {
  BalancedPoolMissingUpstreamError: RQ,
  InvalidArgumentError: DQ
} = ke, {
  PoolBase: NQ,
  kClients: lA,
  kNeedDrain: Ir,
  kAddClient: SQ,
  kRemoveClient: UQ,
  kGetDispatcher: PQ
} = Nh, MQ = Qn, { kUrl: co, kInterceptors: LQ } = Re, { parseOrigin: Gc } = Ie, Wc = Symbol("factory"), Nn = Symbol("options"), Yc = Symbol("kGreatestCommonDivisor"), pt = Symbol("kCurrentWeight"), yt = Symbol("kIndex"), wA = Symbol("kWeight"), Sn = Symbol("kMaxWeightPerServer"), Un = Symbol("kErrorPenalty");
function Sh(r, t) {
  return t === 0 ? r : Sh(t, r % t);
}
function HQ(r, t) {
  return new MQ(r, t);
}
let GQ = class extends NQ {
  constructor(t = [], { factory: e = HQ, ...A } = {}) {
    if (super(), this[Nn] = A, this[yt] = -1, this[pt] = 0, this[Sn] = this[Nn].maxWeightPerServer || 100, this[Un] = this[Nn].errorPenalty || 15, Array.isArray(t) || (t = [t]), typeof e != "function")
      throw new DQ("factory must be a function.");
    this[LQ] = A.interceptors && A.interceptors.BalancedPool && Array.isArray(A.interceptors.BalancedPool) ? A.interceptors.BalancedPool : [], this[Wc] = e;
    for (const n of t)
      this.addUpstream(n);
    this._updateBalancedPoolStats();
  }
  addUpstream(t) {
    const e = Gc(t).origin;
    if (this[lA].find((n) => n[co].origin === e && n.closed !== !0 && n.destroyed !== !0))
      return this;
    const A = this[Wc](e, Object.assign({}, this[Nn]));
    this[SQ](A), A.on("connect", () => {
      A[wA] = Math.min(this[Sn], A[wA] + this[Un]);
    }), A.on("connectionError", () => {
      A[wA] = Math.max(1, A[wA] - this[Un]), this._updateBalancedPoolStats();
    }), A.on("disconnect", (...n) => {
      const i = n[2];
      i && i.code === "UND_ERR_SOCKET" && (A[wA] = Math.max(1, A[wA] - this[Un]), this._updateBalancedPoolStats());
    });
    for (const n of this[lA])
      n[wA] = this[Sn];
    return this._updateBalancedPoolStats(), this;
  }
  _updateBalancedPoolStats() {
    this[Yc] = this[lA].map((t) => t[wA]).reduce(Sh, 0);
  }
  removeUpstream(t) {
    const e = Gc(t).origin, A = this[lA].find((n) => n[co].origin === e && n.closed !== !0 && n.destroyed !== !0);
    return A && this[UQ](A), this;
  }
  get upstreams() {
    return this[lA].filter((t) => t.closed !== !0 && t.destroyed !== !0).map((t) => t[co].origin);
  }
  [PQ]() {
    if (this[lA].length === 0)
      throw new RQ();
    if (!this[lA].find((i) => !i[Ir] && i.closed !== !0 && i.destroyed !== !0) || this[lA].map((i) => i[Ir]).reduce((i, a) => i && a, !0))
      return;
    let A = 0, n = this[lA].findIndex((i) => !i[Ir]);
    for (; A++ < this[lA].length; ) {
      this[yt] = (this[yt] + 1) % this[lA].length;
      const i = this[lA][this[yt]];
      if (i[wA] > this[lA][n][wA] && !i[Ir] && (n = this[yt]), this[yt] === 0 && (this[pt] = this[pt] - this[Yc], this[pt] <= 0 && (this[pt] = this[Sn])), i[wA] >= this[pt] && !i[Ir])
        return i;
    }
    return this[pt] = this[lA][n][wA], this[yt] = n, this[lA][n];
  }
};
var WQ = GQ;
const { kConnected: Uh, kSize: Ph } = Re;
class Jc {
  constructor(t) {
    this.value = t;
  }
  deref() {
    return this.value[Uh] === 0 && this.value[Ph] === 0 ? void 0 : this.value;
  }
}
class _c {
  constructor(t) {
    this.finalizer = t;
  }
  register(t, e) {
    t.on && t.on("disconnect", () => {
      t[Uh] === 0 && t[Ph] === 0 && this.finalizer(e);
    });
  }
}
var Mh = function() {
  return process.env.NODE_V8_COVERAGE ? {
    WeakRef: Jc,
    FinalizationRegistry: _c
  } : {
    WeakRef: se.WeakRef || Jc,
    FinalizationRegistry: se.FinalizationRegistry || _c
  };
};
const { InvalidArgumentError: Pn } = ke, { kClients: tt, kRunning: xc, kClose: YQ, kDestroy: JQ, kDispatch: _Q, kInterceptors: xQ } = Re, OQ = pi, qQ = Qn, jQ = wi, VQ = Ie, $Q = Ns, { WeakRef: XQ, FinalizationRegistry: ZQ } = Mh(), Oc = Symbol("onConnect"), qc = Symbol("onDisconnect"), jc = Symbol("onConnectionError"), KQ = Symbol("maxRedirections"), Vc = Symbol("onDrain"), $c = Symbol("factory"), Xc = Symbol("finalizer"), lo = Symbol("options");
function zQ(r, t) {
  return t && t.connections === 1 ? new jQ(r, t) : new qQ(r, t);
}
let eB = class extends OQ {
  constructor({ factory: t = zQ, maxRedirections: e = 0, connect: A, ...n } = {}) {
    if (super(), typeof t != "function")
      throw new Pn("factory must be a function.");
    if (A != null && typeof A != "function" && typeof A != "object")
      throw new Pn("connect must be a function or an object");
    if (!Number.isInteger(e) || e < 0)
      throw new Pn("maxRedirections must be a positive number");
    A && typeof A != "function" && (A = { ...A }), this[xQ] = n.interceptors && n.interceptors.Agent && Array.isArray(n.interceptors.Agent) ? n.interceptors.Agent : [$Q({ maxRedirections: e })], this[lo] = { ...VQ.deepClone(n), connect: A }, this[lo].interceptors = n.interceptors ? { ...n.interceptors } : void 0, this[KQ] = e, this[$c] = t, this[tt] = /* @__PURE__ */ new Map(), this[Xc] = new ZQ(
      /* istanbul ignore next: gc is undeterministic */
      (a) => {
        const o = this[tt].get(a);
        o !== void 0 && o.deref() === void 0 && this[tt].delete(a);
      }
    );
    const i = this;
    this[Vc] = (a, o) => {
      i.emit("drain", a, [i, ...o]);
    }, this[Oc] = (a, o) => {
      i.emit("connect", a, [i, ...o]);
    }, this[qc] = (a, o, s) => {
      i.emit("disconnect", a, [i, ...o], s);
    }, this[jc] = (a, o, s) => {
      i.emit("connectionError", a, [i, ...o], s);
    };
  }
  get [xc]() {
    let t = 0;
    for (const e of this[tt].values()) {
      const A = e.deref();
      A && (t += A[xc]);
    }
    return t;
  }
  [_Q](t, e) {
    let A;
    if (t.origin && (typeof t.origin == "string" || t.origin instanceof URL))
      A = String(t.origin);
    else
      throw new Pn("opts.origin must be a non-empty string or URL.");
    const n = this[tt].get(A);
    let i = n ? n.deref() : null;
    return i || (i = this[$c](t.origin, this[lo]).on("drain", this[Vc]).on("connect", this[Oc]).on("disconnect", this[qc]).on("connectionError", this[jc]), this[tt].set(A, new XQ(i)), this[Xc].register(i, A)), i.dispatch(t, e);
  }
  async [YQ]() {
    const t = [];
    for (const e of this[tt].values()) {
      const A = e.deref();
      A && t.push(A.close());
    }
    await Promise.all(t);
  }
  async [JQ](t) {
    const e = [];
    for (const A of this[tt].values()) {
      const n = A.deref();
      n && e.push(n.destroy(t));
    }
    await Promise.all(e);
  }
};
var vi = eB, or = {}, Us = { exports: {} };
const Lh = L, { Readable: AB } = L, { RequestAbortedError: Hh, NotSupportedError: tB, InvalidArgumentError: rB } = ke, ri = Ie, { ReadableStreamFrom: nB, toUSVString: iB } = Ie;
let uo;
const dA = Symbol("kConsume"), Mn = Symbol("kReading"), it = Symbol("kBody"), Zc = Symbol("abort"), Gh = Symbol("kContentType"), Kc = () => {
};
var aB = class extends AB {
  constructor({
    resume: t,
    abort: e,
    contentType: A = "",
    highWaterMark: n = 64 * 1024
    // Same as nodejs fs streams.
  }) {
    super({
      autoDestroy: !0,
      read: t,
      highWaterMark: n
    }), this._readableState.dataEmitted = !1, this[Zc] = e, this[dA] = null, this[it] = null, this[Gh] = A, this[Mn] = !1;
  }
  destroy(t) {
    return this.destroyed ? this : (!t && !this._readableState.endEmitted && (t = new Hh()), t && this[Zc](), super.destroy(t));
  }
  emit(t, ...e) {
    return t === "data" ? this._readableState.dataEmitted = !0 : t === "error" && (this._readableState.errorEmitted = !0), super.emit(t, ...e);
  }
  on(t, ...e) {
    return (t === "data" || t === "readable") && (this[Mn] = !0), super.on(t, ...e);
  }
  addListener(t, ...e) {
    return this.on(t, ...e);
  }
  off(t, ...e) {
    const A = super.off(t, ...e);
    return (t === "data" || t === "readable") && (this[Mn] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0), A;
  }
  removeListener(t, ...e) {
    return this.off(t, ...e);
  }
  push(t) {
    return this[dA] && t !== null && this.readableLength === 0 ? (Wh(this[dA], t), this[Mn] ? super.push(t) : !0) : super.push(t);
  }
  // https://fetch.spec.whatwg.org/#dom-body-text
  async text() {
    return Ln(this, "text");
  }
  // https://fetch.spec.whatwg.org/#dom-body-json
  async json() {
    return Ln(this, "json");
  }
  // https://fetch.spec.whatwg.org/#dom-body-blob
  async blob() {
    return Ln(this, "blob");
  }
  // https://fetch.spec.whatwg.org/#dom-body-arraybuffer
  async arrayBuffer() {
    return Ln(this, "arrayBuffer");
  }
  // https://fetch.spec.whatwg.org/#dom-body-formdata
  async formData() {
    throw new tB();
  }
  // https://fetch.spec.whatwg.org/#dom-body-bodyused
  get bodyUsed() {
    return ri.isDisturbed(this);
  }
  // https://fetch.spec.whatwg.org/#dom-body-body
  get body() {
    return this[it] || (this[it] = nB(this), this[dA] && (this[it].getReader(), Lh(this[it].locked))), this[it];
  }
  dump(t) {
    let e = t && Number.isFinite(t.limit) ? t.limit : 262144;
    const A = t && t.signal;
    if (A)
      try {
        if (typeof A != "object" || !("aborted" in A))
          throw new rB("signal must be an AbortSignal");
        ri.throwIfAborted(A);
      } catch (n) {
        return Promise.reject(n);
      }
    return this.closed ? Promise.resolve(null) : new Promise((n, i) => {
      const a = A ? ri.addAbortListener(A, () => {
        this.destroy();
      }) : Kc;
      this.on("close", function() {
        a(), A && A.aborted ? i(A.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" })) : n(null);
      }).on("error", Kc).on("data", function(o) {
        e -= o.length, e <= 0 && this.destroy();
      }).resume();
    });
  }
};
function oB(r) {
  return r[it] && r[it].locked === !0 || r[dA];
}
function sB(r) {
  return ri.isDisturbed(r) || oB(r);
}
async function Ln(r, t) {
  if (sB(r))
    throw new TypeError("unusable");
  return Lh(!r[dA]), new Promise((e, A) => {
    r[dA] = {
      type: t,
      stream: r,
      resolve: e,
      reject: A,
      length: 0,
      body: []
    }, r.on("error", function(n) {
      hs(this[dA], n);
    }).on("close", function() {
      this[dA].body !== null && hs(this[dA], new Hh());
    }), process.nextTick(cB, r[dA]);
  });
}
function cB(r) {
  if (r.body === null)
    return;
  const { _readableState: t } = r.stream;
  for (const e of t.buffer)
    Wh(r, e);
  for (t.endEmitted ? zc(this[dA]) : r.stream.on("end", function() {
    zc(this[dA]);
  }), r.stream.resume(); r.stream.read() != null; )
    ;
}
function zc(r) {
  const { type: t, body: e, resolve: A, stream: n, length: i } = r;
  try {
    if (t === "text")
      A(iB(Buffer.concat(e)));
    else if (t === "json")
      A(JSON.parse(Buffer.concat(e)));
    else if (t === "arrayBuffer") {
      const a = new Uint8Array(i);
      let o = 0;
      for (const s of e)
        a.set(s, o), o += s.byteLength;
      A(a.buffer);
    } else
      t === "blob" && (uo || (uo = L.Blob), A(new uo(e, { type: n[Gh] })));
    hs(r);
  } catch (a) {
    n.destroy(a);
  }
}
function Wh(r, t) {
  r.length += t.length, r.body.push(t);
}
function hs(r, t) {
  r.body !== null && (t ? r.reject(t) : r.resolve(), r.type = null, r.stream = null, r.resolve = null, r.reject = null, r.length = 0, r.body = null);
}
const lB = L, {
  ResponseStatusCodeError: Hn
} = ke, { toUSVString: el } = Ie;
async function uB({ callback: r, body: t, contentType: e, statusCode: A, statusMessage: n, headers: i }) {
  lB(t);
  let a = [], o = 0;
  for await (const s of t)
    if (a.push(s), o += s.length, o > 128 * 1024) {
      a = null;
      break;
    }
  if (A === 204 || !e || !a) {
    process.nextTick(r, new Hn(`Response status code ${A}${n ? `: ${n}` : ""}`, A, i));
    return;
  }
  try {
    if (e.startsWith("application/json")) {
      const s = JSON.parse(el(Buffer.concat(a)));
      process.nextTick(r, new Hn(`Response status code ${A}${n ? `: ${n}` : ""}`, A, i, s));
      return;
    }
    if (e.startsWith("text/")) {
      const s = el(Buffer.concat(a));
      process.nextTick(r, new Hn(`Response status code ${A}${n ? `: ${n}` : ""}`, A, i, s));
      return;
    }
  } catch {
  }
  process.nextTick(r, new Hn(`Response status code ${A}${n ? `: ${n}` : ""}`, A, i));
}
var Yh = { getResolveErrorBodyCallback: uB };
const { addAbortListener: hB } = Ie, { RequestAbortedError: gB } = ke, Xt = Symbol("kListener"), ct = Symbol("kSignal");
function Al(r) {
  r.abort ? r.abort() : r.onError(new gB());
}
function EB(r, t) {
  if (r[ct] = null, r[Xt] = null, !!t) {
    if (t.aborted) {
      Al(r);
      return;
    }
    r[ct] = t, r[Xt] = () => {
      Al(r);
    }, hB(r[ct], r[Xt]);
  }
}
function CB(r) {
  r[ct] && ("removeEventListener" in r[ct] ? r[ct].removeEventListener("abort", r[Xt]) : r[ct].removeListener("abort", r[Xt]), r[ct] = null, r[Xt] = null);
}
var Bn = {
  addSignal: EB,
  removeSignal: CB
};
const fB = aB, {
  InvalidArgumentError: Ot,
  RequestAbortedError: QB
} = ke, MA = Ie, { getResolveErrorBodyCallback: BB } = Yh, { AsyncResource: IB } = L, { addSignal: dB, removeSignal: tl } = Bn;
class Jh extends IB {
  constructor(t, e) {
    if (!t || typeof t != "object")
      throw new Ot("invalid opts");
    const { signal: A, method: n, opaque: i, body: a, onInfo: o, responseHeaders: s, throwOnError: l, highWaterMark: c } = t;
    try {
      if (typeof e != "function")
        throw new Ot("invalid callback");
      if (c && (typeof c != "number" || c < 0))
        throw new Ot("invalid highWaterMark");
      if (A && typeof A.on != "function" && typeof A.addEventListener != "function")
        throw new Ot("signal must be an EventEmitter or EventTarget");
      if (n === "CONNECT")
        throw new Ot("invalid method");
      if (o && typeof o != "function")
        throw new Ot("invalid onInfo callback");
      super("UNDICI_REQUEST");
    } catch (u) {
      throw MA.isStream(a) && MA.destroy(a.on("error", MA.nop), u), u;
    }
    this.responseHeaders = s || null, this.opaque = i || null, this.callback = e, this.res = null, this.abort = null, this.body = a, this.trailers = {}, this.context = null, this.onInfo = o || null, this.throwOnError = l, this.highWaterMark = c, MA.isStream(a) && a.on("error", (u) => {
      this.onError(u);
    }), dB(this, A);
  }
  onConnect(t, e) {
    if (!this.callback)
      throw new QB();
    this.abort = t, this.context = e;
  }
  onHeaders(t, e, A, n) {
    const { callback: i, opaque: a, abort: o, context: s, responseHeaders: l, highWaterMark: c } = this, u = l === "raw" ? MA.parseRawHeaders(e) : MA.parseHeaders(e);
    if (t < 200) {
      this.onInfo && this.onInfo({ statusCode: t, headers: u });
      return;
    }
    const g = (l === "raw" ? MA.parseHeaders(e) : u)["content-type"], d = new fB({ resume: A, abort: o, contentType: g, highWaterMark: c });
    this.callback = null, this.res = d, i !== null && (this.throwOnError && t >= 400 ? this.runInAsyncScope(
      BB,
      null,
      { callback: i, body: d, contentType: g, statusCode: t, statusMessage: n, headers: u }
    ) : this.runInAsyncScope(i, null, null, {
      statusCode: t,
      headers: u,
      trailers: this.trailers,
      opaque: a,
      body: d,
      context: s
    }));
  }
  onData(t) {
    const { res: e } = this;
    return e.push(t);
  }
  onComplete(t) {
    const { res: e } = this;
    tl(this), MA.parseHeaders(t, this.trailers), e.push(null);
  }
  onError(t) {
    const { res: e, callback: A, body: n, opaque: i } = this;
    tl(this), A && (this.callback = null, queueMicrotask(() => {
      this.runInAsyncScope(A, null, t, { opaque: i });
    })), e && (this.res = null, queueMicrotask(() => {
      MA.destroy(e, t);
    })), n && (this.body = null, MA.destroy(n, t));
  }
}
function _h(r, t) {
  if (t === void 0)
    return new Promise((e, A) => {
      _h.call(this, r, (n, i) => n ? A(n) : e(i));
    });
  try {
    this.dispatch(r, new Jh(r, t));
  } catch (e) {
    if (typeof t != "function")
      throw e;
    const A = r && r.opaque;
    queueMicrotask(() => t(e, { opaque: A }));
  }
}
Us.exports = _h;
Us.exports.RequestHandler = Jh;
var pB = Us.exports;
const { finished: yB, PassThrough: mB } = L, {
  InvalidArgumentError: qt,
  InvalidReturnValueError: wB,
  RequestAbortedError: vB
} = ke, RA = Ie, { getResolveErrorBodyCallback: kB } = Yh, { AsyncResource: bB } = L, { addSignal: TB, removeSignal: rl } = Bn;
class FB extends bB {
  constructor(t, e, A) {
    if (!t || typeof t != "object")
      throw new qt("invalid opts");
    const { signal: n, method: i, opaque: a, body: o, onInfo: s, responseHeaders: l, throwOnError: c } = t;
    try {
      if (typeof A != "function")
        throw new qt("invalid callback");
      if (typeof e != "function")
        throw new qt("invalid factory");
      if (n && typeof n.on != "function" && typeof n.addEventListener != "function")
        throw new qt("signal must be an EventEmitter or EventTarget");
      if (i === "CONNECT")
        throw new qt("invalid method");
      if (s && typeof s != "function")
        throw new qt("invalid onInfo callback");
      super("UNDICI_STREAM");
    } catch (u) {
      throw RA.isStream(o) && RA.destroy(o.on("error", RA.nop), u), u;
    }
    this.responseHeaders = l || null, this.opaque = a || null, this.factory = e, this.callback = A, this.res = null, this.abort = null, this.context = null, this.trailers = null, this.body = o, this.onInfo = s || null, this.throwOnError = c || !1, RA.isStream(o) && o.on("error", (u) => {
      this.onError(u);
    }), TB(this, n);
  }
  onConnect(t, e) {
    if (!this.callback)
      throw new vB();
    this.abort = t, this.context = e;
  }
  onHeaders(t, e, A, n) {
    const { factory: i, opaque: a, context: o, callback: s, responseHeaders: l } = this, c = l === "raw" ? RA.parseRawHeaders(e) : RA.parseHeaders(e);
    if (t < 200) {
      this.onInfo && this.onInfo({ statusCode: t, headers: c });
      return;
    }
    this.factory = null;
    let u;
    if (this.throwOnError && t >= 400) {
      const d = (l === "raw" ? RA.parseHeaders(e) : c)["content-type"];
      u = new mB(), this.callback = null, this.runInAsyncScope(
        kB,
        null,
        { callback: s, body: u, contentType: d, statusCode: t, statusMessage: n, headers: c }
      );
    } else {
      if (i === null)
        return;
      if (u = this.runInAsyncScope(i, null, {
        statusCode: t,
        headers: c,
        opaque: a,
        context: o
      }), !u || typeof u.write != "function" || typeof u.end != "function" || typeof u.on != "function")
        throw new wB("expected Writable");
      yB(u, { readable: !1 }, (g) => {
        const { callback: d, res: I, opaque: y, trailers: Q, abort: E } = this;
        this.res = null, (g || !I.readable) && RA.destroy(I, g), this.callback = null, this.runInAsyncScope(d, null, g || null, { opaque: y, trailers: Q }), g && E();
      });
    }
    return u.on("drain", A), this.res = u, (u.writableNeedDrain !== void 0 ? u.writableNeedDrain : u._writableState && u._writableState.needDrain) !== !0;
  }
  onData(t) {
    const { res: e } = this;
    return e ? e.write(t) : !0;
  }
  onComplete(t) {
    const { res: e } = this;
    rl(this), e && (this.trailers = RA.parseHeaders(t), e.end());
  }
  onError(t) {
    const { res: e, callback: A, opaque: n, body: i } = this;
    rl(this), this.factory = null, e ? (this.res = null, RA.destroy(e, t)) : A && (this.callback = null, queueMicrotask(() => {
      this.runInAsyncScope(A, null, t, { opaque: n });
    })), i && (this.body = null, RA.destroy(i, t));
  }
}
function xh(r, t, e) {
  if (e === void 0)
    return new Promise((A, n) => {
      xh.call(this, r, t, (i, a) => i ? n(i) : A(a));
    });
  try {
    this.dispatch(r, new FB(r, t, e));
  } catch (A) {
    if (typeof e != "function")
      throw A;
    const n = r && r.opaque;
    queueMicrotask(() => e(A, { opaque: n }));
  }
}
var RB = xh;
const {
  Readable: Oh,
  Duplex: DB,
  PassThrough: NB
} = L, {
  InvalidArgumentError: dr,
  InvalidReturnValueError: SB,
  RequestAbortedError: ni
} = ke, vA = Ie, { AsyncResource: UB } = L, { addSignal: PB, removeSignal: MB } = Bn, LB = L, Zt = Symbol("resume");
class HB extends Oh {
  constructor() {
    super({ autoDestroy: !0 }), this[Zt] = null;
  }
  _read() {
    const { [Zt]: t } = this;
    t && (this[Zt] = null, t());
  }
  _destroy(t, e) {
    this._read(), e(t);
  }
}
class GB extends Oh {
  constructor(t) {
    super({ autoDestroy: !0 }), this[Zt] = t;
  }
  _read() {
    this[Zt]();
  }
  _destroy(t, e) {
    !t && !this._readableState.endEmitted && (t = new ni()), e(t);
  }
}
class WB extends UB {
  constructor(t, e) {
    if (!t || typeof t != "object")
      throw new dr("invalid opts");
    if (typeof e != "function")
      throw new dr("invalid handler");
    const { signal: A, method: n, opaque: i, onInfo: a, responseHeaders: o } = t;
    if (A && typeof A.on != "function" && typeof A.addEventListener != "function")
      throw new dr("signal must be an EventEmitter or EventTarget");
    if (n === "CONNECT")
      throw new dr("invalid method");
    if (a && typeof a != "function")
      throw new dr("invalid onInfo callback");
    super("UNDICI_PIPELINE"), this.opaque = i || null, this.responseHeaders = o || null, this.handler = e, this.abort = null, this.context = null, this.onInfo = a || null, this.req = new HB().on("error", vA.nop), this.ret = new DB({
      readableObjectMode: t.objectMode,
      autoDestroy: !0,
      read: () => {
        const { body: s } = this;
        s && s.resume && s.resume();
      },
      write: (s, l, c) => {
        const { req: u } = this;
        u.push(s, l) || u._readableState.destroyed ? c() : u[Zt] = c;
      },
      destroy: (s, l) => {
        const { body: c, req: u, res: h, ret: g, abort: d } = this;
        !s && !g._readableState.endEmitted && (s = new ni()), d && s && d(), vA.destroy(c, s), vA.destroy(u, s), vA.destroy(h, s), MB(this), l(s);
      }
    }).on("prefinish", () => {
      const { req: s } = this;
      s.push(null);
    }), this.res = null, PB(this, A);
  }
  onConnect(t, e) {
    const { ret: A, res: n } = this;
    if (LB(!n, "pipeline cannot be retried"), A.destroyed)
      throw new ni();
    this.abort = t, this.context = e;
  }
  onHeaders(t, e, A) {
    const { opaque: n, handler: i, context: a } = this;
    if (t < 200) {
      if (this.onInfo) {
        const s = this.responseHeaders === "raw" ? vA.parseRawHeaders(e) : vA.parseHeaders(e);
        this.onInfo({ statusCode: t, headers: s });
      }
      return;
    }
    this.res = new GB(A);
    let o;
    try {
      this.handler = null;
      const s = this.responseHeaders === "raw" ? vA.parseRawHeaders(e) : vA.parseHeaders(e);
      o = this.runInAsyncScope(i, null, {
        statusCode: t,
        headers: s,
        opaque: n,
        body: this.res,
        context: a
      });
    } catch (s) {
      throw this.res.on("error", vA.nop), s;
    }
    if (!o || typeof o.on != "function")
      throw new SB("expected Readable");
    o.on("data", (s) => {
      const { ret: l, body: c } = this;
      !l.push(s) && c.pause && c.pause();
    }).on("error", (s) => {
      const { ret: l } = this;
      vA.destroy(l, s);
    }).on("end", () => {
      const { ret: s } = this;
      s.push(null);
    }).on("close", () => {
      const { ret: s } = this;
      s._readableState.ended || vA.destroy(s, new ni());
    }), this.body = o;
  }
  onData(t) {
    const { res: e } = this;
    return e.push(t);
  }
  onComplete(t) {
    const { res: e } = this;
    e.push(null);
  }
  onError(t) {
    const { ret: e } = this;
    this.handler = null, vA.destroy(e, t);
  }
}
function YB(r, t) {
  try {
    const e = new WB(r, t);
    return this.dispatch({ ...r, body: e.req }, e), e.ret;
  } catch (e) {
    return new NB().destroy(e);
  }
}
var JB = YB;
const { InvalidArgumentError: ho, RequestAbortedError: _B, SocketError: xB } = ke, { AsyncResource: OB } = L, nl = Ie, { addSignal: qB, removeSignal: il } = Bn, jB = L;
class VB extends OB {
  constructor(t, e) {
    if (!t || typeof t != "object")
      throw new ho("invalid opts");
    if (typeof e != "function")
      throw new ho("invalid callback");
    const { signal: A, opaque: n, responseHeaders: i } = t;
    if (A && typeof A.on != "function" && typeof A.addEventListener != "function")
      throw new ho("signal must be an EventEmitter or EventTarget");
    super("UNDICI_UPGRADE"), this.responseHeaders = i || null, this.opaque = n || null, this.callback = e, this.abort = null, this.context = null, qB(this, A);
  }
  onConnect(t, e) {
    if (!this.callback)
      throw new _B();
    this.abort = t, this.context = null;
  }
  onHeaders() {
    throw new xB("bad upgrade", null);
  }
  onUpgrade(t, e, A) {
    const { callback: n, opaque: i, context: a } = this;
    jB.strictEqual(t, 101), il(this), this.callback = null;
    const o = this.responseHeaders === "raw" ? nl.parseRawHeaders(e) : nl.parseHeaders(e);
    this.runInAsyncScope(n, null, null, {
      headers: o,
      socket: A,
      opaque: i,
      context: a
    });
  }
  onError(t) {
    const { callback: e, opaque: A } = this;
    il(this), e && (this.callback = null, queueMicrotask(() => {
      this.runInAsyncScope(e, null, t, { opaque: A });
    }));
  }
}
function qh(r, t) {
  if (t === void 0)
    return new Promise((e, A) => {
      qh.call(this, r, (n, i) => n ? A(n) : e(i));
    });
  try {
    const e = new VB(r, t);
    this.dispatch({
      ...r,
      method: r.method || "GET",
      upgrade: r.protocol || "Websocket"
    }, e);
  } catch (e) {
    if (typeof t != "function")
      throw e;
    const A = r && r.opaque;
    queueMicrotask(() => t(e, { opaque: A }));
  }
}
var $B = qh;
const { AsyncResource: XB } = L, { InvalidArgumentError: go, RequestAbortedError: ZB, SocketError: KB } = ke, al = Ie, { addSignal: zB, removeSignal: ol } = Bn;
class eI extends XB {
  constructor(t, e) {
    if (!t || typeof t != "object")
      throw new go("invalid opts");
    if (typeof e != "function")
      throw new go("invalid callback");
    const { signal: A, opaque: n, responseHeaders: i } = t;
    if (A && typeof A.on != "function" && typeof A.addEventListener != "function")
      throw new go("signal must be an EventEmitter or EventTarget");
    super("UNDICI_CONNECT"), this.opaque = n || null, this.responseHeaders = i || null, this.callback = e, this.abort = null, zB(this, A);
  }
  onConnect(t, e) {
    if (!this.callback)
      throw new ZB();
    this.abort = t, this.context = e;
  }
  onHeaders() {
    throw new KB("bad connect", null);
  }
  onUpgrade(t, e, A) {
    const { callback: n, opaque: i, context: a } = this;
    ol(this), this.callback = null;
    let o = e;
    o != null && (o = this.responseHeaders === "raw" ? al.parseRawHeaders(e) : al.parseHeaders(e)), this.runInAsyncScope(n, null, null, {
      statusCode: t,
      headers: o,
      socket: A,
      opaque: i,
      context: a
    });
  }
  onError(t) {
    const { callback: e, opaque: A } = this;
    ol(this), e && (this.callback = null, queueMicrotask(() => {
      this.runInAsyncScope(e, null, t, { opaque: A });
    }));
  }
}
function jh(r, t) {
  if (t === void 0)
    return new Promise((e, A) => {
      jh.call(this, r, (n, i) => n ? A(n) : e(i));
    });
  try {
    const e = new eI(r, t);
    this.dispatch({ ...r, method: "CONNECT" }, e);
  } catch (e) {
    if (typeof t != "function")
      throw e;
    const A = r && r.opaque;
    queueMicrotask(() => t(e, { opaque: A }));
  }
}
var AI = jh;
or.request = pB;
or.stream = RB;
or.pipeline = JB;
or.upgrade = $B;
or.connect = AI;
const { UndiciError: tI } = ke;
let rI = class Vh extends tI {
  constructor(t) {
    super(t), Error.captureStackTrace(this, Vh), this.name = "MockNotMatchedError", this.message = t || "The request does not match any registered mock dispatches", this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
  }
};
var $h = {
  MockNotMatchedError: rI
}, In = {
  kAgent: Symbol("agent"),
  kOptions: Symbol("options"),
  kFactory: Symbol("factory"),
  kDispatches: Symbol("dispatches"),
  kDispatchKey: Symbol("dispatch key"),
  kDefaultHeaders: Symbol("default headers"),
  kDefaultTrailers: Symbol("default trailers"),
  kContentLength: Symbol("content length"),
  kMockAgent: Symbol("mock agent"),
  kMockAgentSet: Symbol("mock agent set"),
  kMockAgentGet: Symbol("mock agent get"),
  kMockDispatch: Symbol("mock dispatch"),
  kClose: Symbol("close"),
  kOriginalClose: Symbol("original agent close"),
  kOrigin: Symbol("origin"),
  kIsMockActive: Symbol("is mock active"),
  kNetConnect: Symbol("net connect"),
  kGetNetConnect: Symbol("get net connect"),
  kConnected: Symbol("connected")
};
const { MockNotMatchedError: bt } = $h, {
  kDispatches: Gn,
  kMockAgent: nI,
  kOriginalDispatch: iI,
  kOrigin: aI,
  kGetNetConnect: oI
} = In, { buildURL: sI, nop: cI } = Ie, { STATUS_CODES: lI } = L, {
  types: {
    isPromise: uI
  }
} = L;
function ZA(r, t) {
  return typeof r == "string" ? r === t : r instanceof RegExp ? r.test(t) : typeof r == "function" ? r(t) === !0 : !1;
}
function Xh(r) {
  return Object.fromEntries(
    Object.entries(r).map(([t, e]) => [t.toLocaleLowerCase(), e])
  );
}
function Zh(r, t) {
  if (Array.isArray(r)) {
    for (let e = 0; e < r.length; e += 2)
      if (r[e].toLocaleLowerCase() === t.toLocaleLowerCase())
        return r[e + 1];
    return;
  } else
    return typeof r.get == "function" ? r.get(t) : Xh(r)[t.toLocaleLowerCase()];
}
function Kh(r) {
  const t = r.slice(), e = [];
  for (let A = 0; A < t.length; A += 2)
    e.push([t[A], t[A + 1]]);
  return Object.fromEntries(e);
}
function zh(r, t) {
  if (typeof r.headers == "function")
    return Array.isArray(t) && (t = Kh(t)), r.headers(t ? Xh(t) : {});
  if (typeof r.headers > "u")
    return !0;
  if (typeof t != "object" || typeof r.headers != "object")
    return !1;
  for (const [e, A] of Object.entries(r.headers)) {
    const n = Zh(t, e);
    if (!ZA(A, n))
      return !1;
  }
  return !0;
}
function sl(r) {
  if (typeof r != "string")
    return r;
  const t = r.split("?");
  if (t.length !== 2)
    return r;
  const e = new URLSearchParams(t.pop());
  return e.sort(), [...t, e.toString()].join("?");
}
function hI(r, { path: t, method: e, body: A, headers: n }) {
  const i = ZA(r.path, t), a = ZA(r.method, e), o = typeof r.body < "u" ? ZA(r.body, A) : !0, s = zh(r, n);
  return i && a && o && s;
}
function eg(r) {
  return Buffer.isBuffer(r) ? r : typeof r == "object" ? JSON.stringify(r) : r.toString();
}
function Ag(r, t) {
  const e = t.query ? sI(t.path, t.query) : t.path, A = typeof e == "string" ? sl(e) : e;
  let n = r.filter(({ consumed: i }) => !i).filter(({ path: i }) => ZA(sl(i), A));
  if (n.length === 0)
    throw new bt(`Mock dispatch not matched for path '${A}'`);
  if (n = n.filter(({ method: i }) => ZA(i, t.method)), n.length === 0)
    throw new bt(`Mock dispatch not matched for method '${t.method}'`);
  if (n = n.filter(({ body: i }) => typeof i < "u" ? ZA(i, t.body) : !0), n.length === 0)
    throw new bt(`Mock dispatch not matched for body '${t.body}'`);
  if (n = n.filter((i) => zh(i, t.headers)), n.length === 0)
    throw new bt(`Mock dispatch not matched for headers '${typeof t.headers == "object" ? JSON.stringify(t.headers) : t.headers}'`);
  return n[0];
}
function gI(r, t, e) {
  const A = { timesInvoked: 0, times: 1, persist: !1, consumed: !1 }, n = typeof e == "function" ? { callback: e } : { ...e }, i = { ...A, ...t, pending: !0, data: { error: null, ...n } };
  return r.push(i), i;
}
function gs(r, t) {
  const e = r.findIndex((A) => A.consumed ? hI(A, t) : !1);
  e !== -1 && r.splice(e, 1);
}
function tg(r) {
  const { path: t, method: e, body: A, headers: n, query: i } = r;
  return {
    path: t,
    method: e,
    body: A,
    headers: n,
    query: i
  };
}
function Es(r) {
  return Object.entries(r).reduce((t, [e, A]) => [
    ...t,
    Buffer.from(`${e}`),
    Array.isArray(A) ? A.map((n) => Buffer.from(`${n}`)) : Buffer.from(`${A}`)
  ], []);
}
function rg(r) {
  return lI[r] || "unknown";
}
async function EI(r) {
  const t = [];
  for await (const e of r)
    t.push(e);
  return Buffer.concat(t).toString("utf8");
}
function ng(r, t) {
  const e = tg(r), A = Ag(this[Gn], e);
  A.timesInvoked++, A.data.callback && (A.data = { ...A.data, ...A.data.callback(r) });
  const { data: { statusCode: n, data: i, headers: a, trailers: o, error: s }, delay: l, persist: c } = A, { timesInvoked: u, times: h } = A;
  if (A.consumed = !c && u >= h, A.pending = u < h, s !== null)
    return gs(this[Gn], e), t.onError(s), !0;
  typeof l == "number" && l > 0 ? setTimeout(() => {
    g(this[Gn]);
  }, l) : g(this[Gn]);
  function g(I, y = i) {
    const Q = Array.isArray(r.headers) ? Kh(r.headers) : r.headers, E = typeof y == "function" ? y({ ...r, headers: Q }) : y;
    if (uI(E)) {
      E.then((f) => g(I, f));
      return;
    }
    const B = eg(E), w = Es(a), C = Es(o);
    t.abort = cI, t.onHeaders(n, w, d, rg(n)), t.onData(Buffer.from(B)), t.onComplete(C), gs(I, e);
  }
  function d() {
  }
  return !0;
}
function CI() {
  const r = this[nI], t = this[aI], e = this[iI];
  return function(n, i) {
    if (r.isMockActive)
      try {
        ng.call(this, n, i);
      } catch (a) {
        if (a instanceof bt) {
          const o = r[oI]();
          if (o === !1)
            throw new bt(`${a.message}: subsequent request to origin ${t} was not allowed (net.connect disabled)`);
          if (ig(o, t))
            e.call(this, n, i);
          else
            throw new bt(`${a.message}: subsequent request to origin ${t} was not allowed (net.connect is not enabled for this origin)`);
        } else
          throw a;
      }
    else
      e.call(this, n, i);
  };
}
function ig(r, t) {
  const e = new URL(t);
  return r === !0 ? !0 : !!(Array.isArray(r) && r.some((A) => ZA(A, e.host)));
}
function fI(r) {
  if (r) {
    const { agent: t, ...e } = r;
    return e;
  }
}
var ki = {
  getResponseData: eg,
  getMockDispatch: Ag,
  addMockDispatch: gI,
  deleteMockDispatch: gs,
  buildKey: tg,
  generateKeyValues: Es,
  matchValue: ZA,
  getResponse: EI,
  getStatusText: rg,
  mockDispatch: ng,
  buildMockDispatch: CI,
  checkNetConnect: ig,
  buildMockOptions: fI,
  getHeaderByName: Zh
}, bi = {};
const { getResponseData: QI, buildKey: BI, addMockDispatch: Eo } = ki, {
  kDispatches: Wn,
  kDispatchKey: Yn,
  kDefaultHeaders: Co,
  kDefaultTrailers: fo,
  kContentLength: Qo,
  kMockDispatch: Jn
} = In, { InvalidArgumentError: DA } = ke, { buildURL: II } = Ie;
class ii {
  constructor(t) {
    this[Jn] = t;
  }
  /**
   * Delay a reply by a set amount in ms.
   */
  delay(t) {
    if (typeof t != "number" || !Number.isInteger(t) || t <= 0)
      throw new DA("waitInMs must be a valid integer > 0");
    return this[Jn].delay = t, this;
  }
  /**
   * For a defined reply, never mark as consumed.
   */
  persist() {
    return this[Jn].persist = !0, this;
  }
  /**
   * Allow one to define a reply for a set amount of matching requests.
   */
  times(t) {
    if (typeof t != "number" || !Number.isInteger(t) || t <= 0)
      throw new DA("repeatTimes must be a valid integer > 0");
    return this[Jn].times = t, this;
  }
}
let dI = class {
  constructor(t, e) {
    if (typeof t != "object")
      throw new DA("opts must be an object");
    if (typeof t.path > "u")
      throw new DA("opts.path must be defined");
    if (typeof t.method > "u" && (t.method = "GET"), typeof t.path == "string")
      if (t.query)
        t.path = II(t.path, t.query);
      else {
        const A = new URL(t.path, "data://");
        t.path = A.pathname + A.search;
      }
    typeof t.method == "string" && (t.method = t.method.toUpperCase()), this[Yn] = BI(t), this[Wn] = e, this[Co] = {}, this[fo] = {}, this[Qo] = !1;
  }
  createMockScopeDispatchData(t, e, A = {}) {
    const n = QI(e), i = this[Qo] ? { "content-length": n.length } : {}, a = { ...this[Co], ...i, ...A.headers }, o = { ...this[fo], ...A.trailers };
    return { statusCode: t, data: e, headers: a, trailers: o };
  }
  validateReplyParameters(t, e, A) {
    if (typeof t > "u")
      throw new DA("statusCode must be defined");
    if (typeof e > "u")
      throw new DA("data must be defined");
    if (typeof A != "object")
      throw new DA("responseOptions must be an object");
  }
  /**
   * Mock an undici request with a defined reply.
   */
  reply(t) {
    if (typeof t == "function") {
      const o = (l) => {
        const c = t(l);
        if (typeof c != "object")
          throw new DA("reply options callback must return an object");
        const { statusCode: u, data: h = "", responseOptions: g = {} } = c;
        return this.validateReplyParameters(u, h, g), {
          ...this.createMockScopeDispatchData(u, h, g)
        };
      }, s = Eo(this[Wn], this[Yn], o);
      return new ii(s);
    }
    const [e, A = "", n = {}] = [...arguments];
    this.validateReplyParameters(e, A, n);
    const i = this.createMockScopeDispatchData(e, A, n), a = Eo(this[Wn], this[Yn], i);
    return new ii(a);
  }
  /**
   * Mock an undici request with a defined error.
   */
  replyWithError(t) {
    if (typeof t > "u")
      throw new DA("error must be defined");
    const e = Eo(this[Wn], this[Yn], { error: t });
    return new ii(e);
  }
  /**
   * Set default reply headers on the interceptor for subsequent replies
   */
  defaultReplyHeaders(t) {
    if (typeof t > "u")
      throw new DA("headers must be defined");
    return this[Co] = t, this;
  }
  /**
   * Set default reply trailers on the interceptor for subsequent replies
   */
  defaultReplyTrailers(t) {
    if (typeof t > "u")
      throw new DA("trailers must be defined");
    return this[fo] = t, this;
  }
  /**
   * Set reply content length header for replies on the interceptor
   */
  replyContentLength() {
    return this[Qo] = !0, this;
  }
};
bi.MockInterceptor = dI;
bi.MockScope = ii;
const { promisify: pI } = L, yI = wi, { buildMockDispatch: mI } = ki, {
  kDispatches: cl,
  kMockAgent: ll,
  kClose: ul,
  kOriginalClose: hl,
  kOrigin: gl,
  kOriginalDispatch: wI,
  kConnected: Bo
} = In, { MockInterceptor: vI } = bi, El = Re, { InvalidArgumentError: kI } = ke;
let bI = class extends yI {
  constructor(t, e) {
    if (super(t, e), !e || !e.agent || typeof e.agent.dispatch != "function")
      throw new kI("Argument opts.agent must implement Agent");
    this[ll] = e.agent, this[gl] = t, this[cl] = [], this[Bo] = 1, this[wI] = this.dispatch, this[hl] = this.close.bind(this), this.dispatch = mI.call(this), this.close = this[ul];
  }
  get [El.kConnected]() {
    return this[Bo];
  }
  /**
   * Sets up the base interceptor for mocking replies from undici.
   */
  intercept(t) {
    return new vI(t, this[cl]);
  }
  async [ul]() {
    await pI(this[hl])(), this[Bo] = 0, this[ll][El.kClients].delete(this[gl]);
  }
};
var ag = bI;
const { promisify: TI } = L, FI = Qn, { buildMockDispatch: RI } = ki, {
  kDispatches: Cl,
  kMockAgent: fl,
  kClose: Ql,
  kOriginalClose: Bl,
  kOrigin: Il,
  kOriginalDispatch: DI,
  kConnected: Io
} = In, { MockInterceptor: NI } = bi, dl = Re, { InvalidArgumentError: SI } = ke;
let UI = class extends FI {
  constructor(t, e) {
    if (super(t, e), !e || !e.agent || typeof e.agent.dispatch != "function")
      throw new SI("Argument opts.agent must implement Agent");
    this[fl] = e.agent, this[Il] = t, this[Cl] = [], this[Io] = 1, this[DI] = this.dispatch, this[Bl] = this.close.bind(this), this.dispatch = RI.call(this), this.close = this[Ql];
  }
  get [dl.kConnected]() {
    return this[Io];
  }
  /**
   * Sets up the base interceptor for mocking replies from undici.
   */
  intercept(t) {
    return new NI(t, this[Cl]);
  }
  async [Ql]() {
    await TI(this[Bl])(), this[Io] = 0, this[fl][dl.kClients].delete(this[Il]);
  }
};
var og = UI;
const PI = {
  pronoun: "it",
  is: "is",
  was: "was",
  this: "this"
}, MI = {
  pronoun: "they",
  is: "are",
  was: "were",
  this: "these"
};
var LI = class {
  constructor(t, e) {
    this.singular = t, this.plural = e;
  }
  pluralize(t) {
    const e = t === 1, A = e ? PI : MI, n = e ? this.singular : this.plural;
    return { ...A, count: t, noun: n };
  }
};
const { Transform: HI } = L, { Console: GI } = L;
var WI = class {
  constructor({ disableColors: t } = {}) {
    this.transform = new HI({
      transform(e, A, n) {
        n(null, e);
      }
    }), this.logger = new GI({
      stdout: this.transform,
      inspectOptions: {
        colors: !t && !process.env.CI
      }
    });
  }
  format(t) {
    const e = t.map(
      ({ method: A, path: n, data: { statusCode: i }, persist: a, times: o, timesInvoked: s, origin: l }) => ({
        Method: A,
        Origin: l,
        Path: n,
        "Status code": i,
        Persistent: a ? "" : "",
        Invocations: s,
        Remaining: a ? 1 / 0 : o - s
      })
    );
    return this.logger.table(e), this.transform.read().toString();
  }
};
const { kClients: mt } = Re, YI = vi, {
  kAgent: po,
  kMockAgentSet: _n,
  kMockAgentGet: pl,
  kDispatches: yo,
  kIsMockActive: xn,
  kNetConnect: wt,
  kGetNetConnect: JI,
  kOptions: On,
  kFactory: qn
} = In, _I = ag, xI = og, { matchValue: OI, buildMockOptions: qI } = ki, { InvalidArgumentError: yl, UndiciError: jI } = ke, VI = Rs, $I = LI, XI = WI;
class ZI {
  constructor(t) {
    this.value = t;
  }
  deref() {
    return this.value;
  }
}
let KI = class extends VI {
  constructor(t) {
    if (super(t), this[wt] = !0, this[xn] = !0, t && t.agent && typeof t.agent.dispatch != "function")
      throw new yl("Argument opts.agent must implement Agent");
    const e = t && t.agent ? t.agent : new YI(t);
    this[po] = e, this[mt] = e[mt], this[On] = qI(t);
  }
  get(t) {
    let e = this[pl](t);
    return e || (e = this[qn](t), this[_n](t, e)), e;
  }
  dispatch(t, e) {
    return this.get(t.origin), this[po].dispatch(t, e);
  }
  async close() {
    await this[po].close(), this[mt].clear();
  }
  deactivate() {
    this[xn] = !1;
  }
  activate() {
    this[xn] = !0;
  }
  enableNetConnect(t) {
    if (typeof t == "string" || typeof t == "function" || t instanceof RegExp)
      Array.isArray(this[wt]) ? this[wt].push(t) : this[wt] = [t];
    else if (typeof t > "u")
      this[wt] = !0;
    else
      throw new yl("Unsupported matcher. Must be one of String|Function|RegExp.");
  }
  disableNetConnect() {
    this[wt] = !1;
  }
  // This is required to bypass issues caused by using global symbols - see:
  // https://github.com/nodejs/undici/issues/1447
  get isMockActive() {
    return this[xn];
  }
  [_n](t, e) {
    this[mt].set(t, new ZI(e));
  }
  [qn](t) {
    const e = Object.assign({ agent: this }, this[On]);
    return this[On] && this[On].connections === 1 ? new _I(t, e) : new xI(t, e);
  }
  [pl](t) {
    const e = this[mt].get(t);
    if (e)
      return e.deref();
    if (typeof t != "string") {
      const A = this[qn]("http://localhost:9999");
      return this[_n](t, A), A;
    }
    for (const [A, n] of Array.from(this[mt])) {
      const i = n.deref();
      if (i && typeof A != "string" && OI(A, t)) {
        const a = this[qn](t);
        return this[_n](t, a), a[yo] = i[yo], a;
      }
    }
  }
  [JI]() {
    return this[wt];
  }
  pendingInterceptors() {
    const t = this[mt];
    return Array.from(t.entries()).flatMap(([e, A]) => A.deref()[yo].map((n) => ({ ...n, origin: e }))).filter(({ pending: e }) => e);
  }
  assertNoPendingInterceptors({ pendingInterceptorsFormatter: t = new XI() } = {}) {
    const e = this.pendingInterceptors();
    if (e.length === 0)
      return;
    const A = new $I("interceptor", "interceptors").pluralize(e.length);
    throw new jI(`
${A.count} ${A.noun} ${A.is} pending:

${t.format(e)}
`.trim());
  }
};
var zI = KI;
const { kProxy: ed, kClose: Ad, kDestroy: td, kInterceptors: rd } = Re, { URL: ml } = L, wl = vi, nd = Qn, id = pi, { InvalidArgumentError: br, RequestAbortedError: ad } = ke, vl = yi, pr = Symbol("proxy agent"), jn = Symbol("proxy client"), yr = Symbol("proxy headers"), mo = Symbol("request tls settings"), od = Symbol("proxy tls settings"), kl = Symbol("connect endpoint function");
function sd(r) {
  return r === "https:" ? 443 : 80;
}
function cd(r) {
  if (typeof r == "string" && (r = { uri: r }), !r || !r.uri)
    throw new br("Proxy opts.uri is mandatory");
  return {
    uri: r.uri,
    protocol: r.protocol || "https"
  };
}
function ld(r, t) {
  return new nd(r, t);
}
let ud = class extends id {
  constructor(t) {
    if (super(t), this[ed] = cd(t), this[pr] = new wl(t), this[rd] = t.interceptors && t.interceptors.ProxyAgent && Array.isArray(t.interceptors.ProxyAgent) ? t.interceptors.ProxyAgent : [], typeof t == "string" && (t = { uri: t }), !t || !t.uri)
      throw new br("Proxy opts.uri is mandatory");
    const { clientFactory: e = ld } = t;
    if (typeof e != "function")
      throw new br("Proxy opts.clientFactory must be a function.");
    this[mo] = t.requestTls, this[od] = t.proxyTls, this[yr] = t.headers || {};
    const A = new ml(t.uri), { origin: n, port: i, host: a, username: o, password: s } = A;
    if (t.auth && t.token)
      throw new br("opts.auth cannot be used in combination with opts.token");
    t.auth ? this[yr]["proxy-authorization"] = `Basic ${t.auth}` : t.token ? this[yr]["proxy-authorization"] = t.token : o && s && (this[yr]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(o)}:${decodeURIComponent(s)}`).toString("base64")}`);
    const l = vl({ ...t.proxyTls });
    this[kl] = vl({ ...t.requestTls }), this[jn] = e(A, { connect: l }), this[pr] = new wl({
      ...t,
      connect: async (c, u) => {
        let h = c.host;
        c.port || (h += `:${sd(c.protocol)}`);
        try {
          const { socket: g, statusCode: d } = await this[jn].connect({
            origin: n,
            port: i,
            path: h,
            signal: c.signal,
            headers: {
              ...this[yr],
              host: a
            }
          });
          if (d !== 200 && (g.on("error", () => {
          }).destroy(), u(new ad(`Proxy response (${d}) !== 200 when HTTP Tunneling`))), c.protocol !== "https:") {
            u(null, g);
            return;
          }
          let I;
          this[mo] ? I = this[mo].servername : I = c.servername, this[kl]({ ...c, servername: I, httpSocket: g }, u);
        } catch (g) {
          u(g);
        }
      }
    });
  }
  dispatch(t, e) {
    const { host: A } = new ml(t.origin), n = hd(t.headers);
    return gd(n), this[pr].dispatch(
      {
        ...t,
        headers: {
          ...n,
          host: A
        }
      },
      e
    );
  }
  async [Ad]() {
    await this[pr].close(), await this[jn].close();
  }
  async [td]() {
    await this[pr].destroy(), await this[jn].destroy();
  }
};
function hd(r) {
  if (Array.isArray(r)) {
    const t = {};
    for (let e = 0; e < r.length; e += 2)
      t[r[e]] = r[e + 1];
    return t;
  }
  return r;
}
function gd(r) {
  if (r && Object.keys(r).find((e) => e.toLowerCase() === "proxy-authorization"))
    throw new br("Proxy-Authorization should be sent in ProxyAgent constructor");
}
var Ed = ud;
const vt = L, { kRetryHandlerDefaultRetry: bl } = Re, { RequestRetryError: Vn } = ke, { isDisturbed: Tl, parseHeaders: Cd, parseRangeHeader: Fl } = Ie;
function fd(r) {
  const t = Date.now();
  return new Date(r).getTime() - t;
}
let Qd = class sg {
  constructor(t, e) {
    const { retryOptions: A, ...n } = t, {
      // Retry scoped
      retry: i,
      maxRetries: a,
      maxTimeout: o,
      minTimeout: s,
      timeoutFactor: l,
      // Response scoped
      methods: c,
      errorCodes: u,
      retryAfter: h,
      statusCodes: g
    } = A ?? {};
    this.dispatch = e.dispatch, this.handler = e.handler, this.opts = n, this.abort = null, this.aborted = !1, this.retryOpts = {
      retry: i ?? sg[bl],
      retryAfter: h ?? !0,
      maxTimeout: o ?? 30 * 1e3,
      // 30s,
      timeout: s ?? 500,
      // .5s
      timeoutFactor: l ?? 2,
      maxRetries: a ?? 5,
      // What errors we should retry
      methods: c ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
      // Indicates which errors to retry
      statusCodes: g ?? [500, 502, 503, 504, 429],
      // List of errors to retry
      errorCodes: u ?? [
        "ECONNRESET",
        "ECONNREFUSED",
        "ENOTFOUND",
        "ENETDOWN",
        "ENETUNREACH",
        "EHOSTDOWN",
        "EHOSTUNREACH",
        "EPIPE"
      ]
    }, this.retryCount = 0, this.start = 0, this.end = null, this.etag = null, this.resume = null, this.handler.onConnect((d) => {
      this.aborted = !0, this.abort ? this.abort(d) : this.reason = d;
    });
  }
  onRequestSent() {
    this.handler.onRequestSent && this.handler.onRequestSent();
  }
  onUpgrade(t, e, A) {
    this.handler.onUpgrade && this.handler.onUpgrade(t, e, A);
  }
  onConnect(t) {
    this.aborted ? t(this.reason) : this.abort = t;
  }
  onBodySent(t) {
    if (this.handler.onBodySent)
      return this.handler.onBodySent(t);
  }
  static [bl](t, { state: e, opts: A }, n) {
    const { statusCode: i, code: a, headers: o } = t, { method: s, retryOptions: l } = A, {
      maxRetries: c,
      timeout: u,
      maxTimeout: h,
      timeoutFactor: g,
      statusCodes: d,
      errorCodes: I,
      methods: y
    } = l;
    let { counter: Q, currentTimeout: E } = e;
    if (E = E != null && E > 0 ? E : u, a && a !== "UND_ERR_REQ_RETRY" && a !== "UND_ERR_SOCKET" && !I.includes(a)) {
      n(t);
      return;
    }
    if (Array.isArray(y) && !y.includes(s)) {
      n(t);
      return;
    }
    if (i != null && Array.isArray(d) && !d.includes(i)) {
      n(t);
      return;
    }
    if (Q > c) {
      n(t);
      return;
    }
    let B = o != null && o["retry-after"];
    B && (B = Number(B), B = isNaN(B) ? fd(B) : B * 1e3);
    const w = B > 0 ? Math.min(B, h) : Math.min(E * g ** Q, h);
    e.currentTimeout = w, setTimeout(() => n(null), w);
  }
  onHeaders(t, e, A, n) {
    const i = Cd(e);
    if (this.retryCount += 1, t >= 300)
      return this.abort(
        new Vn("Request failed", t, {
          headers: i,
          count: this.retryCount
        })
      ), !1;
    if (this.resume != null) {
      if (this.resume = null, t !== 206)
        return !0;
      const o = Fl(i["content-range"]);
      if (!o)
        return this.abort(
          new Vn("Content-Range mismatch", t, {
            headers: i,
            count: this.retryCount
          })
        ), !1;
      if (this.etag != null && this.etag !== i.etag)
        return this.abort(
          new Vn("ETag mismatch", t, {
            headers: i,
            count: this.retryCount
          })
        ), !1;
      const { start: s, size: l, end: c = l } = o;
      return vt(this.start === s, "content-range mismatch"), vt(this.end == null || this.end === c, "content-range mismatch"), this.resume = A, !0;
    }
    if (this.end == null) {
      if (t === 206) {
        const o = Fl(i["content-range"]);
        if (o == null)
          return this.handler.onHeaders(
            t,
            e,
            A,
            n
          );
        const { start: s, size: l, end: c = l } = o;
        vt(
          s != null && Number.isFinite(s) && this.start !== s,
          "content-range mismatch"
        ), vt(Number.isFinite(s)), vt(
          c != null && Number.isFinite(c) && this.end !== c,
          "invalid content-length"
        ), this.start = s, this.end = c;
      }
      if (this.end == null) {
        const o = i["content-length"];
        this.end = o != null ? Number(o) : null;
      }
      return vt(Number.isFinite(this.start)), vt(
        this.end == null || Number.isFinite(this.end),
        "invalid content-length"
      ), this.resume = A, this.etag = i.etag != null ? i.etag : null, this.handler.onHeaders(
        t,
        e,
        A,
        n
      );
    }
    const a = new Vn("Request failed", t, {
      headers: i,
      count: this.retryCount
    });
    return this.abort(a), !1;
  }
  onData(t) {
    return this.start += t.length, this.handler.onData(t);
  }
  onComplete(t) {
    return this.retryCount = 0, this.handler.onComplete(t);
  }
  onError(t) {
    if (this.aborted || Tl(this.opts.body))
      return this.handler.onError(t);
    this.retryOpts.retry(
      t,
      {
        state: { counter: this.retryCount++, currentTimeout: this.retryAfter },
        opts: { retryOptions: this.retryOpts, ...this.opts }
      },
      e.bind(this)
    );
    function e(A) {
      if (A != null || this.aborted || Tl(this.opts.body))
        return this.handler.onError(A);
      this.start !== 0 && (this.opts = {
        ...this.opts,
        headers: {
          ...this.opts.headers,
          range: `bytes=${this.start}-${this.end ?? ""}`
        }
      });
      try {
        this.dispatch(this.opts, this);
      } catch (n) {
        this.handler.onError(n);
      }
    }
  }
};
var Bd = Qd;
const cg = Symbol.for("undici.globalDispatcher.1"), { InvalidArgumentError: Id } = ke, dd = vi;
ug() === void 0 && lg(new dd());
function lg(r) {
  if (!r || typeof r.dispatch != "function")
    throw new Id("Argument agent must implement Agent");
  Object.defineProperty(globalThis, cg, {
    value: r,
    writable: !0,
    enumerable: !1,
    configurable: !1
  });
}
function ug() {
  return globalThis[cg];
}
var dn = {
  setGlobalDispatcher: lg,
  getGlobalDispatcher: ug
}, pd = class {
  constructor(t) {
    this.handler = t;
  }
  onConnect(...t) {
    return this.handler.onConnect(...t);
  }
  onError(...t) {
    return this.handler.onError(...t);
  }
  onUpgrade(...t) {
    return this.handler.onUpgrade(...t);
  }
  onHeaders(...t) {
    return this.handler.onHeaders(...t);
  }
  onData(...t) {
    return this.handler.onData(...t);
  }
  onComplete(...t) {
    return this.handler.onComplete(...t);
  }
  onBodySent(...t) {
    return this.handler.onBodySent(...t);
  }
}, wo, Rl;
function sr() {
  if (Rl)
    return wo;
  Rl = 1;
  const { kHeadersList: r, kConstruct: t } = Re, { kGuard: e } = Ct(), { kEnumerableProperty: A } = Ie, {
    makeIterator: n,
    isValidHeaderName: i,
    isValidHeaderValue: a
  } = NA(), { webidl: o } = QA(), s = L, l = Symbol("headers map"), c = Symbol("headers map sorted");
  function u(Q) {
    return Q === 10 || Q === 13 || Q === 9 || Q === 32;
  }
  function h(Q) {
    let E = 0, B = Q.length;
    for (; B > E && u(Q.charCodeAt(B - 1)); )
      --B;
    for (; B > E && u(Q.charCodeAt(E)); )
      ++E;
    return E === 0 && B === Q.length ? Q : Q.substring(E, B);
  }
  function g(Q, E) {
    if (Array.isArray(E))
      for (let B = 0; B < E.length; ++B) {
        const w = E[B];
        if (w.length !== 2)
          throw o.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${w.length}.`
          });
        d(Q, w[0], w[1]);
      }
    else if (typeof E == "object" && E !== null) {
      const B = Object.keys(E);
      for (let w = 0; w < B.length; ++w)
        d(Q, B[w], E[B[w]]);
    } else
      throw o.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
      });
  }
  function d(Q, E, B) {
    if (B = h(B), i(E)) {
      if (!a(B))
        throw o.errors.invalidArgument({
          prefix: "Headers.append",
          value: B,
          type: "header value"
        });
    } else
      throw o.errors.invalidArgument({
        prefix: "Headers.append",
        value: E,
        type: "header name"
      });
    if (Q[e] === "immutable")
      throw new TypeError("immutable");
    return Q[e], Q[r].append(E, B);
  }
  class I {
    constructor(E) {
      /** @type {[string, string][]|null} */
      Wt(this, "cookies", null);
      E instanceof I ? (this[l] = new Map(E[l]), this[c] = E[c], this.cookies = E.cookies === null ? null : [...E.cookies]) : (this[l] = new Map(E), this[c] = null);
    }
    // https://fetch.spec.whatwg.org/#header-list-contains
    contains(E) {
      return E = E.toLowerCase(), this[l].has(E);
    }
    clear() {
      this[l].clear(), this[c] = null, this.cookies = null;
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-append
    append(E, B) {
      this[c] = null;
      const w = E.toLowerCase(), C = this[l].get(w);
      if (C) {
        const f = w === "cookie" ? "; " : ", ";
        this[l].set(w, {
          name: C.name,
          value: `${C.value}${f}${B}`
        });
      } else
        this[l].set(w, { name: E, value: B });
      w === "set-cookie" && (this.cookies ?? (this.cookies = []), this.cookies.push(B));
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-set
    set(E, B) {
      this[c] = null;
      const w = E.toLowerCase();
      w === "set-cookie" && (this.cookies = [B]), this[l].set(w, { name: E, value: B });
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-delete
    delete(E) {
      this[c] = null, E = E.toLowerCase(), E === "set-cookie" && (this.cookies = null), this[l].delete(E);
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-get
    get(E) {
      const B = this[l].get(E.toLowerCase());
      return B === void 0 ? null : B.value;
    }
    *[Symbol.iterator]() {
      for (const [E, { value: B }] of this[l])
        yield [E, B];
    }
    get entries() {
      const E = {};
      if (this[l].size)
        for (const { name: B, value: w } of this[l].values())
          E[B] = w;
      return E;
    }
  }
  class y {
    constructor(E = void 0) {
      E !== t && (this[r] = new I(), this[e] = "none", E !== void 0 && (E = o.converters.HeadersInit(E), g(this, E)));
    }
    // https://fetch.spec.whatwg.org/#dom-headers-append
    append(E, B) {
      return o.brandCheck(this, y), o.argumentLengthCheck(arguments, 2, { header: "Headers.append" }), E = o.converters.ByteString(E), B = o.converters.ByteString(B), d(this, E, B);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-delete
    delete(E) {
      if (o.brandCheck(this, y), o.argumentLengthCheck(arguments, 1, { header: "Headers.delete" }), E = o.converters.ByteString(E), !i(E))
        throw o.errors.invalidArgument({
          prefix: "Headers.delete",
          value: E,
          type: "header name"
        });
      if (this[e] === "immutable")
        throw new TypeError("immutable");
      this[e], this[r].contains(E) && this[r].delete(E);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-get
    get(E) {
      if (o.brandCheck(this, y), o.argumentLengthCheck(arguments, 1, { header: "Headers.get" }), E = o.converters.ByteString(E), !i(E))
        throw o.errors.invalidArgument({
          prefix: "Headers.get",
          value: E,
          type: "header name"
        });
      return this[r].get(E);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-has
    has(E) {
      if (o.brandCheck(this, y), o.argumentLengthCheck(arguments, 1, { header: "Headers.has" }), E = o.converters.ByteString(E), !i(E))
        throw o.errors.invalidArgument({
          prefix: "Headers.has",
          value: E,
          type: "header name"
        });
      return this[r].contains(E);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-set
    set(E, B) {
      if (o.brandCheck(this, y), o.argumentLengthCheck(arguments, 2, { header: "Headers.set" }), E = o.converters.ByteString(E), B = o.converters.ByteString(B), B = h(B), i(E)) {
        if (!a(B))
          throw o.errors.invalidArgument({
            prefix: "Headers.set",
            value: B,
            type: "header value"
          });
      } else
        throw o.errors.invalidArgument({
          prefix: "Headers.set",
          value: E,
          type: "header name"
        });
      if (this[e] === "immutable")
        throw new TypeError("immutable");
      this[e], this[r].set(E, B);
    }
    // https://fetch.spec.whatwg.org/#dom-headers-getsetcookie
    getSetCookie() {
      o.brandCheck(this, y);
      const E = this[r].cookies;
      return E ? [...E] : [];
    }
    // https://fetch.spec.whatwg.org/#concept-header-list-sort-and-combine
    get [c]() {
      if (this[r][c])
        return this[r][c];
      const E = [], B = [...this[r]].sort((C, f) => C[0] < f[0] ? -1 : 1), w = this[r].cookies;
      for (let C = 0; C < B.length; ++C) {
        const [f, p] = B[C];
        if (f === "set-cookie")
          for (let m = 0; m < w.length; ++m)
            E.push([f, w[m]]);
        else
          s(p !== null), E.push([f, p]);
      }
      return this[r][c] = E, E;
    }
    keys() {
      if (o.brandCheck(this, y), this[e] === "immutable") {
        const E = this[c];
        return n(
          () => E,
          "Headers",
          "key"
        );
      }
      return n(
        () => [...this[c].values()],
        "Headers",
        "key"
      );
    }
    values() {
      if (o.brandCheck(this, y), this[e] === "immutable") {
        const E = this[c];
        return n(
          () => E,
          "Headers",
          "value"
        );
      }
      return n(
        () => [...this[c].values()],
        "Headers",
        "value"
      );
    }
    entries() {
      if (o.brandCheck(this, y), this[e] === "immutable") {
        const E = this[c];
        return n(
          () => E,
          "Headers",
          "key+value"
        );
      }
      return n(
        () => [...this[c].values()],
        "Headers",
        "key+value"
      );
    }
    /**
     * @param {(value: string, key: string, self: Headers) => void} callbackFn
     * @param {unknown} thisArg
     */
    forEach(E, B = globalThis) {
      if (o.brandCheck(this, y), o.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" }), typeof E != "function")
        throw new TypeError(
          "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
        );
      for (const [w, C] of this)
        E.apply(B, [C, w, this]);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return o.brandCheck(this, y), this[r];
    }
  }
  return y.prototype[Symbol.iterator] = y.prototype.entries, Object.defineProperties(y.prototype, {
    append: A,
    delete: A,
    get: A,
    has: A,
    set: A,
    getSetCookie: A,
    keys: A,
    values: A,
    entries: A,
    forEach: A,
    [Symbol.iterator]: { enumerable: !1 },
    [Symbol.toStringTag]: {
      value: "Headers",
      configurable: !0
    }
  }), o.converters.HeadersInit = function(Q) {
    if (o.util.Type(Q) === "Object")
      return Q[Symbol.iterator] ? o.converters["sequence<sequence<ByteString>>"](Q) : o.converters["record<ByteString, ByteString>"](Q);
    throw o.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"]
    });
  }, wo = {
    fill: g,
    Headers: y,
    HeadersList: I
  }, wo;
}
var vo, Dl;
function Ps() {
  if (Dl)
    return vo;
  Dl = 1;
  const { Headers: r, HeadersList: t, fill: e } = sr(), { extractBody: A, cloneBody: n, mixinBody: i } = di(), a = Ie, { kEnumerableProperty: o } = a, {
    isValidReasonPhrase: s,
    isCancelled: l,
    isAborted: c,
    isBlobLike: u,
    serializeJavascriptValueToJSONString: h,
    isErrorLike: g,
    isomorphicEncode: d
  } = NA(), {
    redirectStatusSet: I,
    nullBodyStatus: y,
    DOMException: Q
  } = Mt(), { kState: E, kHeaders: B, kGuard: w, kRealm: C } = Ct(), { webidl: f } = QA(), { FormData: p } = Fs(), { getGlobalOrigin: m } = fn(), { URLSerializer: R } = JA(), { kHeadersList: P, kConstruct: N } = Re, $ = L, { types: V } = L, ne = globalThis.ReadableStream || L.ReadableStream, _ = new TextEncoder("utf-8");
  class X {
    // Creates network error Response.
    static error() {
      const S = { settingsObject: {} }, U = new X();
      return U[E] = Z(), U[C] = S, U[B][P] = U[E].headersList, U[B][w] = "immutable", U[B][C] = S, U;
    }
    // https://fetch.spec.whatwg.org/#dom-response-json
    static json(S, U = {}) {
      f.argumentLengthCheck(arguments, 1, { header: "Response.json" }), U !== null && (U = f.converters.ResponseInit(U));
      const Y = _.encode(
        h(S)
      ), O = A(Y), j = { settingsObject: {} }, H = new X();
      return H[C] = j, H[B][w] = "response", H[B][C] = j, F(H, U, { body: O[0], type: "application/json" }), H;
    }
    // Creates a redirect Response that redirects to url with status status.
    static redirect(S, U = 302) {
      const Y = { settingsObject: {} };
      f.argumentLengthCheck(arguments, 1, { header: "Response.redirect" }), S = f.converters.USVString(S), U = f.converters["unsigned short"](U);
      let O;
      try {
        O = new URL(S, m());
      } catch (ie) {
        throw Object.assign(new TypeError("Failed to parse URL from " + S), {
          cause: ie
        });
      }
      if (!I.has(U))
        throw new RangeError("Invalid status code " + U);
      const j = new X();
      j[C] = Y, j[B][w] = "immutable", j[B][C] = Y, j[E].status = U;
      const H = d(R(O));
      return j[E].headersList.append("location", H), j;
    }
    // https://fetch.spec.whatwg.org/#dom-response
    constructor(S = null, U = {}) {
      S !== null && (S = f.converters.BodyInit(S)), U = f.converters.ResponseInit(U), this[C] = { settingsObject: {} }, this[E] = ee({}), this[B] = new r(N), this[B][w] = "response", this[B][P] = this[E].headersList, this[B][C] = this[C];
      let Y = null;
      if (S != null) {
        const [O, j] = A(S);
        Y = { body: O, type: j };
      }
      F(this, U, Y);
    }
    // Returns responses type, e.g., "cors".
    get type() {
      return f.brandCheck(this, X), this[E].type;
    }
    // Returns responses URL, if it has one; otherwise the empty string.
    get url() {
      f.brandCheck(this, X);
      const S = this[E].urlList, U = S[S.length - 1] ?? null;
      return U === null ? "" : R(U, !0);
    }
    // Returns whether response was obtained through a redirect.
    get redirected() {
      return f.brandCheck(this, X), this[E].urlList.length > 1;
    }
    // Returns responses status.
    get status() {
      return f.brandCheck(this, X), this[E].status;
    }
    // Returns whether responses status is an ok status.
    get ok() {
      return f.brandCheck(this, X), this[E].status >= 200 && this[E].status <= 299;
    }
    // Returns responses status message.
    get statusText() {
      return f.brandCheck(this, X), this[E].statusText;
    }
    // Returns responses headers as Headers.
    get headers() {
      return f.brandCheck(this, X), this[B];
    }
    get body() {
      return f.brandCheck(this, X), this[E].body ? this[E].body.stream : null;
    }
    get bodyUsed() {
      return f.brandCheck(this, X), !!this[E].body && a.isDisturbed(this[E].body.stream);
    }
    // Returns a clone of response.
    clone() {
      if (f.brandCheck(this, X), this.bodyUsed || this.body && this.body.locked)
        throw f.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed."
        });
      const S = te(this[E]), U = new X();
      return U[E] = S, U[C] = this[C], U[B][P] = S.headersList, U[B][w] = this[B][w], U[B][C] = this[B][C], U;
    }
  }
  i(X), Object.defineProperties(X.prototype, {
    type: o,
    url: o,
    status: o,
    ok: o,
    redirected: o,
    statusText: o,
    headers: o,
    clone: o,
    body: o,
    bodyUsed: o,
    [Symbol.toStringTag]: {
      value: "Response",
      configurable: !0
    }
  }), Object.defineProperties(X, {
    json: o,
    redirect: o,
    error: o
  });
  function te(T) {
    if (T.internalResponse)
      return W(
        te(T.internalResponse),
        T.type
      );
    const S = ee({ ...T, body: null });
    return T.body != null && (S.body = n(T.body)), S;
  }
  function ee(T) {
    return {
      aborted: !1,
      rangeRequested: !1,
      timingAllowPassed: !1,
      requestIncludesCredentials: !1,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...T,
      headersList: T.headersList ? new t(T.headersList) : new t(),
      urlList: T.urlList ? [...T.urlList] : []
    };
  }
  function Z(T) {
    const S = g(T);
    return ee({
      type: "error",
      status: 0,
      error: S ? T : new Error(T && String(T)),
      aborted: T && T.name === "AbortError"
    });
  }
  function b(T, S) {
    return S = {
      internalResponse: T,
      ...S
    }, new Proxy(T, {
      get(U, Y) {
        return Y in S ? S[Y] : U[Y];
      },
      set(U, Y, O) {
        return $(!(Y in S)), U[Y] = O, !0;
      }
    });
  }
  function W(T, S) {
    if (S === "basic")
      return b(T, {
        type: "basic",
        headersList: T.headersList
      });
    if (S === "cors")
      return b(T, {
        type: "cors",
        headersList: T.headersList
      });
    if (S === "opaque")
      return b(T, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null
      });
    if (S === "opaqueredirect")
      return b(T, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null
      });
    $(!1);
  }
  function v(T, S = null) {
    return $(l(T)), c(T) ? Z(Object.assign(new Q("The operation was aborted.", "AbortError"), { cause: S })) : Z(Object.assign(new Q("Request was cancelled."), { cause: S }));
  }
  function F(T, S, U) {
    if (S.status !== null && (S.status < 200 || S.status > 599))
      throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
    if ("statusText" in S && S.statusText != null && !s(String(S.statusText)))
      throw new TypeError("Invalid statusText");
    if ("status" in S && S.status != null && (T[E].status = S.status), "statusText" in S && S.statusText != null && (T[E].statusText = S.statusText), "headers" in S && S.headers != null && e(T[B], S.headers), U) {
      if (y.includes(T.status))
        throw f.errors.exception({
          header: "Response constructor",
          message: "Invalid response status code " + T.status
        });
      T[E].body = U.body, U.type != null && !T[E].headersList.contains("Content-Type") && T[E].headersList.append("content-type", U.type);
    }
  }
  return f.converters.ReadableStream = f.interfaceConverter(
    ne
  ), f.converters.FormData = f.interfaceConverter(
    p
  ), f.converters.URLSearchParams = f.interfaceConverter(
    URLSearchParams
  ), f.converters.XMLHttpRequestBodyInit = function(T) {
    return typeof T == "string" ? f.converters.USVString(T) : u(T) ? f.converters.Blob(T, { strict: !1 }) : V.isArrayBuffer(T) || V.isTypedArray(T) || V.isDataView(T) ? f.converters.BufferSource(T) : a.isFormDataLike(T) ? f.converters.FormData(T, { strict: !1 }) : T instanceof URLSearchParams ? f.converters.URLSearchParams(T) : f.converters.DOMString(T);
  }, f.converters.BodyInit = function(T) {
    return T instanceof ne ? f.converters.ReadableStream(T) : T != null && T[Symbol.asyncIterator] ? T : f.converters.XMLHttpRequestBodyInit(T);
  }, f.converters.ResponseInit = f.dictionaryConverter([
    {
      key: "status",
      converter: f.converters["unsigned short"],
      defaultValue: 200
    },
    {
      key: "statusText",
      converter: f.converters.ByteString,
      defaultValue: ""
    },
    {
      key: "headers",
      converter: f.converters.HeadersInit
    }
  ]), vo = {
    makeNetworkError: Z,
    makeResponse: ee,
    makeAppropriateNetworkError: v,
    filterResponse: W,
    Response: X,
    cloneResponse: te
  }, vo;
}
var ko, Nl;
function Ti() {
  if (Nl)
    return ko;
  Nl = 1;
  const { extractBody: r, mixinBody: t, cloneBody: e } = di(), { Headers: A, fill: n, HeadersList: i } = sr(), { FinalizationRegistry: a } = Mh(), o = Ie, {
    isValidHTTPToken: s,
    sameOrigin: l,
    normalizeMethod: c,
    makePolicyContainer: u,
    normalizeMethodRecord: h
  } = NA(), {
    forbiddenMethodsSet: g,
    corsSafeListedMethodsSet: d,
    referrerPolicy: I,
    requestRedirect: y,
    requestMode: Q,
    requestCredentials: E,
    requestCache: B,
    requestDuplex: w
  } = Mt(), { kEnumerableProperty: C } = o, { kHeaders: f, kSignal: p, kState: m, kGuard: R, kRealm: P } = Ct(), { webidl: N } = QA(), { getGlobalOrigin: $ } = fn(), { URLSerializer: V } = JA(), { kHeadersList: ne, kConstruct: _ } = Re, X = L, { getMaxListeners: te, setMaxListeners: ee, getEventListeners: Z, defaultMaxListeners: b } = L;
  let W = globalThis.TransformStream;
  const v = Symbol("abortController"), F = new a(({ signal: Y, abort: O }) => {
    Y.removeEventListener("abort", O);
  });
  class T {
    // https://fetch.spec.whatwg.org/#dom-request
    constructor(O, j = {}) {
      var ft, Ht;
      if (O === _)
        return;
      N.argumentLengthCheck(arguments, 1, { header: "Request constructor" }), O = N.converters.RequestInfo(O), j = N.converters.RequestInit(j), this[P] = {
        settingsObject: {
          baseUrl: $(),
          get origin() {
            var ue;
            return (ue = this.baseUrl) == null ? void 0 : ue.origin;
          },
          policyContainer: u()
        }
      };
      let H = null, ie = null;
      const ye = this[P].settingsObject.baseUrl;
      let Ee = null;
      if (typeof O == "string") {
        let ue;
        try {
          ue = new URL(O, ye);
        } catch (Ne) {
          throw new TypeError("Failed to parse URL from " + O, { cause: Ne });
        }
        if (ue.username || ue.password)
          throw new TypeError(
            "Request cannot be constructed from a URL that includes credentials: " + O
          );
        H = S({ urlList: [ue] }), ie = "cors";
      } else
        X(O instanceof T), H = O[m], Ee = O[p];
      const He = this[P].settingsObject.origin;
      let be = "client";
      if (((Ht = (ft = H.window) == null ? void 0 : ft.constructor) == null ? void 0 : Ht.name) === "EnvironmentSettingsObject" && l(H.window, He) && (be = H.window), j.window != null)
        throw new TypeError(`'window' option '${be}' must be null`);
      "window" in j && (be = "no-window"), H = S({
        // URL requests URL.
        // undici implementation note: this is set as the first item in request's urlList in makeRequest
        // method requests method.
        method: H.method,
        // header list A copy of requests header list.
        // undici implementation note: headersList is cloned in makeRequest
        headersList: H.headersList,
        // unsafe-request flag Set.
        unsafeRequest: H.unsafeRequest,
        // client Thiss relevant settings object.
        client: this[P].settingsObject,
        // window window.
        window: be,
        // priority requests priority.
        priority: H.priority,
        // origin requests origin. The propagation of the origin is only significant for navigation requests
        // being handled by a service worker. In this scenario a request can have an origin that is different
        // from the current client.
        origin: H.origin,
        // referrer requests referrer.
        referrer: H.referrer,
        // referrer policy requests referrer policy.
        referrerPolicy: H.referrerPolicy,
        // mode requests mode.
        mode: H.mode,
        // credentials mode requests credentials mode.
        credentials: H.credentials,
        // cache mode requests cache mode.
        cache: H.cache,
        // redirect mode requests redirect mode.
        redirect: H.redirect,
        // integrity metadata requests integrity metadata.
        integrity: H.integrity,
        // keepalive requests keepalive.
        keepalive: H.keepalive,
        // reload-navigation flag requests reload-navigation flag.
        reloadNavigation: H.reloadNavigation,
        // history-navigation flag requests history-navigation flag.
        historyNavigation: H.historyNavigation,
        // URL list A clone of requests URL list.
        urlList: [...H.urlList]
      });
      const De = Object.keys(j).length !== 0;
      if (De && (H.mode === "navigate" && (H.mode = "same-origin"), H.reloadNavigation = !1, H.historyNavigation = !1, H.origin = "client", H.referrer = "client", H.referrerPolicy = "", H.url = H.urlList[H.urlList.length - 1], H.urlList = [H.url]), j.referrer !== void 0) {
        const ue = j.referrer;
        if (ue === "")
          H.referrer = "no-referrer";
        else {
          let Ne;
          try {
            Ne = new URL(ue, ye);
          } catch (SA) {
            throw new TypeError(`Referrer "${ue}" is not a valid URL.`, { cause: SA });
          }
          Ne.protocol === "about:" && Ne.hostname === "client" || He && !l(Ne, this[P].settingsObject.baseUrl) ? H.referrer = "client" : H.referrer = Ne;
        }
      }
      j.referrerPolicy !== void 0 && (H.referrerPolicy = j.referrerPolicy);
      let Ge;
      if (j.mode !== void 0 ? Ge = j.mode : Ge = ie, Ge === "navigate")
        throw N.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate."
        });
      if (Ge != null && (H.mode = Ge), j.credentials !== void 0 && (H.credentials = j.credentials), j.cache !== void 0 && (H.cache = j.cache), H.cache === "only-if-cached" && H.mode !== "same-origin")
        throw new TypeError(
          "'only-if-cached' can be set only with 'same-origin' mode"
        );
      if (j.redirect !== void 0 && (H.redirect = j.redirect), j.integrity != null && (H.integrity = String(j.integrity)), j.keepalive !== void 0 && (H.keepalive = !!j.keepalive), j.method !== void 0) {
        let ue = j.method;
        if (!s(ue))
          throw new TypeError(`'${ue}' is not a valid HTTP method.`);
        if (g.has(ue.toUpperCase()))
          throw new TypeError(`'${ue}' HTTP method is unsupported.`);
        ue = h[ue] ?? c(ue), H.method = ue;
      }
      j.signal !== void 0 && (Ee = j.signal), this[m] = H;
      const Qe = new AbortController();
      if (this[p] = Qe.signal, this[p][P] = this[P], Ee != null) {
        if (!Ee || typeof Ee.aborted != "boolean" || typeof Ee.addEventListener != "function")
          throw new TypeError(
            "Failed to construct 'Request': member signal is not of type AbortSignal."
          );
        if (Ee.aborted)
          Qe.abort(Ee.reason);
        else {
          this[v] = Qe;
          const ue = new WeakRef(Qe), Ne = function() {
            const SA = ue.deref();
            SA !== void 0 && SA.abort(this.reason);
          };
          try {
            (typeof te == "function" && te(Ee) === b || Z(Ee, "abort").length >= b) && ee(100, Ee);
          } catch {
          }
          o.addAbortListener(Ee, Ne), F.register(Qe, { signal: Ee, abort: Ne });
        }
      }
      if (this[f] = new A(_), this[f][ne] = H.headersList, this[f][R] = "request", this[f][P] = this[P], Ge === "no-cors") {
        if (!d.has(H.method))
          throw new TypeError(
            `'${H.method} is unsupported in no-cors mode.`
          );
        this[f][R] = "request-no-cors";
      }
      if (De) {
        const ue = this[f][ne], Ne = j.headers !== void 0 ? j.headers : new i(ue);
        if (ue.clear(), Ne instanceof i) {
          for (const [SA, k] of Ne)
            ue.append(SA, k);
          ue.cookies = Ne.cookies;
        } else
          n(this[f], Ne);
      }
      const Ce = O instanceof T ? O[m].body : null;
      if ((j.body != null || Ce != null) && (H.method === "GET" || H.method === "HEAD"))
        throw new TypeError("Request with GET/HEAD method cannot have body.");
      let pe = null;
      if (j.body != null) {
        const [ue, Ne] = r(
          j.body,
          H.keepalive
        );
        pe = ue, Ne && !this[f][ne].contains("content-type") && this[f].append("content-type", Ne);
      }
      const sA = pe ?? Ce;
      if (sA != null && sA.source == null) {
        if (pe != null && j.duplex == null)
          throw new TypeError("RequestInit: duplex option is required when sending a body.");
        if (H.mode !== "same-origin" && H.mode !== "cors")
          throw new TypeError(
            'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
          );
        H.useCORSPreflightFlag = !0;
      }
      let Lt = sA;
      if (pe == null && Ce != null) {
        if (o.isDisturbed(Ce.stream) || Ce.stream.locked)
          throw new TypeError(
            "Cannot construct a Request with a Request object that has already been used."
          );
        W || (W = L.TransformStream);
        const ue = new W();
        Ce.stream.pipeThrough(ue), Lt = {
          source: Ce.source,
          length: Ce.length,
          stream: ue.readable
        };
      }
      this[m].body = Lt;
    }
    // Returns requests HTTP method, which is "GET" by default.
    get method() {
      return N.brandCheck(this, T), this[m].method;
    }
    // Returns the URL of request as a string.
    get url() {
      return N.brandCheck(this, T), V(this[m].url);
    }
    // Returns a Headers object consisting of the headers associated with request.
    // Note that headers added in the network layer by the user agent will not
    // be accounted for in this object, e.g., the "Host" header.
    get headers() {
      return N.brandCheck(this, T), this[f];
    }
    // Returns the kind of resource requested by request, e.g., "document"
    // or "script".
    get destination() {
      return N.brandCheck(this, T), this[m].destination;
    }
    // Returns the referrer of request. Its value can be a same-origin URL if
    // explicitly set in init, the empty string to indicate no referrer, and
    // "about:client" when defaulting to the globals default. This is used
    // during fetching to determine the value of the `Referer` header of the
    // request being made.
    get referrer() {
      return N.brandCheck(this, T), this[m].referrer === "no-referrer" ? "" : this[m].referrer === "client" ? "about:client" : this[m].referrer.toString();
    }
    // Returns the referrer policy associated with request.
    // This is used during fetching to compute the value of the requests
    // referrer.
    get referrerPolicy() {
      return N.brandCheck(this, T), this[m].referrerPolicy;
    }
    // Returns the mode associated with request, which is a string indicating
    // whether the request will use CORS, or will be restricted to same-origin
    // URLs.
    get mode() {
      return N.brandCheck(this, T), this[m].mode;
    }
    // Returns the credentials mode associated with request,
    // which is a string indicating whether credentials will be sent with the
    // request always, never, or only when sent to a same-origin URL.
    get credentials() {
      return this[m].credentials;
    }
    // Returns the cache mode associated with request,
    // which is a string indicating how the request will
    // interact with the browsers cache when fetching.
    get cache() {
      return N.brandCheck(this, T), this[m].cache;
    }
    // Returns the redirect mode associated with request,
    // which is a string indicating how redirects for the
    // request will be handled during fetching. A request
    // will follow redirects by default.
    get redirect() {
      return N.brandCheck(this, T), this[m].redirect;
    }
    // Returns requests subresource integrity metadata, which is a
    // cryptographic hash of the resource being fetched. Its value
    // consists of multiple hashes separated by whitespace. [SRI]
    get integrity() {
      return N.brandCheck(this, T), this[m].integrity;
    }
    // Returns a boolean indicating whether or not request can outlive the
    // global in which it was created.
    get keepalive() {
      return N.brandCheck(this, T), this[m].keepalive;
    }
    // Returns a boolean indicating whether or not request is for a reload
    // navigation.
    get isReloadNavigation() {
      return N.brandCheck(this, T), this[m].reloadNavigation;
    }
    // Returns a boolean indicating whether or not request is for a history
    // navigation (a.k.a. back-foward navigation).
    get isHistoryNavigation() {
      return N.brandCheck(this, T), this[m].historyNavigation;
    }
    // Returns the signal associated with request, which is an AbortSignal
    // object indicating whether or not request has been aborted, and its
    // abort event handler.
    get signal() {
      return N.brandCheck(this, T), this[p];
    }
    get body() {
      return N.brandCheck(this, T), this[m].body ? this[m].body.stream : null;
    }
    get bodyUsed() {
      return N.brandCheck(this, T), !!this[m].body && o.isDisturbed(this[m].body.stream);
    }
    get duplex() {
      return N.brandCheck(this, T), "half";
    }
    // Returns a clone of request.
    clone() {
      var ie;
      if (N.brandCheck(this, T), this.bodyUsed || (ie = this.body) != null && ie.locked)
        throw new TypeError("unusable");
      const O = U(this[m]), j = new T(_);
      j[m] = O, j[P] = this[P], j[f] = new A(_), j[f][ne] = O.headersList, j[f][R] = this[f][R], j[f][P] = this[f][P];
      const H = new AbortController();
      return this.signal.aborted ? H.abort(this.signal.reason) : o.addAbortListener(
        this.signal,
        () => {
          H.abort(this.signal.reason);
        }
      ), j[p] = H.signal, j;
    }
  }
  t(T);
  function S(Y) {
    const O = {
      method: "GET",
      localURLsOnly: !1,
      unsafeRequest: !1,
      body: null,
      client: null,
      reservedClient: null,
      replacesClientId: "",
      window: "client",
      keepalive: !1,
      serviceWorkers: "all",
      initiator: "",
      destination: "",
      priority: null,
      origin: "client",
      policyContainer: "client",
      referrer: "client",
      referrerPolicy: "",
      mode: "no-cors",
      useCORSPreflightFlag: !1,
      credentials: "same-origin",
      useCredentials: !1,
      cache: "default",
      redirect: "follow",
      integrity: "",
      cryptoGraphicsNonceMetadata: "",
      parserMetadata: "",
      reloadNavigation: !1,
      historyNavigation: !1,
      userActivation: !1,
      taintedOrigin: !1,
      redirectCount: 0,
      responseTainting: "basic",
      preventNoCacheCacheControlHeaderModification: !1,
      done: !1,
      timingAllowFailed: !1,
      ...Y,
      headersList: Y.headersList ? new i(Y.headersList) : new i()
    };
    return O.url = O.urlList[0], O;
  }
  function U(Y) {
    const O = S({ ...Y, body: null });
    return Y.body != null && (O.body = e(Y.body)), O;
  }
  return Object.defineProperties(T.prototype, {
    method: C,
    url: C,
    headers: C,
    redirect: C,
    clone: C,
    signal: C,
    duplex: C,
    destination: C,
    body: C,
    bodyUsed: C,
    isHistoryNavigation: C,
    isReloadNavigation: C,
    keepalive: C,
    integrity: C,
    cache: C,
    credentials: C,
    attribute: C,
    referrerPolicy: C,
    referrer: C,
    mode: C,
    [Symbol.toStringTag]: {
      value: "Request",
      configurable: !0
    }
  }), N.converters.Request = N.interfaceConverter(
    T
  ), N.converters.RequestInfo = function(Y) {
    return typeof Y == "string" ? N.converters.USVString(Y) : Y instanceof T ? N.converters.Request(Y) : N.converters.USVString(Y);
  }, N.converters.AbortSignal = N.interfaceConverter(
    AbortSignal
  ), N.converters.RequestInit = N.dictionaryConverter([
    {
      key: "method",
      converter: N.converters.ByteString
    },
    {
      key: "headers",
      converter: N.converters.HeadersInit
    },
    {
      key: "body",
      converter: N.nullableConverter(
        N.converters.BodyInit
      )
    },
    {
      key: "referrer",
      converter: N.converters.USVString
    },
    {
      key: "referrerPolicy",
      converter: N.converters.DOMString,
      // https://w3c.github.io/webappsec-referrer-policy/#referrer-policy
      allowedValues: I
    },
    {
      key: "mode",
      converter: N.converters.DOMString,
      // https://fetch.spec.whatwg.org/#concept-request-mode
      allowedValues: Q
    },
    {
      key: "credentials",
      converter: N.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcredentials
      allowedValues: E
    },
    {
      key: "cache",
      converter: N.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestcache
      allowedValues: B
    },
    {
      key: "redirect",
      converter: N.converters.DOMString,
      // https://fetch.spec.whatwg.org/#requestredirect
      allowedValues: y
    },
    {
      key: "integrity",
      converter: N.converters.DOMString
    },
    {
      key: "keepalive",
      converter: N.converters.boolean
    },
    {
      key: "signal",
      converter: N.nullableConverter(
        (Y) => N.converters.AbortSignal(
          Y,
          { strict: !1 }
        )
      )
    },
    {
      key: "window",
      converter: N.converters.any
    },
    {
      key: "duplex",
      converter: N.converters.DOMString,
      allowedValues: w
    }
  ]), ko = { Request: T, makeRequest: S }, ko;
}
var bo, Sl;
function Ms() {
  if (Sl)
    return bo;
  Sl = 1;
  const {
    Response: r,
    makeNetworkError: t,
    makeAppropriateNetworkError: e,
    filterResponse: A,
    makeResponse: n
  } = Ps(), { Headers: i } = sr(), { Request: a, makeRequest: o } = Ti(), s = L, {
    bytesMatch: l,
    makePolicyContainer: c,
    clonePolicyContainer: u,
    requestBadPort: h,
    TAOCheck: g,
    appendRequestOriginHeader: d,
    responseLocationURL: I,
    requestCurrentURL: y,
    setRequestReferrerPolicyOnRedirect: Q,
    tryUpgradeRequestToAPotentiallyTrustworthyURL: E,
    createOpaqueTimingInfo: B,
    appendFetchMetadata: w,
    corsCheck: C,
    crossOriginResourcePolicyCheck: f,
    determineRequestsReferrer: p,
    coarsenedSharedCurrentTime: m,
    createDeferredPromise: R,
    isBlobLike: P,
    sameOrigin: N,
    isCancelled: $,
    isAborted: V,
    isErrorLike: ne,
    fullyReadBody: _,
    readableStreamClose: X,
    isomorphicEncode: te,
    urlIsLocal: ee,
    urlIsHttpHttpsScheme: Z,
    urlHasHttpsScheme: b
  } = NA(), { kState: W, kHeaders: v, kGuard: F, kRealm: T } = Ct(), S = L, { safelyExtractBody: U } = di(), {
    redirectStatusSet: Y,
    nullBodyStatus: O,
    safeMethodsSet: j,
    requestBodyHeader: H,
    subresourceSet: ie,
    DOMException: ye
  } = Mt(), { kHeadersList: Ee } = Re, He = L, { Readable: be, pipeline: De } = L, { addAbortListener: Ge, isErrored: Qe, isReadable: Ce, nodeMajor: pe, nodeMinor: sA } = Ie, { dataURLProcessor: Lt, serializeAMimeType: ft } = JA(), { TransformStream: Ht } = L, { getGlobalDispatcher: ue } = dn, { webidl: Ne } = QA(), { STATUS_CODES: SA } = L, k = ["GET", "HEAD"];
  let J, K = globalThis.ReadableStream;
  class oe extends He {
    constructor(z) {
      super(), this.dispatcher = z, this.connection = null, this.dump = !1, this.state = "ongoing", this.setMaxListeners(21);
    }
    terminate(z) {
      var G;
      this.state === "ongoing" && (this.state = "terminated", (G = this.connection) == null || G.destroy(z), this.emit("terminated", z));
    }
    // https://fetch.spec.whatwg.org/#fetch-controller-abort
    abort(z) {
      var G;
      this.state === "ongoing" && (this.state = "aborted", z || (z = new ye("The operation was aborted.", "AbortError")), this.serializedAbortReason = z, (G = this.connection) == null || G.destroy(z), this.emit("terminated", z));
    }
  }
  function Be(D, z = {}) {
    var ge;
    Ne.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
    const G = R();
    let x;
    try {
      x = new a(D, z);
    } catch (me) {
      return G.reject(me), G.promise;
    }
    const re = x[W];
    if (x.signal.aborted)
      return EA(G, re, null, x.signal.reason), G.promise;
    const q = re.client.globalObject;
    ((ge = q == null ? void 0 : q.constructor) == null ? void 0 : ge.name) === "ServiceWorkerGlobalScope" && (re.serviceWorkers = "none");
    let he = null;
    const Pe = null;
    let BA = !1, Ye = null;
    return Ge(
      x.signal,
      () => {
        BA = !0, S(Ye != null), Ye.abort(x.signal.reason), EA(G, re, he, x.signal.reason);
      }
    ), Ye = cA({
      request: re,
      processResponseEndOfBody: (me) => We(me, "fetch"),
      processResponse: (me) => {
        if (BA)
          return Promise.resolve();
        if (me.aborted)
          return EA(G, re, he, Ye.serializedAbortReason), Promise.resolve();
        if (me.type === "error")
          return G.reject(
            Object.assign(new TypeError("fetch failed"), { cause: me.error })
          ), Promise.resolve();
        he = new r(), he[W] = me, he[T] = Pe, he[v][Ee] = me.headersList, he[v][F] = "immutable", he[v][T] = Pe, G.resolve(he);
      },
      dispatcher: z.dispatcher ?? ue()
      // undici
    }), G.promise;
  }
  function We(D, z = "other") {
    var q;
    if (D.type === "error" && D.aborted || !((q = D.urlList) != null && q.length))
      return;
    const G = D.urlList[0];
    let x = D.timingInfo, re = D.cacheState;
    Z(G) && x !== null && (D.timingAllowPassed || (x = B({
      startTime: x.startTime
    }), re = ""), x.endTime = m(), D.timingInfo = x, AA(
      x,
      G,
      z,
      globalThis,
      re
    ));
  }
  function AA(D, z, G, x, re) {
    (pe > 18 || pe === 18 && sA >= 2) && performance.markResourceTiming(D, z.href, G, x, re);
  }
  function EA(D, z, G, x) {
    var q, he;
    if (x || (x = new ye("The operation was aborted.", "AbortError")), D.reject(x), z.body != null && Ce((q = z.body) == null ? void 0 : q.stream) && z.body.stream.cancel(x).catch((Pe) => {
      if (Pe.code !== "ERR_INVALID_STATE")
        throw Pe;
    }), G == null)
      return;
    const re = G[W];
    re.body != null && Ce((he = re.body) == null ? void 0 : he.stream) && re.body.stream.cancel(x).catch((Pe) => {
      if (Pe.code !== "ERR_INVALID_STATE")
        throw Pe;
    });
  }
  function cA({
    request: D,
    processRequestBodyChunkLength: z,
    processRequestEndOfBody: G,
    processResponse: x,
    processResponseEndOfBody: re,
    processResponseConsumeBody: q,
    useParallelQueue: he = !1,
    dispatcher: Pe
    // undici
  }) {
    var me, IA, xe, UA;
    let BA = null, Ye = !1;
    D.client != null && (BA = D.client.globalObject, Ye = D.client.crossOriginIsolatedCapability);
    const zA = m(Ye), kn = B({
      startTime: zA
    }), ge = {
      controller: new oe(Pe),
      request: D,
      timingInfo: kn,
      processRequestBodyChunkLength: z,
      processRequestEndOfBody: G,
      processResponse: x,
      processResponseConsumeBody: q,
      processResponseEndOfBody: re,
      taskDestination: BA,
      crossOriginIsolatedCapability: Ye
    };
    return S(!D.body || D.body.stream), D.window === "client" && (D.window = ((xe = (IA = (me = D.client) == null ? void 0 : me.globalObject) == null ? void 0 : IA.constructor) == null ? void 0 : xe.name) === "Window" ? D.client : "no-window"), D.origin === "client" && (D.origin = (UA = D.client) == null ? void 0 : UA.origin), D.policyContainer === "client" && (D.client != null ? D.policyContainer = u(
      D.client.policyContainer
    ) : D.policyContainer = c()), D.headersList.contains("accept") || D.headersList.append("accept", "*/*"), D.headersList.contains("accept-language") || D.headersList.append("accept-language", "*"), D.priority, ie.has(D.destination), wn(ge).catch((Se) => {
      ge.controller.terminate(Se);
    }), ge.controller;
  }
  async function wn(D, z = !1) {
    const G = D.request;
    let x = null;
    if (G.localURLsOnly && !ee(y(G)) && (x = t("local URLs only")), E(G), h(G) === "blocked" && (x = t("bad port")), G.referrerPolicy === "" && (G.referrerPolicy = G.policyContainer.referrerPolicy), G.referrer !== "no-referrer" && (G.referrer = p(G)), x === null && (x = await (async () => {
      const q = y(G);
      return (
        // - requests current URLs origin is same origin with requests origin,
        //   and requests response tainting is "basic"
        N(q, G.url) && G.responseTainting === "basic" || // requests current URLs scheme is "data"
        q.protocol === "data:" || // - requests mode is "navigate" or "websocket"
        G.mode === "navigate" || G.mode === "websocket" ? (G.responseTainting = "basic", await vn(D)) : G.mode === "same-origin" ? t('request mode cannot be "same-origin"') : G.mode === "no-cors" ? G.redirect !== "follow" ? t(
          'redirect mode cannot be "follow" for "no-cors" request'
        ) : (G.responseTainting = "opaque", await vn(D)) : Z(y(G)) ? (G.responseTainting = "cors", await Ys(D)) : t("URL scheme must be a HTTP(S) scheme")
      );
    })()), z)
      return x;
    x.status !== 0 && !x.internalResponse && (G.responseTainting, G.responseTainting === "basic" ? x = A(x, "basic") : G.responseTainting === "cors" ? x = A(x, "cors") : G.responseTainting === "opaque" ? x = A(x, "opaque") : S(!1));
    let re = x.status === 0 ? x : x.internalResponse;
    if (re.urlList.length === 0 && re.urlList.push(...G.urlList), G.timingAllowFailed || (x.timingAllowPassed = !0), x.type === "opaque" && re.status === 206 && re.rangeRequested && !G.headers.contains("range") && (x = re = t()), x.status !== 0 && (G.method === "HEAD" || G.method === "CONNECT" || O.includes(re.status)) && (re.body = null, D.controller.dump = !0), G.integrity) {
      const q = (Pe) => Ea(D, t(Pe));
      if (G.responseTainting === "opaque" || x.body == null) {
        q(x.error);
        return;
      }
      const he = (Pe) => {
        if (!l(Pe, G.integrity)) {
          q("integrity mismatch");
          return;
        }
        x.body = U(Pe)[0], Ea(D, x);
      };
      await _(x.body, he, q);
    } else
      Ea(D, x);
  }
  function vn(D) {
    if ($(D) && D.request.redirectCount === 0)
      return Promise.resolve(e(D));
    const { request: z } = D, { protocol: G } = y(z);
    switch (G) {
      case "about:":
        return Promise.resolve(t("about scheme is not supported"));
      case "blob:": {
        J || (J = L.resolveObjectURL);
        const x = y(z);
        if (x.search.length !== 0)
          return Promise.resolve(t("NetworkError when attempting to fetch resource."));
        const re = J(x.toString());
        if (z.method !== "GET" || !P(re))
          return Promise.resolve(t("invalid method"));
        const q = U(re), he = q[0], Pe = te(`${he.length}`), BA = q[1] ?? "", Ye = n({
          statusText: "OK",
          headersList: [
            ["content-length", { name: "Content-Length", value: Pe }],
            ["content-type", { name: "Content-Type", value: BA }]
          ]
        });
        return Ye.body = he, Promise.resolve(Ye);
      }
      case "data:": {
        const x = y(z), re = Lt(x);
        if (re === "failure")
          return Promise.resolve(t("failed to fetch the data URL"));
        const q = ft(re.mimeType);
        return Promise.resolve(n({
          statusText: "OK",
          headersList: [
            ["content-type", { name: "Content-Type", value: q }]
          ],
          body: U(re.body)[0]
        }));
      }
      case "file:":
        return Promise.resolve(t("not implemented... yet..."));
      case "http:":
      case "https:":
        return Ys(D).catch((x) => t(x));
      default:
        return Promise.resolve(t("unknown scheme"));
    }
  }
  function Rg(D, z) {
    D.request.done = !0, D.processResponseDone != null && queueMicrotask(() => D.processResponseDone(z));
  }
  function Ea(D, z) {
    z.type === "error" && (z.urlList = [D.request.urlList[0]], z.timingInfo = B({
      startTime: D.timingInfo.startTime
    }));
    const G = () => {
      D.request.done = !0, D.processResponseEndOfBody != null && queueMicrotask(() => D.processResponseEndOfBody(z));
    };
    if (D.processResponse != null && queueMicrotask(() => D.processResponse(z)), z.body == null)
      G();
    else {
      const x = (q, he) => {
        he.enqueue(q);
      }, re = new Ht({
        start() {
        },
        transform: x,
        flush: G
      }, {
        size() {
          return 1;
        }
      }, {
        size() {
          return 1;
        }
      });
      z.body = { stream: z.body.stream.pipeThrough(re) };
    }
    if (D.processResponseConsumeBody != null) {
      const x = (q) => D.processResponseConsumeBody(z, q), re = (q) => D.processResponseConsumeBody(z, q);
      if (z.body == null)
        queueMicrotask(() => x(null));
      else
        return _(z.body, x, re);
      return Promise.resolve();
    }
  }
  async function Ys(D) {
    const z = D.request;
    let G = null, x = null;
    const re = D.timingInfo;
    if (z.serviceWorkers, G === null) {
      if (z.redirect === "follow" && (z.serviceWorkers = "none"), x = G = await Js(D), z.responseTainting === "cors" && C(z, G) === "failure")
        return t("cors failure");
      g(z, G) === "failure" && (z.timingAllowFailed = !0);
    }
    return (z.responseTainting === "opaque" || G.type === "opaque") && f(
      z.origin,
      z.client,
      z.destination,
      x
    ) === "blocked" ? t("blocked") : (Y.has(x.status) && (z.redirect !== "manual" && D.controller.connection.destroy(), z.redirect === "error" ? G = t("unexpected redirect") : z.redirect === "manual" ? G = x : z.redirect === "follow" ? G = await Dg(D, G) : S(!1)), G.timingInfo = re, G);
  }
  function Dg(D, z) {
    const G = D.request, x = z.internalResponse ? z.internalResponse : z;
    let re;
    try {
      if (re = I(
        x,
        y(G).hash
      ), re == null)
        return z;
    } catch (he) {
      return Promise.resolve(t(he));
    }
    if (!Z(re))
      return Promise.resolve(t("URL scheme must be a HTTP(S) scheme"));
    if (G.redirectCount === 20)
      return Promise.resolve(t("redirect count exceeded"));
    if (G.redirectCount += 1, G.mode === "cors" && (re.username || re.password) && !N(G, re))
      return Promise.resolve(t('cross origin not allowed for request mode "cors"'));
    if (G.responseTainting === "cors" && (re.username || re.password))
      return Promise.resolve(t(
        'URL cannot contain credentials for request mode "cors"'
      ));
    if (x.status !== 303 && G.body != null && G.body.source == null)
      return Promise.resolve(t());
    if ([301, 302].includes(x.status) && G.method === "POST" || x.status === 303 && !k.includes(G.method)) {
      G.method = "GET", G.body = null;
      for (const he of H)
        G.headersList.delete(he);
    }
    N(y(G), re) || (G.headersList.delete("authorization"), G.headersList.delete("proxy-authorization", !0), G.headersList.delete("cookie"), G.headersList.delete("host")), G.body != null && (S(G.body.source != null), G.body = U(G.body.source)[0]);
    const q = D.timingInfo;
    return q.redirectEndTime = q.postRedirectStartTime = m(D.crossOriginIsolatedCapability), q.redirectStartTime === 0 && (q.redirectStartTime = q.startTime), G.urlList.push(re), Q(G, x), wn(D, !0);
  }
  async function Js(D, z = !1, G = !1) {
    const x = D.request;
    let re = null, q = null, he = null;
    x.window === "no-window" && x.redirect === "error" ? (re = D, q = x) : (q = o(x), re = { ...D }, re.request = q);
    const Pe = x.credentials === "include" || x.credentials === "same-origin" && x.responseTainting === "basic", BA = q.body ? q.body.length : null;
    let Ye = null;
    if (q.body == null && ["POST", "PUT"].includes(q.method) && (Ye = "0"), BA != null && (Ye = te(`${BA}`)), Ye != null && q.headersList.append("content-length", Ye), BA != null && q.keepalive, q.referrer instanceof URL && q.headersList.append("referer", te(q.referrer.href)), d(q), w(q), q.headersList.contains("user-agent") || q.headersList.append("user-agent", typeof esbuildDetection > "u" ? "undici" : "node"), q.cache === "default" && (q.headersList.contains("if-modified-since") || q.headersList.contains("if-none-match") || q.headersList.contains("if-unmodified-since") || q.headersList.contains("if-match") || q.headersList.contains("if-range")) && (q.cache = "no-store"), q.cache === "no-cache" && !q.preventNoCacheCacheControlHeaderModification && !q.headersList.contains("cache-control") && q.headersList.append("cache-control", "max-age=0"), (q.cache === "no-store" || q.cache === "reload") && (q.headersList.contains("pragma") || q.headersList.append("pragma", "no-cache"), q.headersList.contains("cache-control") || q.headersList.append("cache-control", "no-cache")), q.headersList.contains("range") && q.headersList.append("accept-encoding", "identity"), q.headersList.contains("accept-encoding") || (b(y(q)) ? q.headersList.append("accept-encoding", "br, gzip, deflate") : q.headersList.append("accept-encoding", "gzip, deflate")), q.headersList.delete("host"), q.cache = "no-store", q.mode !== "no-store" && q.mode, he == null) {
      if (q.mode === "only-if-cached")
        return t("only if cached");
      const zA = await Ng(
        re,
        Pe,
        G
      );
      !j.has(q.method) && zA.status >= 200 && zA.status <= 399, he == null && (he = zA);
    }
    if (he.urlList = [...q.urlList], q.headersList.contains("range") && (he.rangeRequested = !0), he.requestIncludesCredentials = Pe, he.status === 407)
      return x.window === "no-window" ? t() : $(D) ? e(D) : t("proxy authentication required");
    if (
      // responses status is 421
      he.status === 421 && // isNewConnectionFetch is false
      !G && // requests body is null, or requests body is non-null and requests bodys source is non-null
      (x.body == null || x.body.source != null)
    ) {
      if ($(D))
        return e(D);
      D.controller.connection.destroy(), he = await Js(
        D,
        z,
        !0
      );
    }
    return he;
  }
  async function Ng(D, z = !1, G = !1) {
    S(!D.controller.connection || D.controller.connection.destroyed), D.controller.connection = {
      abort: null,
      destroyed: !1,
      destroy(ge) {
        var me;
        this.destroyed || (this.destroyed = !0, (me = this.abort) == null || me.call(this, ge ?? new ye("The operation was aborted.", "AbortError")));
      }
    };
    const x = D.request;
    let re = null;
    const q = D.timingInfo;
    x.cache = "no-store", x.mode;
    let he = null;
    if (x.body == null && D.processRequestEndOfBody)
      queueMicrotask(() => D.processRequestEndOfBody());
    else if (x.body != null) {
      const ge = async function* (xe) {
        var UA;
        $(D) || (yield xe, (UA = D.processRequestBodyChunkLength) == null || UA.call(D, xe.byteLength));
      }, me = () => {
        $(D) || D.processRequestEndOfBody && D.processRequestEndOfBody();
      }, IA = (xe) => {
        $(D) || (xe.name === "AbortError" ? D.controller.abort() : D.controller.terminate(xe));
      };
      he = async function* () {
        try {
          for await (const xe of x.body.stream)
            yield* ge(xe);
          me();
        } catch (xe) {
          IA(xe);
        }
      }();
    }
    try {
      const { body: ge, status: me, statusText: IA, headersList: xe, socket: UA } = await kn({ body: he });
      if (UA)
        re = n({ status: me, statusText: IA, headersList: xe, socket: UA });
      else {
        const Se = ge[Symbol.asyncIterator]();
        D.controller.next = () => Se.next(), re = n({ status: me, statusText: IA, headersList: xe });
      }
    } catch (ge) {
      return ge.name === "AbortError" ? (D.controller.connection.destroy(), e(D, ge)) : t(ge);
    }
    const Pe = () => {
      D.controller.resume();
    }, BA = (ge) => {
      D.controller.abort(ge);
    };
    K || (K = L.ReadableStream);
    const Ye = new K(
      {
        async start(ge) {
          D.controller.controller = ge;
        },
        async pull(ge) {
          await Pe();
        },
        async cancel(ge) {
          await BA(ge);
        }
      },
      {
        highWaterMark: 0,
        size() {
          return 1;
        }
      }
    );
    re.body = { stream: Ye }, D.controller.on("terminated", zA), D.controller.resume = async () => {
      for (; ; ) {
        let ge, me;
        try {
          const { done: IA, value: xe } = await D.controller.next();
          if (V(D))
            break;
          ge = IA ? void 0 : xe;
        } catch (IA) {
          D.controller.ended && !q.encodedBodySize ? ge = void 0 : (ge = IA, me = !0);
        }
        if (ge === void 0) {
          X(D.controller.controller), Rg(D, re);
          return;
        }
        if (q.decodedBodySize += (ge == null ? void 0 : ge.byteLength) ?? 0, me) {
          D.controller.terminate(ge);
          return;
        }
        if (D.controller.controller.enqueue(new Uint8Array(ge)), Qe(Ye)) {
          D.controller.terminate();
          return;
        }
        if (!D.controller.controller.desiredSize)
          return;
      }
    };
    function zA(ge) {
      V(D) ? (re.aborted = !0, Ce(Ye) && D.controller.controller.error(
        D.controller.serializedAbortReason
      )) : Ce(Ye) && D.controller.controller.error(new TypeError("terminated", {
        cause: ne(ge) ? ge : void 0
      })), D.controller.connection.destroy();
    }
    return re;
    async function kn({ body: ge }) {
      const me = y(x), IA = D.controller.dispatcher;
      return new Promise((xe, UA) => IA.dispatch(
        {
          path: me.pathname + me.search,
          origin: me.origin,
          method: x.method,
          body: D.controller.dispatcher.isMockActive ? x.body && (x.body.source || x.body.stream) : ge,
          headers: x.headersList.entries,
          maxRedirections: 0,
          upgrade: x.mode === "websocket" ? "websocket" : void 0
        },
        {
          body: null,
          abort: null,
          onConnect(Se) {
            const { connection: qe } = D.controller;
            qe.destroyed ? Se(new ye("The operation was aborted.", "AbortError")) : (D.controller.on("terminated", Se), this.abort = qe.abort = Se);
          },
          onHeaders(Se, qe, Ca, bn) {
            if (Se < 200)
              return;
            let et = [], lr = "";
            const ur = new i();
            if (Array.isArray(qe))
              for (let bA = 0; bA < qe.length; bA += 2) {
                const At = qe[bA + 0].toString("latin1"), Qt = qe[bA + 1].toString("latin1");
                At.toLowerCase() === "content-encoding" ? et = Qt.toLowerCase().split(",").map((fa) => fa.trim()) : At.toLowerCase() === "location" && (lr = Qt), ur[Ee].append(At, Qt);
              }
            else {
              const bA = Object.keys(qe);
              for (const At of bA) {
                const Qt = qe[At];
                At.toLowerCase() === "content-encoding" ? et = Qt.toLowerCase().split(",").map((fa) => fa.trim()).reverse() : At.toLowerCase() === "location" && (lr = Qt), ur[Ee].append(At, Qt);
              }
            }
            this.body = new be({ read: Ca });
            const Gt = [], Sg = x.redirect === "follow" && lr && Y.has(Se);
            if (x.method !== "HEAD" && x.method !== "CONNECT" && !O.includes(Se) && !Sg)
              for (const bA of et)
                if (bA === "x-gzip" || bA === "gzip")
                  Gt.push(s.createGunzip({
                    // Be less strict when decoding compressed responses, since sometimes
                    // servers send slightly invalid responses that are still accepted
                    // by common browsers.
                    // Always using Z_SYNC_FLUSH is what cURL does.
                    flush: s.constants.Z_SYNC_FLUSH,
                    finishFlush: s.constants.Z_SYNC_FLUSH
                  }));
                else if (bA === "deflate")
                  Gt.push(s.createInflate());
                else if (bA === "br")
                  Gt.push(s.createBrotliDecompress());
                else {
                  Gt.length = 0;
                  break;
                }
            return xe({
              status: Se,
              statusText: bn,
              headersList: ur[Ee],
              body: Gt.length ? De(this.body, ...Gt, () => {
              }) : this.body.on("error", () => {
              })
            }), !0;
          },
          onData(Se) {
            if (D.controller.dump)
              return;
            const qe = Se;
            return q.encodedBodySize += qe.byteLength, this.body.push(qe);
          },
          onComplete() {
            this.abort && D.controller.off("terminated", this.abort), D.controller.ended = !0, this.body.push(null);
          },
          onError(Se) {
            var qe;
            this.abort && D.controller.off("terminated", this.abort), (qe = this.body) == null || qe.destroy(Se), D.controller.terminate(Se), UA(Se);
          },
          onUpgrade(Se, qe, Ca) {
            if (Se !== 101)
              return;
            const bn = new i();
            for (let et = 0; et < qe.length; et += 2) {
              const lr = qe[et + 0].toString("latin1"), ur = qe[et + 1].toString("latin1");
              bn[Ee].append(lr, ur);
            }
            return xe({
              status: Se,
              statusText: SA[Se],
              headersList: bn[Ee],
              socket: Ca
            }), !0;
          }
        }
      ));
    }
  }
  return bo = {
    fetch: Be,
    Fetch: oe,
    fetching: cA,
    finalizeAndReportTiming: We
  }, bo;
}
var To, Ul;
function hg() {
  return Ul || (Ul = 1, To = {
    kState: Symbol("FileReader state"),
    kResult: Symbol("FileReader result"),
    kError: Symbol("FileReader error"),
    kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
    kEvents: Symbol("FileReader events"),
    kAborted: Symbol("FileReader aborted")
  }), To;
}
var Fo, Pl;
function yd() {
  if (Pl)
    return Fo;
  Pl = 1;
  const { webidl: r } = QA(), t = Symbol("ProgressEvent state");
  class e extends Event {
    constructor(n, i = {}) {
      n = r.converters.DOMString(n), i = r.converters.ProgressEventInit(i ?? {}), super(n, i), this[t] = {
        lengthComputable: i.lengthComputable,
        loaded: i.loaded,
        total: i.total
      };
    }
    get lengthComputable() {
      return r.brandCheck(this, e), this[t].lengthComputable;
    }
    get loaded() {
      return r.brandCheck(this, e), this[t].loaded;
    }
    get total() {
      return r.brandCheck(this, e), this[t].total;
    }
  }
  return r.converters.ProgressEventInit = r.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: r.converters.boolean,
      defaultValue: !1
    },
    {
      key: "loaded",
      converter: r.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "total",
      converter: r.converters["unsigned long long"],
      defaultValue: 0
    },
    {
      key: "bubbles",
      converter: r.converters.boolean,
      defaultValue: !1
    },
    {
      key: "cancelable",
      converter: r.converters.boolean,
      defaultValue: !1
    },
    {
      key: "composed",
      converter: r.converters.boolean,
      defaultValue: !1
    }
  ]), Fo = {
    ProgressEvent: e
  }, Fo;
}
var Ro, Ml;
function md() {
  if (Ml)
    return Ro;
  Ml = 1;
  function r(t) {
    if (!t)
      return "failure";
    switch (t.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8";
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866";
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2";
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3";
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4";
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5";
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6";
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7";
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8";
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I";
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10";
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13";
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14";
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15";
      case "iso-8859-16":
        return "ISO-8859-16";
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R";
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U";
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh";
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874";
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250";
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251";
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252";
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253";
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254";
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255";
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256";
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257";
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258";
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic";
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK";
      case "gb18030":
        return "gb18030";
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5";
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP";
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP";
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS";
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR";
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement";
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE";
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE";
      case "x-user-defined":
        return "x-user-defined";
      default:
        return "failure";
    }
  }
  return Ro = {
    getEncoding: r
  }, Ro;
}
var Do = {}, $n = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var Ll;
function wd() {
  return Ll || (Ll = 1, function(r, t) {
    var e = L, A = e.Buffer;
    function n(a, o) {
      for (var s in a)
        o[s] = a[s];
    }
    A.from && A.alloc && A.allocUnsafe && A.allocUnsafeSlow ? r.exports = e : (n(e, t), t.Buffer = i);
    function i(a, o, s) {
      return A(a, o, s);
    }
    i.prototype = Object.create(A.prototype), n(A, i), i.from = function(a, o, s) {
      if (typeof a == "number")
        throw new TypeError("Argument must not be a number");
      return A(a, o, s);
    }, i.alloc = function(a, o, s) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      var l = A(a);
      return o !== void 0 ? typeof s == "string" ? l.fill(o, s) : l.fill(o) : l.fill(0), l;
    }, i.allocUnsafe = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return A(a);
    }, i.allocUnsafeSlow = function(a) {
      if (typeof a != "number")
        throw new TypeError("Argument must be a number");
      return e.SlowBuffer(a);
    };
  }($n, $n.exports)), $n.exports;
}
var Hl;
function vd() {
  if (Hl)
    return Do;
  Hl = 1;
  var r = wd().Buffer, t = r.isEncoding || function(Q) {
    switch (Q = "" + Q, Q && Q.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function e(Q) {
    if (!Q)
      return "utf8";
    for (var E; ; )
      switch (Q) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return Q;
        default:
          if (E)
            return;
          Q = ("" + Q).toLowerCase(), E = !0;
      }
  }
  function A(Q) {
    var E = e(Q);
    if (typeof E != "string" && (r.isEncoding === t || !t(Q)))
      throw new Error("Unknown encoding: " + Q);
    return E || Q;
  }
  Do.StringDecoder = n;
  function n(Q) {
    this.encoding = A(Q);
    var E;
    switch (this.encoding) {
      case "utf16le":
        this.text = u, this.end = h, E = 4;
        break;
      case "utf8":
        this.fillLast = s, E = 4;
        break;
      case "base64":
        this.text = g, this.end = d, E = 3;
        break;
      default:
        this.write = I, this.end = y;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = r.allocUnsafe(E);
  }
  n.prototype.write = function(Q) {
    if (Q.length === 0)
      return "";
    var E, B;
    if (this.lastNeed) {
      if (E = this.fillLast(Q), E === void 0)
        return "";
      B = this.lastNeed, this.lastNeed = 0;
    } else
      B = 0;
    return B < Q.length ? E ? E + this.text(Q, B) : this.text(Q, B) : E || "";
  }, n.prototype.end = c, n.prototype.text = l, n.prototype.fillLast = function(Q) {
    if (this.lastNeed <= Q.length)
      return Q.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    Q.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, Q.length), this.lastNeed -= Q.length;
  };
  function i(Q) {
    return Q <= 127 ? 0 : Q >> 5 === 6 ? 2 : Q >> 4 === 14 ? 3 : Q >> 3 === 30 ? 4 : Q >> 6 === 2 ? -1 : -2;
  }
  function a(Q, E, B) {
    var w = E.length - 1;
    if (w < B)
      return 0;
    var C = i(E[w]);
    return C >= 0 ? (C > 0 && (Q.lastNeed = C - 1), C) : --w < B || C === -2 ? 0 : (C = i(E[w]), C >= 0 ? (C > 0 && (Q.lastNeed = C - 2), C) : --w < B || C === -2 ? 0 : (C = i(E[w]), C >= 0 ? (C > 0 && (C === 2 ? C = 0 : Q.lastNeed = C - 3), C) : 0));
  }
  function o(Q, E, B) {
    if ((E[0] & 192) !== 128)
      return Q.lastNeed = 0, "";
    if (Q.lastNeed > 1 && E.length > 1) {
      if ((E[1] & 192) !== 128)
        return Q.lastNeed = 1, "";
      if (Q.lastNeed > 2 && E.length > 2 && (E[2] & 192) !== 128)
        return Q.lastNeed = 2, "";
    }
  }
  function s(Q) {
    var E = this.lastTotal - this.lastNeed, B = o(this, Q);
    if (B !== void 0)
      return B;
    if (this.lastNeed <= Q.length)
      return Q.copy(this.lastChar, E, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    Q.copy(this.lastChar, E, 0, Q.length), this.lastNeed -= Q.length;
  }
  function l(Q, E) {
    var B = a(this, Q, E);
    if (!this.lastNeed)
      return Q.toString("utf8", E);
    this.lastTotal = B;
    var w = Q.length - (B - this.lastNeed);
    return Q.copy(this.lastChar, 0, w), Q.toString("utf8", E, w);
  }
  function c(Q) {
    var E = Q && Q.length ? this.write(Q) : "";
    return this.lastNeed ? E + "" : E;
  }
  function u(Q, E) {
    if ((Q.length - E) % 2 === 0) {
      var B = Q.toString("utf16le", E);
      if (B) {
        var w = B.charCodeAt(B.length - 1);
        if (w >= 55296 && w <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = Q[Q.length - 2], this.lastChar[1] = Q[Q.length - 1], B.slice(0, -1);
      }
      return B;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = Q[Q.length - 1], Q.toString("utf16le", E, Q.length - 1);
  }
  function h(Q) {
    var E = Q && Q.length ? this.write(Q) : "";
    if (this.lastNeed) {
      var B = this.lastTotal - this.lastNeed;
      return E + this.lastChar.toString("utf16le", 0, B);
    }
    return E;
  }
  function g(Q, E) {
    var B = (Q.length - E) % 3;
    return B === 0 ? Q.toString("base64", E) : (this.lastNeed = 3 - B, this.lastTotal = 3, B === 1 ? this.lastChar[0] = Q[Q.length - 1] : (this.lastChar[0] = Q[Q.length - 2], this.lastChar[1] = Q[Q.length - 1]), Q.toString("base64", E, Q.length - B));
  }
  function d(Q) {
    var E = Q && Q.length ? this.write(Q) : "";
    return this.lastNeed ? E + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : E;
  }
  function I(Q) {
    return Q.toString(this.encoding);
  }
  function y(Q) {
    return Q && Q.length ? this.write(Q) : "";
  }
  return Do;
}
var No, Gl;
function kd() {
  if (Gl)
    return No;
  Gl = 1;
  const {
    kState: r,
    kError: t,
    kResult: e,
    kAborted: A,
    kLastProgressEventFired: n
  } = hg(), { ProgressEvent: i } = yd(), { getEncoding: a } = md(), { DOMException: o } = Mt(), { serializeAMimeType: s, parseMIMEType: l } = JA(), { types: c } = L, { StringDecoder: u } = vd(), { btoa: h } = L, g = {
    enumerable: !0,
    writable: !1,
    configurable: !1
  };
  function d(w, C, f, p) {
    if (w[r] === "loading")
      throw new o("Invalid state", "InvalidStateError");
    w[r] = "loading", w[e] = null, w[t] = null;
    const R = C.stream().getReader(), P = [];
    let N = R.read(), $ = !0;
    (async () => {
      for (; !w[A]; )
        try {
          const { done: V, value: ne } = await N;
          if ($ && !w[A] && queueMicrotask(() => {
            I("loadstart", w);
          }), $ = !1, !V && c.isUint8Array(ne))
            P.push(ne), (w[n] === void 0 || Date.now() - w[n] >= 50) && !w[A] && (w[n] = Date.now(), queueMicrotask(() => {
              I("progress", w);
            })), N = R.read();
          else if (V) {
            queueMicrotask(() => {
              w[r] = "done";
              try {
                const _ = y(P, f, C.type, p);
                if (w[A])
                  return;
                w[e] = _, I("load", w);
              } catch (_) {
                w[t] = _, I("error", w);
              }
              w[r] !== "loading" && I("loadend", w);
            });
            break;
          }
        } catch (V) {
          if (w[A])
            return;
          queueMicrotask(() => {
            w[r] = "done", w[t] = V, I("error", w), w[r] !== "loading" && I("loadend", w);
          });
          break;
        }
    })();
  }
  function I(w, C) {
    const f = new i(w, {
      bubbles: !1,
      cancelable: !1
    });
    C.dispatchEvent(f);
  }
  function y(w, C, f, p) {
    switch (C) {
      case "DataURL": {
        let m = "data:";
        const R = l(f || "application/octet-stream");
        R !== "failure" && (m += s(R)), m += ";base64,";
        const P = new u("latin1");
        for (const N of w)
          m += h(P.write(N));
        return m += h(P.end()), m;
      }
      case "Text": {
        let m = "failure";
        if (p && (m = a(p)), m === "failure" && f) {
          const R = l(f);
          R !== "failure" && (m = a(R.parameters.get("charset")));
        }
        return m === "failure" && (m = "UTF-8"), Q(w, m);
      }
      case "ArrayBuffer":
        return B(w).buffer;
      case "BinaryString": {
        let m = "";
        const R = new u("latin1");
        for (const P of w)
          m += R.write(P);
        return m += R.end(), m;
      }
    }
  }
  function Q(w, C) {
    const f = B(w), p = E(f);
    let m = 0;
    p !== null && (C = p, m = p === "UTF-8" ? 3 : 2);
    const R = f.slice(m);
    return new TextDecoder(C).decode(R);
  }
  function E(w) {
    const [C, f, p] = w;
    return C === 239 && f === 187 && p === 191 ? "UTF-8" : C === 254 && f === 255 ? "UTF-16BE" : C === 255 && f === 254 ? "UTF-16LE" : null;
  }
  function B(w) {
    const C = w.reduce((p, m) => p + m.byteLength, 0);
    let f = 0;
    return w.reduce((p, m) => (p.set(m, f), f += m.byteLength, p), new Uint8Array(C));
  }
  return No = {
    staticPropertyDescriptors: g,
    readOperation: d,
    fireAProgressEvent: I
  }, No;
}
var So, Wl;
function bd() {
  if (Wl)
    return So;
  Wl = 1;
  const {
    staticPropertyDescriptors: r,
    readOperation: t,
    fireAProgressEvent: e
  } = kd(), {
    kState: A,
    kError: n,
    kResult: i,
    kEvents: a,
    kAborted: o
  } = hg(), { webidl: s } = QA(), { kEnumerableProperty: l } = Ie;
  class c extends EventTarget {
    constructor() {
      super(), this[A] = "empty", this[i] = null, this[n] = null, this[a] = {
        loadend: null,
        error: null,
        abort: null,
        load: null,
        progress: null,
        loadstart: null
      };
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-readAsArrayBuffer
     * @param {import('buffer').Blob} blob
     */
    readAsArrayBuffer(h) {
      s.brandCheck(this, c), s.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" }), h = s.converters.Blob(h, { strict: !1 }), t(this, h, "ArrayBuffer");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#readAsBinaryString
     * @param {import('buffer').Blob} blob
     */
    readAsBinaryString(h) {
      s.brandCheck(this, c), s.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" }), h = s.converters.Blob(h, { strict: !1 }), t(this, h, "BinaryString");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#readAsDataText
     * @param {import('buffer').Blob} blob
     * @param {string?} encoding
     */
    readAsText(h, g = void 0) {
      s.brandCheck(this, c), s.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" }), h = s.converters.Blob(h, { strict: !1 }), g !== void 0 && (g = s.converters.DOMString(g)), t(this, h, "Text", g);
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-readAsDataURL
     * @param {import('buffer').Blob} blob
     */
    readAsDataURL(h) {
      s.brandCheck(this, c), s.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" }), h = s.converters.Blob(h, { strict: !1 }), t(this, h, "DataURL");
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dfn-abort
     */
    abort() {
      if (this[A] === "empty" || this[A] === "done") {
        this[i] = null;
        return;
      }
      this[A] === "loading" && (this[A] = "done", this[i] = null), this[o] = !0, e("abort", this), this[A] !== "loading" && e("loadend", this);
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-readystate
     */
    get readyState() {
      switch (s.brandCheck(this, c), this[A]) {
        case "empty":
          return this.EMPTY;
        case "loading":
          return this.LOADING;
        case "done":
          return this.DONE;
      }
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-result
     */
    get result() {
      return s.brandCheck(this, c), this[i];
    }
    /**
     * @see https://w3c.github.io/FileAPI/#dom-filereader-error
     */
    get error() {
      return s.brandCheck(this, c), this[n];
    }
    get onloadend() {
      return s.brandCheck(this, c), this[a].loadend;
    }
    set onloadend(h) {
      s.brandCheck(this, c), this[a].loadend && this.removeEventListener("loadend", this[a].loadend), typeof h == "function" ? (this[a].loadend = h, this.addEventListener("loadend", h)) : this[a].loadend = null;
    }
    get onerror() {
      return s.brandCheck(this, c), this[a].error;
    }
    set onerror(h) {
      s.brandCheck(this, c), this[a].error && this.removeEventListener("error", this[a].error), typeof h == "function" ? (this[a].error = h, this.addEventListener("error", h)) : this[a].error = null;
    }
    get onloadstart() {
      return s.brandCheck(this, c), this[a].loadstart;
    }
    set onloadstart(h) {
      s.brandCheck(this, c), this[a].loadstart && this.removeEventListener("loadstart", this[a].loadstart), typeof h == "function" ? (this[a].loadstart = h, this.addEventListener("loadstart", h)) : this[a].loadstart = null;
    }
    get onprogress() {
      return s.brandCheck(this, c), this[a].progress;
    }
    set onprogress(h) {
      s.brandCheck(this, c), this[a].progress && this.removeEventListener("progress", this[a].progress), typeof h == "function" ? (this[a].progress = h, this.addEventListener("progress", h)) : this[a].progress = null;
    }
    get onload() {
      return s.brandCheck(this, c), this[a].load;
    }
    set onload(h) {
      s.brandCheck(this, c), this[a].load && this.removeEventListener("load", this[a].load), typeof h == "function" ? (this[a].load = h, this.addEventListener("load", h)) : this[a].load = null;
    }
    get onabort() {
      return s.brandCheck(this, c), this[a].abort;
    }
    set onabort(h) {
      s.brandCheck(this, c), this[a].abort && this.removeEventListener("abort", this[a].abort), typeof h == "function" ? (this[a].abort = h, this.addEventListener("abort", h)) : this[a].abort = null;
    }
  }
  return c.EMPTY = c.prototype.EMPTY = 0, c.LOADING = c.prototype.LOADING = 1, c.DONE = c.prototype.DONE = 2, Object.defineProperties(c.prototype, {
    EMPTY: r,
    LOADING: r,
    DONE: r,
    readAsArrayBuffer: l,
    readAsBinaryString: l,
    readAsText: l,
    readAsDataURL: l,
    abort: l,
    readyState: l,
    result: l,
    error: l,
    onloadstart: l,
    onprogress: l,
    onload: l,
    onabort: l,
    onerror: l,
    onloadend: l,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: !1,
      enumerable: !1,
      configurable: !0
    }
  }), Object.defineProperties(c, {
    EMPTY: r,
    LOADING: r,
    DONE: r
  }), So = {
    FileReader: c
  }, So;
}
var Uo, Yl;
function Ls() {
  return Yl || (Yl = 1, Uo = {
    kConstruct: Re.kConstruct
  }), Uo;
}
var Po, Jl;
function Td() {
  if (Jl)
    return Po;
  Jl = 1;
  const r = L, { URLSerializer: t } = JA(), { isValidHeaderName: e } = NA();
  function A(i, a, o = !1) {
    const s = t(i, o), l = t(a, o);
    return s === l;
  }
  function n(i) {
    r(i !== null);
    const a = [];
    for (let o of i.split(",")) {
      if (o = o.trim(), o.length) {
        if (!e(o))
          continue;
      } else
        continue;
      a.push(o);
    }
    return a;
  }
  return Po = {
    urlEquals: A,
    fieldValues: n
  }, Po;
}
var Mo, _l;
function Fd() {
  var f, p, ai, R, Vt, N, gg;
  if (_l)
    return Mo;
  _l = 1;
  const { kConstruct: r } = Ls(), { urlEquals: t, fieldValues: e } = Td(), { kEnumerableProperty: A, isDisturbed: n } = Ie, { kHeadersList: i } = Re, { webidl: a } = QA(), { Response: o, cloneResponse: s } = Ps(), { Request: l } = Ti(), { kState: c, kHeaders: u, kGuard: h, kRealm: g } = Ct(), { fetching: d } = Ms(), { urlIsHttpHttpsScheme: I, createDeferredPromise: y, readAllBytes: Q } = NA(), E = L, { getGlobalDispatcher: B } = dn, V = class V {
    constructor() {
      /**
       * @see https://w3c.github.io/ServiceWorker/#batch-cache-operations-algorithm
       * @param {CacheBatchOperation[]} operations
       * @returns {requestResponseList}
       */
      je(this, p);
      /**
       * @see https://w3c.github.io/ServiceWorker/#query-cache
       * @param {any} requestQuery
       * @param {import('../../types/cache').CacheQueryOptions} options
       * @param {requestResponseList} targetStorage
       * @returns {requestResponseList}
       */
      je(this, R);
      /**
       * @see https://w3c.github.io/ServiceWorker/#request-matches-cached-item-algorithm
       * @param {any} requestQuery
       * @param {any} request
       * @param {any | null} response
       * @param {import('../../types/cache').CacheQueryOptions | undefined} options
       * @returns {boolean}
       */
      je(this, N);
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-request-response-list
       * @type {requestResponseList}
       */
      je(this, f, void 0);
      arguments[0] !== r && a.illegalConstructor(), we(this, f, arguments[1]);
    }
    async match(_, X = {}) {
      a.brandCheck(this, V), a.argumentLengthCheck(arguments, 1, { header: "Cache.match" }), _ = a.converters.RequestInfo(_), X = a.converters.CacheQueryOptions(X);
      const te = await this.matchAll(_, X);
      if (te.length !== 0)
        return te[0];
    }
    async matchAll(_ = void 0, X = {}) {
      var b;
      a.brandCheck(this, V), _ !== void 0 && (_ = a.converters.RequestInfo(_)), X = a.converters.CacheQueryOptions(X);
      let te = null;
      if (_ !== void 0)
        if (_ instanceof l) {
          if (te = _[c], te.method !== "GET" && !X.ignoreMethod)
            return [];
        } else
          typeof _ == "string" && (te = new l(_)[c]);
      const ee = [];
      if (_ === void 0)
        for (const W of M(this, f))
          ee.push(W[1]);
      else {
        const W = TA(this, R, Vt).call(this, te, X);
        for (const v of W)
          ee.push(v[1]);
      }
      const Z = [];
      for (const W of ee) {
        const v = new o(((b = W.body) == null ? void 0 : b.source) ?? null), F = v[c].body;
        v[c] = W, v[c].body = F, v[u][i] = W.headersList, v[u][h] = "immutable", Z.push(v);
      }
      return Object.freeze(Z);
    }
    async add(_) {
      a.brandCheck(this, V), a.argumentLengthCheck(arguments, 1, { header: "Cache.add" }), _ = a.converters.RequestInfo(_);
      const X = [_];
      return await this.addAll(X);
    }
    async addAll(_) {
      a.brandCheck(this, V), a.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" }), _ = a.converters["sequence<RequestInfo>"](_);
      const X = [], te = [];
      for (const S of _) {
        if (typeof S == "string")
          continue;
        const U = S[c];
        if (!I(U.url) || U.method !== "GET")
          throw a.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme when method is not GET."
          });
      }
      const ee = [];
      for (const S of _) {
        const U = new l(S)[c];
        if (!I(U.url))
          throw a.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme."
          });
        U.initiator = "fetch", U.destination = "subresource", te.push(U);
        const Y = y();
        ee.push(d({
          request: U,
          dispatcher: B(),
          processResponse(O) {
            if (O.type === "error" || O.status === 206 || O.status < 200 || O.status > 299)
              Y.reject(a.errors.exception({
                header: "Cache.addAll",
                message: "Received an invalid status code or the request failed."
              }));
            else if (O.headersList.contains("vary")) {
              const j = e(O.headersList.get("vary"));
              for (const H of j)
                if (H === "*") {
                  Y.reject(a.errors.exception({
                    header: "Cache.addAll",
                    message: "invalid vary field value"
                  }));
                  for (const ie of ee)
                    ie.abort();
                  return;
                }
            }
          },
          processResponseEndOfBody(O) {
            if (O.aborted) {
              Y.reject(new DOMException("aborted", "AbortError"));
              return;
            }
            Y.resolve(O);
          }
        })), X.push(Y.promise);
      }
      const b = await Promise.all(X), W = [];
      let v = 0;
      for (const S of b) {
        const U = {
          type: "put",
          // 7.3.2
          request: te[v],
          // 7.3.3
          response: S
          // 7.3.4
        };
        W.push(U), v++;
      }
      const F = y();
      let T = null;
      try {
        TA(this, p, ai).call(this, W);
      } catch (S) {
        T = S;
      }
      return queueMicrotask(() => {
        T === null ? F.resolve(void 0) : F.reject(T);
      }), F.promise;
    }
    async put(_, X) {
      a.brandCheck(this, V), a.argumentLengthCheck(arguments, 2, { header: "Cache.put" }), _ = a.converters.RequestInfo(_), X = a.converters.Response(X);
      let te = null;
      if (_ instanceof l ? te = _[c] : te = new l(_)[c], !I(te.url) || te.method !== "GET")
        throw a.errors.exception({
          header: "Cache.put",
          message: "Expected an http/s scheme when method is not GET"
        });
      const ee = X[c];
      if (ee.status === 206)
        throw a.errors.exception({
          header: "Cache.put",
          message: "Got 206 status"
        });
      if (ee.headersList.contains("vary")) {
        const U = e(ee.headersList.get("vary"));
        for (const Y of U)
          if (Y === "*")
            throw a.errors.exception({
              header: "Cache.put",
              message: "Got * vary field value"
            });
      }
      if (ee.body && (n(ee.body.stream) || ee.body.stream.locked))
        throw a.errors.exception({
          header: "Cache.put",
          message: "Response body is locked or disturbed"
        });
      const Z = s(ee), b = y();
      if (ee.body != null) {
        const Y = ee.body.stream.getReader();
        Q(Y).then(b.resolve, b.reject);
      } else
        b.resolve(void 0);
      const W = [], v = {
        type: "put",
        // 14.
        request: te,
        // 15.
        response: Z
        // 16.
      };
      W.push(v);
      const F = await b.promise;
      Z.body != null && (Z.body.source = F);
      const T = y();
      let S = null;
      try {
        TA(this, p, ai).call(this, W);
      } catch (U) {
        S = U;
      }
      return queueMicrotask(() => {
        S === null ? T.resolve() : T.reject(S);
      }), T.promise;
    }
    async delete(_, X = {}) {
      a.brandCheck(this, V), a.argumentLengthCheck(arguments, 1, { header: "Cache.delete" }), _ = a.converters.RequestInfo(_), X = a.converters.CacheQueryOptions(X);
      let te = null;
      if (_ instanceof l) {
        if (te = _[c], te.method !== "GET" && !X.ignoreMethod)
          return !1;
      } else
        E(typeof _ == "string"), te = new l(_)[c];
      const ee = [], Z = {
        type: "delete",
        request: te,
        options: X
      };
      ee.push(Z);
      const b = y();
      let W = null, v;
      try {
        v = TA(this, p, ai).call(this, ee);
      } catch (F) {
        W = F;
      }
      return queueMicrotask(() => {
        W === null ? b.resolve(!!(v != null && v.length)) : b.reject(W);
      }), b.promise;
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cache-keys
     * @param {any} request
     * @param {import('../../types/cache').CacheQueryOptions} options
     * @returns {readonly Request[]}
     */
    async keys(_ = void 0, X = {}) {
      a.brandCheck(this, V), _ !== void 0 && (_ = a.converters.RequestInfo(_)), X = a.converters.CacheQueryOptions(X);
      let te = null;
      if (_ !== void 0)
        if (_ instanceof l) {
          if (te = _[c], te.method !== "GET" && !X.ignoreMethod)
            return [];
        } else
          typeof _ == "string" && (te = new l(_)[c]);
      const ee = y(), Z = [];
      if (_ === void 0)
        for (const b of M(this, f))
          Z.push(b[0]);
      else {
        const b = TA(this, R, Vt).call(this, te, X);
        for (const W of b)
          Z.push(W[0]);
      }
      return queueMicrotask(() => {
        const b = [];
        for (const W of Z) {
          const v = new l("https://a");
          v[c] = W, v[u][i] = W.headersList, v[u][h] = "immutable", v[g] = W.client, b.push(v);
        }
        ee.resolve(Object.freeze(b));
      }), ee.promise;
    }
  };
  f = new WeakMap(), p = new WeakSet(), ai = function(_) {
    const X = M(this, f), te = [...X], ee = [], Z = [];
    try {
      for (const b of _) {
        if (b.type !== "delete" && b.type !== "put")
          throw a.errors.exception({
            header: "Cache.#batchCacheOperations",
            message: 'operation type does not match "delete" or "put"'
          });
        if (b.type === "delete" && b.response != null)
          throw a.errors.exception({
            header: "Cache.#batchCacheOperations",
            message: "delete operation should not have an associated response"
          });
        if (TA(this, R, Vt).call(this, b.request, b.options, ee).length)
          throw new DOMException("???", "InvalidStateError");
        let W;
        if (b.type === "delete") {
          if (W = TA(this, R, Vt).call(this, b.request, b.options), W.length === 0)
            return [];
          for (const v of W) {
            const F = X.indexOf(v);
            E(F !== -1), X.splice(F, 1);
          }
        } else if (b.type === "put") {
          if (b.response == null)
            throw a.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "put operation should have an associated response"
            });
          const v = b.request;
          if (!I(v.url))
            throw a.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "expected http or https scheme"
            });
          if (v.method !== "GET")
            throw a.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "not get method"
            });
          if (b.options != null)
            throw a.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: "options must not be defined"
            });
          W = TA(this, R, Vt).call(this, b.request);
          for (const F of W) {
            const T = X.indexOf(F);
            E(T !== -1), X.splice(T, 1);
          }
          X.push([b.request, b.response]), ee.push([b.request, b.response]);
        }
        Z.push([b.request, b.response]);
      }
      return Z;
    } catch (b) {
      throw M(this, f).length = 0, we(this, f, te), b;
    }
  }, R = new WeakSet(), Vt = function(_, X, te) {
    const ee = [], Z = te ?? M(this, f);
    for (const b of Z) {
      const [W, v] = b;
      TA(this, N, gg).call(this, _, W, v, X) && ee.push(b);
    }
    return ee;
  }, N = new WeakSet(), gg = function(_, X, te = null, ee) {
    const Z = new URL(_.url), b = new URL(X.url);
    if (ee != null && ee.ignoreSearch && (b.search = "", Z.search = ""), !t(Z, b, !0))
      return !1;
    if (te == null || ee != null && ee.ignoreVary || !te.headersList.contains("vary"))
      return !0;
    const W = e(te.headersList.get("vary"));
    for (const v of W) {
      if (v === "*")
        return !1;
      const F = X.headersList.get(v), T = _.headersList.get(v);
      if (F !== T)
        return !1;
    }
    return !0;
  };
  let w = V;
  Object.defineProperties(w.prototype, {
    [Symbol.toStringTag]: {
      value: "Cache",
      configurable: !0
    },
    match: A,
    matchAll: A,
    add: A,
    addAll: A,
    put: A,
    delete: A,
    keys: A
  });
  const C = [
    {
      key: "ignoreSearch",
      converter: a.converters.boolean,
      defaultValue: !1
    },
    {
      key: "ignoreMethod",
      converter: a.converters.boolean,
      defaultValue: !1
    },
    {
      key: "ignoreVary",
      converter: a.converters.boolean,
      defaultValue: !1
    }
  ];
  return a.converters.CacheQueryOptions = a.dictionaryConverter(C), a.converters.MultiCacheQueryOptions = a.dictionaryConverter([
    ...C,
    {
      key: "cacheName",
      converter: a.converters.DOMString
    }
  ]), a.converters.Response = a.interfaceConverter(o), a.converters["sequence<RequestInfo>"] = a.sequenceConverter(
    a.converters.RequestInfo
  ), Mo = {
    Cache: w
  }, Mo;
}
var Lo, xl;
function Rd() {
  var i;
  if (xl)
    return Lo;
  xl = 1;
  const { kConstruct: r } = Ls(), { Cache: t } = Fd(), { webidl: e } = QA(), { kEnumerableProperty: A } = Ie, a = class a {
    constructor() {
      /**
       * @see https://w3c.github.io/ServiceWorker/#dfn-relevant-name-to-cache-map
       * @type {Map<string, import('./cache').requestResponseList}
       */
      je(this, i, /* @__PURE__ */ new Map());
      arguments[0] !== r && e.illegalConstructor();
    }
    async match(s, l = {}) {
      if (e.brandCheck(this, a), e.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" }), s = e.converters.RequestInfo(s), l = e.converters.MultiCacheQueryOptions(l), l.cacheName != null) {
        if (M(this, i).has(l.cacheName)) {
          const c = M(this, i).get(l.cacheName);
          return await new t(r, c).match(s, l);
        }
      } else
        for (const c of M(this, i).values()) {
          const h = await new t(r, c).match(s, l);
          if (h !== void 0)
            return h;
        }
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-has
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async has(s) {
      return e.brandCheck(this, a), e.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" }), s = e.converters.DOMString(s), M(this, i).has(s);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#dom-cachestorage-open
     * @param {string} cacheName
     * @returns {Promise<Cache>}
     */
    async open(s) {
      if (e.brandCheck(this, a), e.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" }), s = e.converters.DOMString(s), M(this, i).has(s)) {
        const c = M(this, i).get(s);
        return new t(r, c);
      }
      const l = [];
      return M(this, i).set(s, l), new t(r, l);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-delete
     * @param {string} cacheName
     * @returns {Promise<boolean>}
     */
    async delete(s) {
      return e.brandCheck(this, a), e.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" }), s = e.converters.DOMString(s), M(this, i).delete(s);
    }
    /**
     * @see https://w3c.github.io/ServiceWorker/#cache-storage-keys
     * @returns {string[]}
     */
    async keys() {
      return e.brandCheck(this, a), [...M(this, i).keys()];
    }
  };
  i = new WeakMap();
  let n = a;
  return Object.defineProperties(n.prototype, {
    [Symbol.toStringTag]: {
      value: "CacheStorage",
      configurable: !0
    },
    match: A,
    has: A,
    open: A,
    delete: A,
    keys: A
  }), Lo = {
    CacheStorage: n
  }, Lo;
}
var Ho, Ol;
function Dd() {
  return Ol || (Ol = 1, Ho = {
    maxAttributeValueSize: 1024,
    maxNameValuePairSize: 4096
  }), Ho;
}
var Go, ql;
function Eg() {
  if (ql)
    return Go;
  ql = 1;
  const r = L, { kHeadersList: t } = Re;
  function e(h) {
    if (h.length === 0)
      return !1;
    for (const g of h) {
      const d = g.charCodeAt(0);
      if (d >= 0 || d <= 8 || d >= 10 || d <= 31 || d === 127)
        return !1;
    }
  }
  function A(h) {
    for (const g of h) {
      const d = g.charCodeAt(0);
      if (d <= 32 || d > 127 || g === "(" || g === ")" || g === ">" || g === "<" || g === "@" || g === "," || g === ";" || g === ":" || g === "\\" || g === '"' || g === "/" || g === "[" || g === "]" || g === "?" || g === "=" || g === "{" || g === "}")
        throw new Error("Invalid cookie name");
    }
  }
  function n(h) {
    for (const g of h) {
      const d = g.charCodeAt(0);
      if (d < 33 || // exclude CTLs (0-31)
      d === 34 || d === 44 || d === 59 || d === 92 || d > 126)
        throw new Error("Invalid header value");
    }
  }
  function i(h) {
    for (const g of h)
      if (g.charCodeAt(0) < 33 || g === ";")
        throw new Error("Invalid cookie path");
  }
  function a(h) {
    if (h.startsWith("-") || h.endsWith(".") || h.endsWith("-"))
      throw new Error("Invalid cookie domain");
  }
  function o(h) {
    typeof h == "number" && (h = new Date(h));
    const g = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ], d = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ], I = g[h.getUTCDay()], y = h.getUTCDate().toString().padStart(2, "0"), Q = d[h.getUTCMonth()], E = h.getUTCFullYear(), B = h.getUTCHours().toString().padStart(2, "0"), w = h.getUTCMinutes().toString().padStart(2, "0"), C = h.getUTCSeconds().toString().padStart(2, "0");
    return `${I}, ${y} ${Q} ${E} ${B}:${w}:${C} GMT`;
  }
  function s(h) {
    if (h < 0)
      throw new Error("Invalid cookie max-age");
  }
  function l(h) {
    if (h.name.length === 0)
      return null;
    A(h.name), n(h.value);
    const g = [`${h.name}=${h.value}`];
    h.name.startsWith("__Secure-") && (h.secure = !0), h.name.startsWith("__Host-") && (h.secure = !0, h.domain = null, h.path = "/"), h.secure && g.push("Secure"), h.httpOnly && g.push("HttpOnly"), typeof h.maxAge == "number" && (s(h.maxAge), g.push(`Max-Age=${h.maxAge}`)), h.domain && (a(h.domain), g.push(`Domain=${h.domain}`)), h.path && (i(h.path), g.push(`Path=${h.path}`)), h.expires && h.expires.toString() !== "Invalid Date" && g.push(`Expires=${o(h.expires)}`), h.sameSite && g.push(`SameSite=${h.sameSite}`);
    for (const d of h.unparsed) {
      if (!d.includes("="))
        throw new Error("Invalid unparsed");
      const [I, ...y] = d.split("=");
      g.push(`${I.trim()}=${y.join("=")}`);
    }
    return g.join("; ");
  }
  let c;
  function u(h) {
    if (h[t])
      return h[t];
    c || (c = Object.getOwnPropertySymbols(h).find(
      (d) => d.description === "headers list"
    ), r(c, "Headers cannot be parsed"));
    const g = h[c];
    return r(g), g;
  }
  return Go = {
    isCTLExcludingHtab: e,
    stringify: l,
    getHeadersList: u
  }, Go;
}
var Wo, jl;
function Nd() {
  if (jl)
    return Wo;
  jl = 1;
  const { maxNameValuePairSize: r, maxAttributeValueSize: t } = Dd(), { isCTLExcludingHtab: e } = Eg(), { collectASequenceOfCodePointsFast: A } = JA(), n = L;
  function i(o) {
    if (e(o))
      return null;
    let s = "", l = "", c = "", u = "";
    if (o.includes(";")) {
      const h = { position: 0 };
      s = A(";", o, h), l = o.slice(h.position);
    } else
      s = o;
    if (!s.includes("="))
      u = s;
    else {
      const h = { position: 0 };
      c = A(
        "=",
        s,
        h
      ), u = s.slice(h.position + 1);
    }
    return c = c.trim(), u = u.trim(), c.length + u.length > r ? null : {
      name: c,
      value: u,
      ...a(l)
    };
  }
  function a(o, s = {}) {
    if (o.length === 0)
      return s;
    n(o[0] === ";"), o = o.slice(1);
    let l = "";
    o.includes(";") ? (l = A(
      ";",
      o,
      { position: 0 }
    ), o = o.slice(l.length)) : (l = o, o = "");
    let c = "", u = "";
    if (l.includes("=")) {
      const g = { position: 0 };
      c = A(
        "=",
        l,
        g
      ), u = l.slice(g.position + 1);
    } else
      c = l;
    if (c = c.trim(), u = u.trim(), u.length > t)
      return a(o, s);
    const h = c.toLowerCase();
    if (h === "expires") {
      const g = new Date(u);
      s.expires = g;
    } else if (h === "max-age") {
      const g = u.charCodeAt(0);
      if ((g < 48 || g > 57) && u[0] !== "-" || !/^\d+$/.test(u))
        return a(o, s);
      const d = Number(u);
      s.maxAge = d;
    } else if (h === "domain") {
      let g = u;
      g[0] === "." && (g = g.slice(1)), g = g.toLowerCase(), s.domain = g;
    } else if (h === "path") {
      let g = "";
      u.length === 0 || u[0] !== "/" ? g = "/" : g = u, s.path = g;
    } else if (h === "secure")
      s.secure = !0;
    else if (h === "httponly")
      s.httpOnly = !0;
    else if (h === "samesite") {
      let g = "Default";
      const d = u.toLowerCase();
      d.includes("none") && (g = "None"), d.includes("strict") && (g = "Strict"), d.includes("lax") && (g = "Lax"), s.sameSite = g;
    } else
      s.unparsed ?? (s.unparsed = []), s.unparsed.push(`${c}=${u}`);
    return a(o, s);
  }
  return Wo = {
    parseSetCookie: i,
    parseUnparsedAttributes: a
  }, Wo;
}
var Yo, Vl;
function Sd() {
  if (Vl)
    return Yo;
  Vl = 1;
  const { parseSetCookie: r } = Nd(), { stringify: t, getHeadersList: e } = Eg(), { webidl: A } = QA(), { Headers: n } = sr();
  function i(l) {
    A.argumentLengthCheck(arguments, 1, { header: "getCookies" }), A.brandCheck(l, n, { strict: !1 });
    const c = l.get("cookie"), u = {};
    if (!c)
      return u;
    for (const h of c.split(";")) {
      const [g, ...d] = h.split("=");
      u[g.trim()] = d.join("=");
    }
    return u;
  }
  function a(l, c, u) {
    A.argumentLengthCheck(arguments, 2, { header: "deleteCookie" }), A.brandCheck(l, n, { strict: !1 }), c = A.converters.DOMString(c), u = A.converters.DeleteCookieAttributes(u), s(l, {
      name: c,
      value: "",
      expires: /* @__PURE__ */ new Date(0),
      ...u
    });
  }
  function o(l) {
    A.argumentLengthCheck(arguments, 1, { header: "getSetCookies" }), A.brandCheck(l, n, { strict: !1 });
    const c = e(l).cookies;
    return c ? c.map((u) => r(Array.isArray(u) ? u[1] : u)) : [];
  }
  function s(l, c) {
    A.argumentLengthCheck(arguments, 2, { header: "setCookie" }), A.brandCheck(l, n, { strict: !1 }), c = A.converters.Cookie(c), t(c) && l.append("Set-Cookie", t(c));
  }
  return A.converters.DeleteCookieAttributes = A.dictionaryConverter([
    {
      converter: A.nullableConverter(A.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: A.nullableConverter(A.converters.DOMString),
      key: "domain",
      defaultValue: null
    }
  ]), A.converters.Cookie = A.dictionaryConverter([
    {
      converter: A.converters.DOMString,
      key: "name"
    },
    {
      converter: A.converters.DOMString,
      key: "value"
    },
    {
      converter: A.nullableConverter((l) => typeof l == "number" ? A.converters["unsigned long long"](l) : new Date(l)),
      key: "expires",
      defaultValue: null
    },
    {
      converter: A.nullableConverter(A.converters["long long"]),
      key: "maxAge",
      defaultValue: null
    },
    {
      converter: A.nullableConverter(A.converters.DOMString),
      key: "domain",
      defaultValue: null
    },
    {
      converter: A.nullableConverter(A.converters.DOMString),
      key: "path",
      defaultValue: null
    },
    {
      converter: A.nullableConverter(A.converters.boolean),
      key: "secure",
      defaultValue: null
    },
    {
      converter: A.nullableConverter(A.converters.boolean),
      key: "httpOnly",
      defaultValue: null
    },
    {
      converter: A.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"]
    },
    {
      converter: A.sequenceConverter(A.converters.DOMString),
      key: "unparsed",
      defaultValue: []
    }
  ]), Yo = {
    getCookies: i,
    deleteCookie: a,
    getSetCookies: o,
    setCookie: s
  }, Yo;
}
var Jo, $l;
function pn() {
  if ($l)
    return Jo;
  $l = 1;
  const r = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11", t = {
    enumerable: !0,
    writable: !1,
    configurable: !1
  }, e = {
    CONNECTING: 0,
    OPEN: 1,
    CLOSING: 2,
    CLOSED: 3
  }, A = {
    CONTINUATION: 0,
    TEXT: 1,
    BINARY: 2,
    CLOSE: 8,
    PING: 9,
    PONG: 10
  }, n = 2 ** 16 - 1, i = {
    INFO: 0,
    PAYLOADLENGTH_16: 2,
    PAYLOADLENGTH_64: 3,
    READ_DATA: 4
  }, a = Buffer.allocUnsafe(0);
  return Jo = {
    uid: r,
    staticPropertyDescriptors: t,
    states: e,
    opcodes: A,
    maxUnsigned16Bit: n,
    parserStates: i,
    emptyBuffer: a
  }, Jo;
}
var _o, Xl;
function Fi() {
  return Xl || (Xl = 1, _o = {
    kWebSocketURL: Symbol("url"),
    kReadyState: Symbol("ready state"),
    kController: Symbol("controller"),
    kResponse: Symbol("response"),
    kBinaryType: Symbol("binary type"),
    kSentClose: Symbol("sent close"),
    kReceivedClose: Symbol("received close"),
    kByteParser: Symbol("byte parser")
  }), _o;
}
var xo, Zl;
function Cg() {
  var o, l, u;
  if (Zl)
    return xo;
  Zl = 1;
  const { webidl: r } = QA(), { kEnumerableProperty: t } = Ie, { MessagePort: e } = L, s = class s extends Event {
    constructor(I, y = {}) {
      r.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" }), I = r.converters.DOMString(I), y = r.converters.MessageEventInit(y);
      super(I, y);
      je(this, o, void 0);
      we(this, o, y);
    }
    get data() {
      return r.brandCheck(this, s), M(this, o).data;
    }
    get origin() {
      return r.brandCheck(this, s), M(this, o).origin;
    }
    get lastEventId() {
      return r.brandCheck(this, s), M(this, o).lastEventId;
    }
    get source() {
      return r.brandCheck(this, s), M(this, o).source;
    }
    get ports() {
      return r.brandCheck(this, s), Object.isFrozen(M(this, o).ports) || Object.freeze(M(this, o).ports), M(this, o).ports;
    }
    initMessageEvent(I, y = !1, Q = !1, E = null, B = "", w = "", C = null, f = []) {
      return r.brandCheck(this, s), r.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" }), new s(I, {
        bubbles: y,
        cancelable: Q,
        data: E,
        origin: B,
        lastEventId: w,
        source: C,
        ports: f
      });
    }
  };
  o = new WeakMap();
  let A = s;
  const c = class c extends Event {
    constructor(I, y = {}) {
      r.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" }), I = r.converters.DOMString(I), y = r.converters.CloseEventInit(y);
      super(I, y);
      je(this, l, void 0);
      we(this, l, y);
    }
    get wasClean() {
      return r.brandCheck(this, c), M(this, l).wasClean;
    }
    get code() {
      return r.brandCheck(this, c), M(this, l).code;
    }
    get reason() {
      return r.brandCheck(this, c), M(this, l).reason;
    }
  };
  l = new WeakMap();
  let n = c;
  const h = class h extends Event {
    constructor(I, y) {
      r.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
      super(I, y);
      je(this, u, void 0);
      I = r.converters.DOMString(I), y = r.converters.ErrorEventInit(y ?? {}), we(this, u, y);
    }
    get message() {
      return r.brandCheck(this, h), M(this, u).message;
    }
    get filename() {
      return r.brandCheck(this, h), M(this, u).filename;
    }
    get lineno() {
      return r.brandCheck(this, h), M(this, u).lineno;
    }
    get colno() {
      return r.brandCheck(this, h), M(this, u).colno;
    }
    get error() {
      return r.brandCheck(this, h), M(this, u).error;
    }
  };
  u = new WeakMap();
  let i = h;
  Object.defineProperties(A.prototype, {
    [Symbol.toStringTag]: {
      value: "MessageEvent",
      configurable: !0
    },
    data: t,
    origin: t,
    lastEventId: t,
    source: t,
    ports: t,
    initMessageEvent: t
  }), Object.defineProperties(n.prototype, {
    [Symbol.toStringTag]: {
      value: "CloseEvent",
      configurable: !0
    },
    reason: t,
    code: t,
    wasClean: t
  }), Object.defineProperties(i.prototype, {
    [Symbol.toStringTag]: {
      value: "ErrorEvent",
      configurable: !0
    },
    message: t,
    filename: t,
    lineno: t,
    colno: t,
    error: t
  }), r.converters.MessagePort = r.interfaceConverter(e), r.converters["sequence<MessagePort>"] = r.sequenceConverter(
    r.converters.MessagePort
  );
  const a = [
    {
      key: "bubbles",
      converter: r.converters.boolean,
      defaultValue: !1
    },
    {
      key: "cancelable",
      converter: r.converters.boolean,
      defaultValue: !1
    },
    {
      key: "composed",
      converter: r.converters.boolean,
      defaultValue: !1
    }
  ];
  return r.converters.MessageEventInit = r.dictionaryConverter([
    ...a,
    {
      key: "data",
      converter: r.converters.any,
      defaultValue: null
    },
    {
      key: "origin",
      converter: r.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lastEventId",
      converter: r.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "source",
      // Node doesn't implement WindowProxy or ServiceWorker, so the only
      // valid value for source is a MessagePort.
      converter: r.nullableConverter(r.converters.MessagePort),
      defaultValue: null
    },
    {
      key: "ports",
      converter: r.converters["sequence<MessagePort>"],
      get defaultValue() {
        return [];
      }
    }
  ]), r.converters.CloseEventInit = r.dictionaryConverter([
    ...a,
    {
      key: "wasClean",
      converter: r.converters.boolean,
      defaultValue: !1
    },
    {
      key: "code",
      converter: r.converters["unsigned short"],
      defaultValue: 0
    },
    {
      key: "reason",
      converter: r.converters.USVString,
      defaultValue: ""
    }
  ]), r.converters.ErrorEventInit = r.dictionaryConverter([
    ...a,
    {
      key: "message",
      converter: r.converters.DOMString,
      defaultValue: ""
    },
    {
      key: "filename",
      converter: r.converters.USVString,
      defaultValue: ""
    },
    {
      key: "lineno",
      converter: r.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "colno",
      converter: r.converters["unsigned long"],
      defaultValue: 0
    },
    {
      key: "error",
      converter: r.converters.any
    }
  ]), xo = {
    MessageEvent: A,
    CloseEvent: n,
    ErrorEvent: i
  }, xo;
}
var Oo, Kl;
function Hs() {
  if (Kl)
    return Oo;
  Kl = 1;
  const { kReadyState: r, kController: t, kResponse: e, kBinaryType: A, kWebSocketURL: n } = Fi(), { states: i, opcodes: a } = pn(), { MessageEvent: o, ErrorEvent: s } = Cg();
  function l(Q) {
    return Q[r] === i.OPEN;
  }
  function c(Q) {
    return Q[r] === i.CLOSING;
  }
  function u(Q) {
    return Q[r] === i.CLOSED;
  }
  function h(Q, E, B = Event, w) {
    const C = new B(Q, w);
    E.dispatchEvent(C);
  }
  function g(Q, E, B) {
    if (Q[r] !== i.OPEN)
      return;
    let w;
    if (E === a.TEXT)
      try {
        w = new TextDecoder("utf-8", { fatal: !0 }).decode(B);
      } catch {
        y(Q, "Received invalid UTF-8 in text frame.");
        return;
      }
    else
      E === a.BINARY && (Q[A] === "blob" ? w = new Blob([B]) : w = new Uint8Array(B).buffer);
    h("message", Q, o, {
      origin: Q[n].origin,
      data: w
    });
  }
  function d(Q) {
    if (Q.length === 0)
      return !1;
    for (const E of Q) {
      const B = E.charCodeAt(0);
      if (B < 33 || B > 126 || E === "(" || E === ")" || E === "<" || E === ">" || E === "@" || E === "," || E === ";" || E === ":" || E === "\\" || E === '"' || E === "/" || E === "[" || E === "]" || E === "?" || E === "=" || E === "{" || E === "}" || B === 32 || // SP
      B === 9)
        return !1;
    }
    return !0;
  }
  function I(Q) {
    return Q >= 1e3 && Q < 1015 ? Q !== 1004 && // reserved
    Q !== 1005 && // "MUST NOT be set as a status code"
    Q !== 1006 : Q >= 3e3 && Q <= 4999;
  }
  function y(Q, E) {
    const { [t]: B, [e]: w } = Q;
    B.abort(), w != null && w.socket && !w.socket.destroyed && w.socket.destroy(), E && h("error", Q, s, {
      error: new Error(E)
    });
  }
  return Oo = {
    isEstablished: l,
    isClosing: c,
    isClosed: u,
    fireEvent: h,
    isValidSubprotocol: d,
    isValidStatusCode: I,
    failWebsocketConnection: y,
    websocketMessageReceived: g
  }, Oo;
}
var qo, zl;
function Ud() {
  if (zl)
    return qo;
  zl = 1;
  const r = L, { uid: t, states: e } = pn(), {
    kReadyState: A,
    kSentClose: n,
    kByteParser: i,
    kReceivedClose: a
  } = Fi(), { fireEvent: o, failWebsocketConnection: s } = Hs(), { CloseEvent: l } = Cg(), { makeRequest: c } = Ti(), { fetching: u } = Ms(), { Headers: h } = sr(), { getGlobalDispatcher: g } = dn, { kHeadersList: d } = Re, I = {};
  I.open = r.channel("undici:websocket:open"), I.close = r.channel("undici:websocket:close"), I.socketError = r.channel("undici:websocket:socket_error");
  let y;
  try {
    y = L;
  } catch {
  }
  function Q(C, f, p, m, R) {
    const P = C;
    P.protocol = C.protocol === "ws:" ? "http:" : "https:";
    const N = c({
      urlList: [P],
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error"
    });
    if (R.headers) {
      const _ = new h(R.headers)[d];
      N.headersList = _;
    }
    const $ = y.randomBytes(16).toString("base64");
    N.headersList.append("sec-websocket-key", $), N.headersList.append("sec-websocket-version", "13");
    for (const _ of f)
      N.headersList.append("sec-websocket-protocol", _);
    const V = "";
    return u({
      request: N,
      useParallelQueue: !0,
      dispatcher: R.dispatcher ?? g(),
      processResponse(_) {
        var b, W;
        if (_.type === "error" || _.status !== 101) {
          s(p, "Received network error or non-101 status code.");
          return;
        }
        if (f.length !== 0 && !_.headersList.get("Sec-WebSocket-Protocol")) {
          s(p, "Server did not respond with sent protocols.");
          return;
        }
        if (((b = _.headersList.get("Upgrade")) == null ? void 0 : b.toLowerCase()) !== "websocket") {
          s(p, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (((W = _.headersList.get("Connection")) == null ? void 0 : W.toLowerCase()) !== "upgrade") {
          s(p, 'Server did not set Connection header to "upgrade".');
          return;
        }
        const X = _.headersList.get("Sec-WebSocket-Accept"), te = y.createHash("sha1").update($ + t).digest("base64");
        if (X !== te) {
          s(p, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        const ee = _.headersList.get("Sec-WebSocket-Extensions");
        if (ee !== null && ee !== V) {
          s(p, "Received different permessage-deflate than the one set.");
          return;
        }
        const Z = _.headersList.get("Sec-WebSocket-Protocol");
        if (Z !== null && Z !== N.headersList.get("Sec-WebSocket-Protocol")) {
          s(p, "Protocol was not set in the opening handshake.");
          return;
        }
        _.socket.on("data", E), _.socket.on("close", B), _.socket.on("error", w), I.open.hasSubscribers && I.open.publish({
          address: _.socket.address(),
          protocol: Z,
          extensions: ee
        }), m(_);
      }
    });
  }
  function E(C) {
    this.ws[i].write(C) || this.pause();
  }
  function B() {
    const { ws: C } = this, f = C[n] && C[a];
    let p = 1005, m = "";
    const R = C[i].closingInfo;
    R ? (p = R.code ?? 1005, m = R.reason) : C[n] || (p = 1006), C[A] = e.CLOSED, o("close", C, l, {
      wasClean: f,
      code: p,
      reason: m
    }), I.close.hasSubscribers && I.close.publish({
      websocket: C,
      code: p,
      reason: m
    });
  }
  function w(C) {
    const { ws: f } = this;
    f[A] = e.CLOSING, I.socketError.hasSubscribers && I.socketError.publish(C), this.destroy();
  }
  return qo = {
    establishWebSocketConnection: Q
  }, qo;
}
var jo, eu;
function fg() {
  if (eu)
    return jo;
  eu = 1;
  const { maxUnsigned16Bit: r } = pn();
  let t;
  try {
    t = L;
  } catch {
  }
  class e {
    /**
     * @param {Buffer|undefined} data
     */
    constructor(n) {
      this.frameData = n, this.maskKey = t.randomBytes(4);
    }
    createFrame(n) {
      var l;
      const i = ((l = this.frameData) == null ? void 0 : l.byteLength) ?? 0;
      let a = i, o = 6;
      i > r ? (o += 8, a = 127) : i > 125 && (o += 2, a = 126);
      const s = Buffer.allocUnsafe(i + o);
      s[0] = s[1] = 0, s[0] |= 128, s[0] = (s[0] & 240) + n;
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */
      s[o - 4] = this.maskKey[0], s[o - 3] = this.maskKey[1], s[o - 2] = this.maskKey[2], s[o - 1] = this.maskKey[3], s[1] = a, a === 126 ? s.writeUInt16BE(i, 2) : a === 127 && (s[2] = s[3] = 0, s.writeUIntBE(i, 4, 6)), s[1] |= 128;
      for (let c = 0; c < i; c++)
        s[o + c] = this.frameData[c] ^ this.maskKey[c % 4];
      return s;
    }
  }
  return jo = {
    WebsocketFrameSend: e
  }, jo;
}
var Vo, Au;
function Pd() {
  var y, Q, E, B, w;
  if (Au)
    return Vo;
  Au = 1;
  const { Writable: r } = L, t = L, { parserStates: e, opcodes: A, states: n, emptyBuffer: i } = pn(), { kReadyState: a, kSentClose: o, kResponse: s, kReceivedClose: l } = Fi(), { isValidStatusCode: c, failWebsocketConnection: u, websocketMessageReceived: h } = Hs(), { WebsocketFrameSend: g } = fg(), d = {};
  d.ping = t.channel("undici:websocket:ping"), d.pong = t.channel("undici:websocket:pong");
  class I extends r {
    constructor(p) {
      super();
      je(this, y, []);
      je(this, Q, 0);
      je(this, E, e.INFO);
      je(this, B, {});
      je(this, w, []);
      this.ws = p;
    }
    /**
     * @param {Buffer} chunk
     * @param {() => void} callback
     */
    _write(p, m, R) {
      M(this, y).push(p), we(this, Q, M(this, Q) + p.length), this.run(R);
    }
    /**
     * Runs whenever a new chunk is received.
     * Callback is called whenever there are no more chunks buffering,
     * or not enough bytes are buffered to parse.
     */
    run(p) {
      var m;
      for (; ; ) {
        if (M(this, E) === e.INFO) {
          if (M(this, Q) < 2)
            return p();
          const R = this.consume(2);
          if (M(this, B).fin = (R[0] & 128) !== 0, M(this, B).opcode = R[0] & 15, (m = M(this, B)).originalOpcode ?? (m.originalOpcode = M(this, B).opcode), M(this, B).fragmented = !M(this, B).fin && M(this, B).opcode !== A.CONTINUATION, M(this, B).fragmented && M(this, B).opcode !== A.BINARY && M(this, B).opcode !== A.TEXT) {
            u(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          const P = R[1] & 127;
          if (P <= 125 ? (M(this, B).payloadLength = P, we(this, E, e.READ_DATA)) : P === 126 ? we(this, E, e.PAYLOADLENGTH_16) : P === 127 && we(this, E, e.PAYLOADLENGTH_64), M(this, B).fragmented && P > 125) {
            u(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          } else if ((M(this, B).opcode === A.PING || M(this, B).opcode === A.PONG || M(this, B).opcode === A.CLOSE) && P > 125) {
            u(this.ws, "Payload length for control frame exceeded 125 bytes.");
            return;
          } else if (M(this, B).opcode === A.CLOSE) {
            if (P === 1) {
              u(this.ws, "Received close frame with a 1-byte body.");
              return;
            }
            const N = this.consume(P);
            if (M(this, B).closeInfo = this.parseCloseBody(!1, N), !this.ws[o]) {
              const $ = Buffer.allocUnsafe(2);
              $.writeUInt16BE(M(this, B).closeInfo.code, 0);
              const V = new g($);
              this.ws[s].socket.write(
                V.createFrame(A.CLOSE),
                (ne) => {
                  ne || (this.ws[o] = !0);
                }
              );
            }
            this.ws[a] = n.CLOSING, this.ws[l] = !0, this.end();
            return;
          } else if (M(this, B).opcode === A.PING) {
            const N = this.consume(P);
            if (!this.ws[l]) {
              const $ = new g(N);
              this.ws[s].socket.write($.createFrame(A.PONG)), d.ping.hasSubscribers && d.ping.publish({
                payload: N
              });
            }
            if (we(this, E, e.INFO), M(this, Q) > 0)
              continue;
            p();
            return;
          } else if (M(this, B).opcode === A.PONG) {
            const N = this.consume(P);
            if (d.pong.hasSubscribers && d.pong.publish({
              payload: N
            }), M(this, Q) > 0)
              continue;
            p();
            return;
          }
        } else if (M(this, E) === e.PAYLOADLENGTH_16) {
          if (M(this, Q) < 2)
            return p();
          const R = this.consume(2);
          M(this, B).payloadLength = R.readUInt16BE(0), we(this, E, e.READ_DATA);
        } else if (M(this, E) === e.PAYLOADLENGTH_64) {
          if (M(this, Q) < 8)
            return p();
          const R = this.consume(8), P = R.readUInt32BE(0);
          if (P > 2 ** 31 - 1) {
            u(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          const N = R.readUInt32BE(4);
          M(this, B).payloadLength = (P << 8) + N, we(this, E, e.READ_DATA);
        } else if (M(this, E) === e.READ_DATA) {
          if (M(this, Q) < M(this, B).payloadLength)
            return p();
          if (M(this, Q) >= M(this, B).payloadLength) {
            const R = this.consume(M(this, B).payloadLength);
            if (M(this, w).push(R), !M(this, B).fragmented || M(this, B).fin && M(this, B).opcode === A.CONTINUATION) {
              const P = Buffer.concat(M(this, w));
              h(this.ws, M(this, B).originalOpcode, P), we(this, B, {}), M(this, w).length = 0;
            }
            we(this, E, e.INFO);
          }
        }
        if (!(M(this, Q) > 0)) {
          p();
          break;
        }
      }
    }
    /**
     * Take n bytes from the buffered Buffers
     * @param {number} n
     * @returns {Buffer|null}
     */
    consume(p) {
      if (p > M(this, Q))
        return null;
      if (p === 0)
        return i;
      if (M(this, y)[0].length === p)
        return we(this, Q, M(this, Q) - M(this, y)[0].length), M(this, y).shift();
      const m = Buffer.allocUnsafe(p);
      let R = 0;
      for (; R !== p; ) {
        const P = M(this, y)[0], { length: N } = P;
        if (N + R === p) {
          m.set(M(this, y).shift(), R);
          break;
        } else if (N + R > p) {
          m.set(P.subarray(0, p - R), R), M(this, y)[0] = P.subarray(p - R);
          break;
        } else
          m.set(M(this, y).shift(), R), R += P.length;
      }
      return we(this, Q, M(this, Q) - p), m;
    }
    parseCloseBody(p, m) {
      let R;
      if (m.length >= 2 && (R = m.readUInt16BE(0)), p)
        return c(R) ? { code: R } : null;
      let P = m.subarray(2);
      if (P[0] === 239 && P[1] === 187 && P[2] === 191 && (P = P.subarray(3)), R !== void 0 && !c(R))
        return null;
      try {
        P = new TextDecoder("utf-8", { fatal: !0 }).decode(P);
      } catch {
        return null;
      }
      return { code: R, reason: P };
    }
    get closingInfo() {
      return M(this, B).closeInfo;
    }
  }
  return y = new WeakMap(), Q = new WeakMap(), E = new WeakMap(), B = new WeakMap(), w = new WeakMap(), Vo = {
    ByteParser: I
  }, Vo;
}
var $o, tu;
function Md() {
  var V, ne, _, X, te, Qg;
  if (tu)
    return $o;
  tu = 1;
  const { webidl: r } = QA(), { DOMException: t } = Mt(), { URLSerializer: e } = JA(), { getGlobalOrigin: A } = fn(), { staticPropertyDescriptors: n, states: i, opcodes: a, emptyBuffer: o } = pn(), {
    kWebSocketURL: s,
    kReadyState: l,
    kController: c,
    kBinaryType: u,
    kResponse: h,
    kSentClose: g,
    kByteParser: d
  } = Fi(), { isEstablished: I, isClosing: y, isValidSubprotocol: Q, failWebsocketConnection: E, fireEvent: B } = Hs(), { establishWebSocketConnection: w } = Ud(), { WebsocketFrameSend: C } = fg(), { ByteParser: f } = Pd(), { kEnumerableProperty: p, isBlobLike: m } = Ie, { getGlobalDispatcher: R } = dn, { types: P } = L;
  let N = !1;
  const Z = class Z extends EventTarget {
    /**
     * @param {string} url
     * @param {string|string[]} protocols
     */
    constructor(v, F = []) {
      super();
      /**
       * @see https://websockets.spec.whatwg.org/#feedback-from-the-protocol
       */
      je(this, te);
      je(this, V, {
        open: null,
        error: null,
        close: null,
        message: null
      });
      je(this, ne, 0);
      je(this, _, "");
      je(this, X, "");
      r.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" }), N || (N = !0, process.emitWarning("WebSockets are experimental, expect them to change at any time.", {
        code: "UNDICI-WS"
      }));
      const T = r.converters["DOMString or sequence<DOMString> or WebSocketInit"](F);
      v = r.converters.USVString(v), F = T.protocols;
      const S = A();
      let U;
      try {
        U = new URL(v, S);
      } catch (Y) {
        throw new t(Y, "SyntaxError");
      }
      if (U.protocol === "http:" ? U.protocol = "ws:" : U.protocol === "https:" && (U.protocol = "wss:"), U.protocol !== "ws:" && U.protocol !== "wss:")
        throw new t(
          `Expected a ws: or wss: protocol, got ${U.protocol}`,
          "SyntaxError"
        );
      if (U.hash || U.href.endsWith("#"))
        throw new t("Got fragment", "SyntaxError");
      if (typeof F == "string" && (F = [F]), F.length !== new Set(F.map((Y) => Y.toLowerCase())).size)
        throw new t("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      if (F.length > 0 && !F.every((Y) => Q(Y)))
        throw new t("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      this[s] = new URL(U.href), this[c] = w(
        U,
        F,
        this,
        (Y) => TA(this, te, Qg).call(this, Y),
        T
      ), this[l] = Z.CONNECTING, this[u] = "blob";
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-close
     * @param {number|undefined} code
     * @param {string|undefined} reason
     */
    close(v = void 0, F = void 0) {
      if (r.brandCheck(this, Z), v !== void 0 && (v = r.converters["unsigned short"](v, { clamp: !0 })), F !== void 0 && (F = r.converters.USVString(F)), v !== void 0 && v !== 1e3 && (v < 3e3 || v > 4999))
        throw new t("invalid code", "InvalidAccessError");
      let T = 0;
      if (F !== void 0 && (T = Buffer.byteLength(F), T > 123))
        throw new t(
          `Reason must be less than 123 bytes; received ${T}`,
          "SyntaxError"
        );
      if (!(this[l] === Z.CLOSING || this[l] === Z.CLOSED))
        if (!I(this))
          E(this, "Connection was closed before it was established."), this[l] = Z.CLOSING;
        else if (y(this))
          this[l] = Z.CLOSING;
        else {
          const S = new C();
          v !== void 0 && F === void 0 ? (S.frameData = Buffer.allocUnsafe(2), S.frameData.writeUInt16BE(v, 0)) : v !== void 0 && F !== void 0 ? (S.frameData = Buffer.allocUnsafe(2 + T), S.frameData.writeUInt16BE(v, 0), S.frameData.write(F, 2, "utf-8")) : S.frameData = o, this[h].socket.write(S.createFrame(a.CLOSE), (Y) => {
            Y || (this[g] = !0);
          }), this[l] = i.CLOSING;
        }
    }
    /**
     * @see https://websockets.spec.whatwg.org/#dom-websocket-send
     * @param {NodeJS.TypedArray|ArrayBuffer|Blob|string} data
     */
    send(v) {
      if (r.brandCheck(this, Z), r.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" }), v = r.converters.WebSocketSendData(v), this[l] === Z.CONNECTING)
        throw new t("Sent before connected.", "InvalidStateError");
      if (!I(this) || y(this))
        return;
      const F = this[h].socket;
      if (typeof v == "string") {
        const T = Buffer.from(v), U = new C(T).createFrame(a.TEXT);
        we(this, ne, M(this, ne) + T.byteLength), F.write(U, () => {
          we(this, ne, M(this, ne) - T.byteLength);
        });
      } else if (P.isArrayBuffer(v)) {
        const T = Buffer.from(v), U = new C(T).createFrame(a.BINARY);
        we(this, ne, M(this, ne) + T.byteLength), F.write(U, () => {
          we(this, ne, M(this, ne) - T.byteLength);
        });
      } else if (ArrayBuffer.isView(v)) {
        const T = Buffer.from(v, v.byteOffset, v.byteLength), U = new C(T).createFrame(a.BINARY);
        we(this, ne, M(this, ne) + T.byteLength), F.write(U, () => {
          we(this, ne, M(this, ne) - T.byteLength);
        });
      } else if (m(v)) {
        const T = new C();
        v.arrayBuffer().then((S) => {
          const U = Buffer.from(S);
          T.frameData = U;
          const Y = T.createFrame(a.BINARY);
          we(this, ne, M(this, ne) + U.byteLength), F.write(Y, () => {
            we(this, ne, M(this, ne) - U.byteLength);
          });
        });
      }
    }
    get readyState() {
      return r.brandCheck(this, Z), this[l];
    }
    get bufferedAmount() {
      return r.brandCheck(this, Z), M(this, ne);
    }
    get url() {
      return r.brandCheck(this, Z), e(this[s]);
    }
    get extensions() {
      return r.brandCheck(this, Z), M(this, X);
    }
    get protocol() {
      return r.brandCheck(this, Z), M(this, _);
    }
    get onopen() {
      return r.brandCheck(this, Z), M(this, V).open;
    }
    set onopen(v) {
      r.brandCheck(this, Z), M(this, V).open && this.removeEventListener("open", M(this, V).open), typeof v == "function" ? (M(this, V).open = v, this.addEventListener("open", v)) : M(this, V).open = null;
    }
    get onerror() {
      return r.brandCheck(this, Z), M(this, V).error;
    }
    set onerror(v) {
      r.brandCheck(this, Z), M(this, V).error && this.removeEventListener("error", M(this, V).error), typeof v == "function" ? (M(this, V).error = v, this.addEventListener("error", v)) : M(this, V).error = null;
    }
    get onclose() {
      return r.brandCheck(this, Z), M(this, V).close;
    }
    set onclose(v) {
      r.brandCheck(this, Z), M(this, V).close && this.removeEventListener("close", M(this, V).close), typeof v == "function" ? (M(this, V).close = v, this.addEventListener("close", v)) : M(this, V).close = null;
    }
    get onmessage() {
      return r.brandCheck(this, Z), M(this, V).message;
    }
    set onmessage(v) {
      r.brandCheck(this, Z), M(this, V).message && this.removeEventListener("message", M(this, V).message), typeof v == "function" ? (M(this, V).message = v, this.addEventListener("message", v)) : M(this, V).message = null;
    }
    get binaryType() {
      return r.brandCheck(this, Z), this[u];
    }
    set binaryType(v) {
      r.brandCheck(this, Z), v !== "blob" && v !== "arraybuffer" ? this[u] = "blob" : this[u] = v;
    }
  };
  V = new WeakMap(), ne = new WeakMap(), _ = new WeakMap(), X = new WeakMap(), te = new WeakSet(), Qg = function(v) {
    this[h] = v;
    const F = new f(this);
    F.on("drain", function() {
      this.ws[h].socket.resume();
    }), v.socket.ws = this, this[d] = F, this[l] = i.OPEN;
    const T = v.headersList.get("sec-websocket-extensions");
    T !== null && we(this, X, T);
    const S = v.headersList.get("sec-websocket-protocol");
    S !== null && we(this, _, S), B("open", this);
  };
  let $ = Z;
  return $.CONNECTING = $.prototype.CONNECTING = i.CONNECTING, $.OPEN = $.prototype.OPEN = i.OPEN, $.CLOSING = $.prototype.CLOSING = i.CLOSING, $.CLOSED = $.prototype.CLOSED = i.CLOSED, Object.defineProperties($.prototype, {
    CONNECTING: n,
    OPEN: n,
    CLOSING: n,
    CLOSED: n,
    url: p,
    readyState: p,
    bufferedAmount: p,
    onopen: p,
    onerror: p,
    onclose: p,
    close: p,
    onmessage: p,
    binaryType: p,
    send: p,
    extensions: p,
    protocol: p,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: !1,
      enumerable: !1,
      configurable: !0
    }
  }), Object.defineProperties($, {
    CONNECTING: n,
    OPEN: n,
    CLOSING: n,
    CLOSED: n
  }), r.converters["sequence<DOMString>"] = r.sequenceConverter(
    r.converters.DOMString
  ), r.converters["DOMString or sequence<DOMString>"] = function(b) {
    return r.util.Type(b) === "Object" && Symbol.iterator in b ? r.converters["sequence<DOMString>"](b) : r.converters.DOMString(b);
  }, r.converters.WebSocketInit = r.dictionaryConverter([
    {
      key: "protocols",
      converter: r.converters["DOMString or sequence<DOMString>"],
      get defaultValue() {
        return [];
      }
    },
    {
      key: "dispatcher",
      converter: (b) => b,
      get defaultValue() {
        return R();
      }
    },
    {
      key: "headers",
      converter: r.nullableConverter(r.converters.HeadersInit)
    }
  ]), r.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function(b) {
    return r.util.Type(b) === "Object" && !(Symbol.iterator in b) ? r.converters.WebSocketInit(b) : { protocols: r.converters["DOMString or sequence<DOMString>"](b) };
  }, r.converters.WebSocketSendData = function(b) {
    if (r.util.Type(b) === "Object") {
      if (m(b))
        return r.converters.Blob(b, { strict: !1 });
      if (ArrayBuffer.isView(b) || P.isAnyArrayBuffer(b))
        return r.converters.BufferSource(b);
    }
    return r.converters.USVString(b);
  }, $o = {
    WebSocket: $
  }, $o;
}
const Ld = wi, Bg = Rs, Ig = ke, Hd = Qn, Gd = WQ, Wd = vi, Rt = Ie, { InvalidArgumentError: Xn } = Ig, cr = or, Yd = yi, Jd = ag, _d = zI, xd = og, Od = $h, qd = Ed, jd = Bd, { getGlobalDispatcher: dg, setGlobalDispatcher: Vd } = dn, $d = pd, Xd = uh, Zd = Ns;
let Cs;
try {
  Cs = !0;
} catch {
  Cs = !1;
}
Object.assign(Bg.prototype, cr);
ce.Dispatcher = Bg;
ce.Client = Ld;
ce.Pool = Hd;
ce.BalancedPool = Gd;
ce.Agent = Wd;
ce.ProxyAgent = qd;
ce.RetryHandler = jd;
ce.DecoratorHandler = $d;
ce.RedirectHandler = Xd;
ce.createRedirectInterceptor = Zd;
ce.buildConnector = Yd;
ce.errors = Ig;
function yn(r) {
  return (t, e, A) => {
    if (typeof e == "function" && (A = e, e = null), !t || typeof t != "string" && typeof t != "object" && !(t instanceof URL))
      throw new Xn("invalid url");
    if (e != null && typeof e != "object")
      throw new Xn("invalid opts");
    if (e && e.path != null) {
      if (typeof e.path != "string")
        throw new Xn("invalid opts.path");
      let a = e.path;
      e.path.startsWith("/") || (a = `/${a}`), t = new URL(Rt.parseOrigin(t).origin + a);
    } else
      e || (e = typeof t == "object" ? t : {}), t = Rt.parseURL(t);
    const { agent: n, dispatcher: i = dg() } = e;
    if (n)
      throw new Xn("unsupported opts.agent. Did you mean opts.client?");
    return r.call(i, {
      ...e,
      origin: t.origin,
      path: t.search ? `${t.pathname}${t.search}` : t.pathname,
      method: e.method || (e.body ? "PUT" : "GET")
    }, A);
  };
}
ce.setGlobalDispatcher = Vd;
ce.getGlobalDispatcher = dg;
if (Rt.nodeMajor > 16 || Rt.nodeMajor === 16 && Rt.nodeMinor >= 8) {
  let r = null;
  ce.fetch = async function(a) {
    r || (r = Ms().fetch);
    try {
      return await r(...arguments);
    } catch (o) {
      throw typeof o == "object" && Error.captureStackTrace(o, this), o;
    }
  }, ce.Headers = sr().Headers, ce.Response = Ps().Response, ce.Request = Ti().Request, ce.FormData = Fs().FormData, ce.File = Ts().File, ce.FileReader = bd().FileReader;
  const { setGlobalOrigin: t, getGlobalOrigin: e } = fn();
  ce.setGlobalOrigin = t, ce.getGlobalOrigin = e;
  const { CacheStorage: A } = Rd(), { kConstruct: n } = Ls();
  ce.caches = new A(n);
}
if (Rt.nodeMajor >= 16) {
  const { deleteCookie: r, getCookies: t, getSetCookies: e, setCookie: A } = Sd();
  ce.deleteCookie = r, ce.getCookies = t, ce.getSetCookies = e, ce.setCookie = A;
  const { parseMIMEType: n, serializeAMimeType: i } = JA();
  ce.parseMIMEType = n, ce.serializeAMimeType = i;
}
if (Rt.nodeMajor >= 18 && Cs) {
  const { WebSocket: r } = Md();
  ce.WebSocket = r;
}
ce.request = yn(cr.request);
ce.stream = yn(cr.stream);
ce.pipeline = yn(cr.pipeline);
ce.connect = yn(cr.connect);
ce.upgrade = yn(cr.upgrade);
ce.MockClient = Jd;
ce.MockPool = xd;
ce.MockAgent = _d;
ce.mockErrors = Od;
var Kd = se && se.__createBinding || (Object.create ? function(r, t, e, A) {
  A === void 0 && (A = e);
  var n = Object.getOwnPropertyDescriptor(t, e);
  (!n || ("get" in n ? !t.__esModule : n.writable || n.configurable)) && (n = { enumerable: !0, get: function() {
    return t[e];
  } }), Object.defineProperty(r, A, n);
} : function(r, t, e, A) {
  A === void 0 && (A = e), r[A] = t[e];
}), zd = se && se.__setModuleDefault || (Object.create ? function(r, t) {
  Object.defineProperty(r, "default", { enumerable: !0, value: t });
} : function(r, t) {
  r.default = t;
}), Ri = se && se.__importStar || function(r) {
  if (r && r.__esModule)
    return r;
  var t = {};
  if (r != null)
    for (var e in r)
      e !== "default" && Object.prototype.hasOwnProperty.call(r, e) && Kd(t, r, e);
  return zd(t, r), t;
}, _e = se && se.__awaiter || function(r, t, e, A) {
  function n(i) {
    return i instanceof e ? i : new e(function(a) {
      a(i);
    });
  }
  return new (e || (e = Promise))(function(i, a) {
    function o(c) {
      try {
        l(A.next(c));
      } catch (u) {
        a(u);
      }
    }
    function s(c) {
      try {
        l(A.throw(c));
      } catch (u) {
        a(u);
      }
    }
    function l(c) {
      c.done ? i(c.value) : n(c.value).then(o, s);
    }
    l((A = A.apply(r, t || [])).next());
  });
};
Object.defineProperty(Xe, "__esModule", { value: !0 });
Xe.HttpClient = Xe.isHttps = Xe.HttpClientResponse = Xe.HttpClientError = Xe.getProxyUrl = Xe.MediaTypes = Xe.Headers = Xe.HttpCodes = void 0;
const Xo = Ri(L), ru = Ri(L), fs = Ri(Ar), Zn = Ri(RE), ep = ce;
var kA;
(function(r) {
  r[r.OK = 200] = "OK", r[r.MultipleChoices = 300] = "MultipleChoices", r[r.MovedPermanently = 301] = "MovedPermanently", r[r.ResourceMoved = 302] = "ResourceMoved", r[r.SeeOther = 303] = "SeeOther", r[r.NotModified = 304] = "NotModified", r[r.UseProxy = 305] = "UseProxy", r[r.SwitchProxy = 306] = "SwitchProxy", r[r.TemporaryRedirect = 307] = "TemporaryRedirect", r[r.PermanentRedirect = 308] = "PermanentRedirect", r[r.BadRequest = 400] = "BadRequest", r[r.Unauthorized = 401] = "Unauthorized", r[r.PaymentRequired = 402] = "PaymentRequired", r[r.Forbidden = 403] = "Forbidden", r[r.NotFound = 404] = "NotFound", r[r.MethodNotAllowed = 405] = "MethodNotAllowed", r[r.NotAcceptable = 406] = "NotAcceptable", r[r.ProxyAuthenticationRequired = 407] = "ProxyAuthenticationRequired", r[r.RequestTimeout = 408] = "RequestTimeout", r[r.Conflict = 409] = "Conflict", r[r.Gone = 410] = "Gone", r[r.TooManyRequests = 429] = "TooManyRequests", r[r.InternalServerError = 500] = "InternalServerError", r[r.NotImplemented = 501] = "NotImplemented", r[r.BadGateway = 502] = "BadGateway", r[r.ServiceUnavailable = 503] = "ServiceUnavailable", r[r.GatewayTimeout = 504] = "GatewayTimeout";
})(kA || (Xe.HttpCodes = kA = {}));
var aA;
(function(r) {
  r.Accept = "accept", r.ContentType = "content-type";
})(aA || (Xe.Headers = aA = {}));
var jA;
(function(r) {
  r.ApplicationJson = "application/json";
})(jA || (Xe.MediaTypes = jA = {}));
function Ap(r) {
  const t = fs.getProxyUrl(new URL(r));
  return t ? t.href : "";
}
Xe.getProxyUrl = Ap;
const tp = [
  kA.MovedPermanently,
  kA.ResourceMoved,
  kA.SeeOther,
  kA.TemporaryRedirect,
  kA.PermanentRedirect
], rp = [
  kA.BadGateway,
  kA.ServiceUnavailable,
  kA.GatewayTimeout
], np = ["OPTIONS", "GET", "DELETE", "HEAD"], ip = 10, ap = 5;
class Di extends Error {
  constructor(t, e) {
    super(t), this.name = "HttpClientError", this.statusCode = e, Object.setPrototypeOf(this, Di.prototype);
  }
}
Xe.HttpClientError = Di;
class pg {
  constructor(t) {
    this.message = t;
  }
  readBody() {
    return _e(this, void 0, void 0, function* () {
      return new Promise((t) => _e(this, void 0, void 0, function* () {
        let e = Buffer.alloc(0);
        this.message.on("data", (A) => {
          e = Buffer.concat([e, A]);
        }), this.message.on("end", () => {
          t(e.toString());
        });
      }));
    });
  }
  readBodyBuffer() {
    return _e(this, void 0, void 0, function* () {
      return new Promise((t) => _e(this, void 0, void 0, function* () {
        const e = [];
        this.message.on("data", (A) => {
          e.push(A);
        }), this.message.on("end", () => {
          t(Buffer.concat(e));
        });
      }));
    });
  }
}
Xe.HttpClientResponse = pg;
function op(r) {
  return new URL(r).protocol === "https:";
}
Xe.isHttps = op;
class sp {
  constructor(t, e, A) {
    this._ignoreSslError = !1, this._allowRedirects = !0, this._allowRedirectDowngrade = !1, this._maxRedirects = 50, this._allowRetries = !1, this._maxRetries = 1, this._keepAlive = !1, this._disposed = !1, this.userAgent = t, this.handlers = e || [], this.requestOptions = A, A && (A.ignoreSslError != null && (this._ignoreSslError = A.ignoreSslError), this._socketTimeout = A.socketTimeout, A.allowRedirects != null && (this._allowRedirects = A.allowRedirects), A.allowRedirectDowngrade != null && (this._allowRedirectDowngrade = A.allowRedirectDowngrade), A.maxRedirects != null && (this._maxRedirects = Math.max(A.maxRedirects, 0)), A.keepAlive != null && (this._keepAlive = A.keepAlive), A.allowRetries != null && (this._allowRetries = A.allowRetries), A.maxRetries != null && (this._maxRetries = A.maxRetries));
  }
  options(t, e) {
    return _e(this, void 0, void 0, function* () {
      return this.request("OPTIONS", t, null, e || {});
    });
  }
  get(t, e) {
    return _e(this, void 0, void 0, function* () {
      return this.request("GET", t, null, e || {});
    });
  }
  del(t, e) {
    return _e(this, void 0, void 0, function* () {
      return this.request("DELETE", t, null, e || {});
    });
  }
  post(t, e, A) {
    return _e(this, void 0, void 0, function* () {
      return this.request("POST", t, e, A || {});
    });
  }
  patch(t, e, A) {
    return _e(this, void 0, void 0, function* () {
      return this.request("PATCH", t, e, A || {});
    });
  }
  put(t, e, A) {
    return _e(this, void 0, void 0, function* () {
      return this.request("PUT", t, e, A || {});
    });
  }
  head(t, e) {
    return _e(this, void 0, void 0, function* () {
      return this.request("HEAD", t, null, e || {});
    });
  }
  sendStream(t, e, A, n) {
    return _e(this, void 0, void 0, function* () {
      return this.request(t, e, A, n);
    });
  }
  /**
   * Gets a typed object from an endpoint
   * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise
   */
  getJson(t, e = {}) {
    return _e(this, void 0, void 0, function* () {
      e[aA.Accept] = this._getExistingOrDefaultHeader(e, aA.Accept, jA.ApplicationJson);
      const A = yield this.get(t, e);
      return this._processResponse(A, this.requestOptions);
    });
  }
  postJson(t, e, A = {}) {
    return _e(this, void 0, void 0, function* () {
      const n = JSON.stringify(e, null, 2);
      A[aA.Accept] = this._getExistingOrDefaultHeader(A, aA.Accept, jA.ApplicationJson), A[aA.ContentType] = this._getExistingOrDefaultHeader(A, aA.ContentType, jA.ApplicationJson);
      const i = yield this.post(t, n, A);
      return this._processResponse(i, this.requestOptions);
    });
  }
  putJson(t, e, A = {}) {
    return _e(this, void 0, void 0, function* () {
      const n = JSON.stringify(e, null, 2);
      A[aA.Accept] = this._getExistingOrDefaultHeader(A, aA.Accept, jA.ApplicationJson), A[aA.ContentType] = this._getExistingOrDefaultHeader(A, aA.ContentType, jA.ApplicationJson);
      const i = yield this.put(t, n, A);
      return this._processResponse(i, this.requestOptions);
    });
  }
  patchJson(t, e, A = {}) {
    return _e(this, void 0, void 0, function* () {
      const n = JSON.stringify(e, null, 2);
      A[aA.Accept] = this._getExistingOrDefaultHeader(A, aA.Accept, jA.ApplicationJson), A[aA.ContentType] = this._getExistingOrDefaultHeader(A, aA.ContentType, jA.ApplicationJson);
      const i = yield this.patch(t, n, A);
      return this._processResponse(i, this.requestOptions);
    });
  }
  /**
   * Makes a raw http request.
   * All other methods such as get, post, patch, and request ultimately call this.
   * Prefer get, del, post and patch
   */
  request(t, e, A, n) {
    return _e(this, void 0, void 0, function* () {
      if (this._disposed)
        throw new Error("Client has already been disposed.");
      const i = new URL(e);
      let a = this._prepareRequest(t, i, n);
      const o = this._allowRetries && np.includes(t) ? this._maxRetries + 1 : 1;
      let s = 0, l;
      do {
        if (l = yield this.requestRaw(a, A), l && l.message && l.message.statusCode === kA.Unauthorized) {
          let u;
          for (const h of this.handlers)
            if (h.canHandleAuthentication(l)) {
              u = h;
              break;
            }
          return u ? u.handleAuthentication(this, a, A) : l;
        }
        let c = this._maxRedirects;
        for (; l.message.statusCode && tp.includes(l.message.statusCode) && this._allowRedirects && c > 0; ) {
          const u = l.message.headers.location;
          if (!u)
            break;
          const h = new URL(u);
          if (i.protocol === "https:" && i.protocol !== h.protocol && !this._allowRedirectDowngrade)
            throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
          if (yield l.readBody(), h.hostname !== i.hostname)
            for (const g in n)
              g.toLowerCase() === "authorization" && delete n[g];
          a = this._prepareRequest(t, h, n), l = yield this.requestRaw(a, A), c--;
        }
        if (!l.message.statusCode || !rp.includes(l.message.statusCode))
          return l;
        s += 1, s < o && (yield l.readBody(), yield this._performExponentialBackoff(s));
      } while (s < o);
      return l;
    });
  }
  /**
   * Needs to be called if keepAlive is set to true in request options.
   */
  dispose() {
    this._agent && this._agent.destroy(), this._disposed = !0;
  }
  /**
   * Raw request.
   * @param info
   * @param data
   */
  requestRaw(t, e) {
    return _e(this, void 0, void 0, function* () {
      return new Promise((A, n) => {
        function i(a, o) {
          a ? n(a) : o ? A(o) : n(new Error("Unknown error"));
        }
        this.requestRawWithCallback(t, e, i);
      });
    });
  }
  /**
   * Raw request with callback.
   * @param info
   * @param data
   * @param onResult
   */
  requestRawWithCallback(t, e, A) {
    typeof e == "string" && (t.options.headers || (t.options.headers = {}), t.options.headers["Content-Length"] = Buffer.byteLength(e, "utf8"));
    let n = !1;
    function i(s, l) {
      n || (n = !0, A(s, l));
    }
    const a = t.httpModule.request(t.options, (s) => {
      const l = new pg(s);
      i(void 0, l);
    });
    let o;
    a.on("socket", (s) => {
      o = s;
    }), a.setTimeout(this._socketTimeout || 3 * 6e4, () => {
      o && o.end(), i(new Error(`Request timeout: ${t.options.path}`));
    }), a.on("error", function(s) {
      i(s);
    }), e && typeof e == "string" && a.write(e, "utf8"), e && typeof e != "string" ? (e.on("close", function() {
      a.end();
    }), e.pipe(a)) : a.end();
  }
  /**
   * Gets an http agent. This function is useful when you need an http agent that handles
   * routing through a proxy server - depending upon the url and proxy environment variables.
   * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com
   */
  getAgent(t) {
    const e = new URL(t);
    return this._getAgent(e);
  }
  getAgentDispatcher(t) {
    const e = new URL(t), A = fs.getProxyUrl(e);
    if (A && A.hostname)
      return this._getProxyAgentDispatcher(e, A);
  }
  _prepareRequest(t, e, A) {
    const n = {};
    n.parsedUrl = e;
    const i = n.parsedUrl.protocol === "https:";
    n.httpModule = i ? ru : Xo;
    const a = i ? 443 : 80;
    if (n.options = {}, n.options.host = n.parsedUrl.hostname, n.options.port = n.parsedUrl.port ? parseInt(n.parsedUrl.port) : a, n.options.path = (n.parsedUrl.pathname || "") + (n.parsedUrl.search || ""), n.options.method = t, n.options.headers = this._mergeHeaders(A), this.userAgent != null && (n.options.headers["user-agent"] = this.userAgent), n.options.agent = this._getAgent(n.parsedUrl), this.handlers)
      for (const o of this.handlers)
        o.prepareRequest(n.options);
    return n;
  }
  _mergeHeaders(t) {
    return this.requestOptions && this.requestOptions.headers ? Object.assign({}, Kn(this.requestOptions.headers), Kn(t || {})) : Kn(t || {});
  }
  _getExistingOrDefaultHeader(t, e, A) {
    let n;
    return this.requestOptions && this.requestOptions.headers && (n = Kn(this.requestOptions.headers)[e]), t[e] || n || A;
  }
  _getAgent(t) {
    let e;
    const A = fs.getProxyUrl(t), n = A && A.hostname;
    if (this._keepAlive && n && (e = this._proxyAgent), n || (e = this._agent), e)
      return e;
    const i = t.protocol === "https:";
    let a = 100;
    if (this.requestOptions && (a = this.requestOptions.maxSockets || Xo.globalAgent.maxSockets), A && A.hostname) {
      const o = {
        maxSockets: a,
        keepAlive: this._keepAlive,
        proxy: Object.assign(Object.assign({}, (A.username || A.password) && {
          proxyAuth: `${A.username}:${A.password}`
        }), { host: A.hostname, port: A.port })
      };
      let s;
      const l = A.protocol === "https:";
      i ? s = l ? Zn.httpsOverHttps : Zn.httpsOverHttp : s = l ? Zn.httpOverHttps : Zn.httpOverHttp, e = s(o), this._proxyAgent = e;
    }
    if (!e) {
      const o = { keepAlive: this._keepAlive, maxSockets: a };
      e = i ? new ru.Agent(o) : new Xo.Agent(o), this._agent = e;
    }
    return i && this._ignoreSslError && (e.options = Object.assign(e.options || {}, {
      rejectUnauthorized: !1
    })), e;
  }
  _getProxyAgentDispatcher(t, e) {
    let A;
    if (this._keepAlive && (A = this._proxyAgentDispatcher), A)
      return A;
    const n = t.protocol === "https:";
    return A = new ep.ProxyAgent(Object.assign({ uri: e.href, pipelining: this._keepAlive ? 1 : 0 }, (e.username || e.password) && {
      token: `${e.username}:${e.password}`
    })), this._proxyAgentDispatcher = A, n && this._ignoreSslError && (A.options = Object.assign(A.options.requestTls || {}, {
      rejectUnauthorized: !1
    })), A;
  }
  _performExponentialBackoff(t) {
    return _e(this, void 0, void 0, function* () {
      t = Math.min(ip, t);
      const e = ap * Math.pow(2, t);
      return new Promise((A) => setTimeout(() => A(), e));
    });
  }
  _processResponse(t, e) {
    return _e(this, void 0, void 0, function* () {
      return new Promise((A, n) => _e(this, void 0, void 0, function* () {
        const i = t.message.statusCode || 0, a = {
          statusCode: i,
          result: null,
          headers: {}
        };
        i === kA.NotFound && A(a);
        function o(c, u) {
          if (typeof u == "string") {
            const h = new Date(u);
            if (!isNaN(h.valueOf()))
              return h;
          }
          return u;
        }
        let s, l;
        try {
          l = yield t.readBody(), l && l.length > 0 && (e && e.deserializeDates ? s = JSON.parse(l, o) : s = JSON.parse(l), a.result = s), a.headers = t.message.headers;
        } catch {
        }
        if (i > 299) {
          let c;
          s && s.message ? c = s.message : l && l.length > 0 ? c = l : c = `Failed request: (${i})`;
          const u = new Di(c, i);
          u.result = a.result, n(u);
        } else
          A(a);
      }));
    });
  }
}
Xe.HttpClient = sp;
const Kn = (r) => Object.keys(r).reduce((t, e) => (t[e.toLowerCase()] = r[e], t), {});
var gt = {}, Gs = se && se.__awaiter || function(r, t, e, A) {
  function n(i) {
    return i instanceof e ? i : new e(function(a) {
      a(i);
    });
  }
  return new (e || (e = Promise))(function(i, a) {
    function o(c) {
      try {
        l(A.next(c));
      } catch (u) {
        a(u);
      }
    }
    function s(c) {
      try {
        l(A.throw(c));
      } catch (u) {
        a(u);
      }
    }
    function l(c) {
      c.done ? i(c.value) : n(c.value).then(o, s);
    }
    l((A = A.apply(r, t || [])).next());
  });
};
Object.defineProperty(gt, "__esModule", { value: !0 });
gt.PersonalAccessTokenCredentialHandler = gt.BearerCredentialHandler = gt.BasicCredentialHandler = void 0;
class cp {
  constructor(t, e) {
    this.username = t, this.password = e;
  }
  prepareRequest(t) {
    if (!t.headers)
      throw Error("The request has no headers");
    t.headers.Authorization = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
  }
  // This handler cannot handle 401
  canHandleAuthentication() {
    return !1;
  }
  handleAuthentication() {
    return Gs(this, void 0, void 0, function* () {
      throw new Error("not implemented");
    });
  }
}
gt.BasicCredentialHandler = cp;
class lp {
  constructor(t) {
    this.token = t;
  }
  // currently implements pre-authorization
  // TODO: support preAuth = false where it hooks on 401
  prepareRequest(t) {
    if (!t.headers)
      throw Error("The request has no headers");
    t.headers.Authorization = `Bearer ${this.token}`;
  }
  // This handler cannot handle 401
  canHandleAuthentication() {
    return !1;
  }
  handleAuthentication() {
    return Gs(this, void 0, void 0, function* () {
      throw new Error("not implemented");
    });
  }
}
gt.BearerCredentialHandler = lp;
class up {
  constructor(t) {
    this.token = t;
  }
  // currently implements pre-authorization
  // TODO: support preAuth = false where it hooks on 401
  prepareRequest(t) {
    if (!t.headers)
      throw Error("The request has no headers");
    t.headers.Authorization = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
  }
  // This handler cannot handle 401
  canHandleAuthentication() {
    return !1;
  }
  handleAuthentication() {
    return Gs(this, void 0, void 0, function* () {
      throw new Error("not implemented");
    });
  }
}
gt.PersonalAccessTokenCredentialHandler = up;
var nu;
function hp() {
  if (nu)
    return hr;
  nu = 1;
  var r = se && se.__awaiter || function(i, a, o, s) {
    function l(c) {
      return c instanceof o ? c : new o(function(u) {
        u(c);
      });
    }
    return new (o || (o = Promise))(function(c, u) {
      function h(I) {
        try {
          d(s.next(I));
        } catch (y) {
          u(y);
        }
      }
      function g(I) {
        try {
          d(s.throw(I));
        } catch (y) {
          u(y);
        }
      }
      function d(I) {
        I.done ? c(I.value) : l(I.value).then(h, g);
      }
      d((s = s.apply(i, a || [])).next());
    });
  };
  Object.defineProperty(hr, "__esModule", { value: !0 }), hr.OidcClient = void 0;
  const t = Xe, e = gt, A = yg();
  class n {
    static createHttpClient(a = !0, o = 10) {
      const s = {
        allowRetries: a,
        maxRetries: o
      };
      return new t.HttpClient("actions/oidc-client", [new e.BearerCredentialHandler(n.getRequestToken())], s);
    }
    static getRequestToken() {
      const a = process.env.ACTIONS_ID_TOKEN_REQUEST_TOKEN;
      if (!a)
        throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
      return a;
    }
    static getIDTokenUrl() {
      const a = process.env.ACTIONS_ID_TOKEN_REQUEST_URL;
      if (!a)
        throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
      return a;
    }
    static getCall(a) {
      var o;
      return r(this, void 0, void 0, function* () {
        const c = (o = (yield n.createHttpClient().getJson(a).catch((u) => {
          throw new Error(`Failed to get ID Token. 
 
        Error Code : ${u.statusCode}
 
        Error Message: ${u.message}`);
        })).result) === null || o === void 0 ? void 0 : o.value;
        if (!c)
          throw new Error("Response json body do not have ID Token field");
        return c;
      });
    }
    static getIDToken(a) {
      return r(this, void 0, void 0, function* () {
        try {
          let o = n.getIDTokenUrl();
          if (a) {
            const l = encodeURIComponent(a);
            o = `${o}&audience=${l}`;
          }
          A.debug(`ID token url is ${o}`);
          const s = yield n.getCall(o);
          return A.setSecret(s), s;
        } catch (o) {
          throw new Error(`Error message: ${o.message}`);
        }
      });
    }
  }
  return hr.OidcClient = n, hr;
}
var Zo = {}, iu;
function au() {
  return iu || (iu = 1, function(r) {
    var t = se && se.__awaiter || function(l, c, u, h) {
      function g(d) {
        return d instanceof u ? d : new u(function(I) {
          I(d);
        });
      }
      return new (u || (u = Promise))(function(d, I) {
        function y(B) {
          try {
            E(h.next(B));
          } catch (w) {
            I(w);
          }
        }
        function Q(B) {
          try {
            E(h.throw(B));
          } catch (w) {
            I(w);
          }
        }
        function E(B) {
          B.done ? d(B.value) : g(B.value).then(y, Q);
        }
        E((h = h.apply(l, c || [])).next());
      });
    };
    Object.defineProperty(r, "__esModule", { value: !0 }), r.summary = r.markdownSummary = r.SUMMARY_DOCS_URL = r.SUMMARY_ENV_VAR = void 0;
    const e = L, A = L, { access: n, appendFile: i, writeFile: a } = A.promises;
    r.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY", r.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    class o {
      constructor() {
        this._buffer = "";
      }
      /**
       * Finds the summary file path from the environment, rejects if env var is not found or file does not exist
       * Also checks r/w permissions.
       *
       * @returns step summary file path
       */
      filePath() {
        return t(this, void 0, void 0, function* () {
          if (this._filePath)
            return this._filePath;
          const c = process.env[r.SUMMARY_ENV_VAR];
          if (!c)
            throw new Error(`Unable to find environment variable for $${r.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
          try {
            yield n(c, A.constants.R_OK | A.constants.W_OK);
          } catch {
            throw new Error(`Unable to access summary file: '${c}'. Check if the file has correct read/write permissions.`);
          }
          return this._filePath = c, this._filePath;
        });
      }
      /**
       * Wraps content in an HTML tag, adding any HTML attributes
       *
       * @param {string} tag HTML tag to wrap
       * @param {string | null} content content within the tag
       * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add
       *
       * @returns {string} content wrapped in HTML element
       */
      wrap(c, u, h = {}) {
        const g = Object.entries(h).map(([d, I]) => ` ${d}="${I}"`).join("");
        return u ? `<${c}${g}>${u}</${c}>` : `<${c}${g}>`;
      }
      /**
       * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.
       *
       * @param {SummaryWriteOptions} [options] (optional) options for write operation
       *
       * @returns {Promise<Summary>} summary instance
       */
      write(c) {
        return t(this, void 0, void 0, function* () {
          const u = !!(c != null && c.overwrite), h = yield this.filePath();
          return yield (u ? a : i)(h, this._buffer, { encoding: "utf8" }), this.emptyBuffer();
        });
      }
      /**
       * Clears the summary buffer and wipes the summary file
       *
       * @returns {Summary} summary instance
       */
      clear() {
        return t(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: !0 });
        });
      }
      /**
       * Returns the current summary buffer as a string
       *
       * @returns {string} string of summary buffer
       */
      stringify() {
        return this._buffer;
      }
      /**
       * If the summary buffer is empty
       *
       * @returns {boolen} true if the buffer is empty
       */
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      /**
       * Resets the summary buffer without writing to summary file
       *
       * @returns {Summary} summary instance
       */
      emptyBuffer() {
        return this._buffer = "", this;
      }
      /**
       * Adds raw text to the summary buffer
       *
       * @param {string} text content to add
       * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)
       *
       * @returns {Summary} summary instance
       */
      addRaw(c, u = !1) {
        return this._buffer += c, u ? this.addEOL() : this;
      }
      /**
       * Adds the operating system-specific end-of-line marker to the buffer
       *
       * @returns {Summary} summary instance
       */
      addEOL() {
        return this.addRaw(e.EOL);
      }
      /**
       * Adds an HTML codeblock to the summary buffer
       *
       * @param {string} code content to render within fenced code block
       * @param {string} lang (optional) language to syntax highlight code
       *
       * @returns {Summary} summary instance
       */
      addCodeBlock(c, u) {
        const h = Object.assign({}, u && { lang: u }), g = this.wrap("pre", this.wrap("code", c), h);
        return this.addRaw(g).addEOL();
      }
      /**
       * Adds an HTML list to the summary buffer
       *
       * @param {string[]} items list of items to render
       * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)
       *
       * @returns {Summary} summary instance
       */
      addList(c, u = !1) {
        const h = u ? "ol" : "ul", g = c.map((I) => this.wrap("li", I)).join(""), d = this.wrap(h, g);
        return this.addRaw(d).addEOL();
      }
      /**
       * Adds an HTML table to the summary buffer
       *
       * @param {SummaryTableCell[]} rows table rows
       *
       * @returns {Summary} summary instance
       */
      addTable(c) {
        const u = c.map((g) => {
          const d = g.map((I) => {
            if (typeof I == "string")
              return this.wrap("td", I);
            const { header: y, data: Q, colspan: E, rowspan: B } = I, w = y ? "th" : "td", C = Object.assign(Object.assign({}, E && { colspan: E }), B && { rowspan: B });
            return this.wrap(w, Q, C);
          }).join("");
          return this.wrap("tr", d);
        }).join(""), h = this.wrap("table", u);
        return this.addRaw(h).addEOL();
      }
      /**
       * Adds a collapsable HTML details element to the summary buffer
       *
       * @param {string} label text for the closed state
       * @param {string} content collapsable content
       *
       * @returns {Summary} summary instance
       */
      addDetails(c, u) {
        const h = this.wrap("details", this.wrap("summary", c) + u);
        return this.addRaw(h).addEOL();
      }
      /**
       * Adds an HTML image tag to the summary buffer
       *
       * @param {string} src path to the image you to embed
       * @param {string} alt text description of the image
       * @param {SummaryImageOptions} options (optional) addition image attributes
       *
       * @returns {Summary} summary instance
       */
      addImage(c, u, h) {
        const { width: g, height: d } = h || {}, I = Object.assign(Object.assign({}, g && { width: g }), d && { height: d }), y = this.wrap("img", null, Object.assign({ src: c, alt: u }, I));
        return this.addRaw(y).addEOL();
      }
      /**
       * Adds an HTML section heading element
       *
       * @param {string} text heading text
       * @param {number | string} [level=1] (optional) the heading level, default: 1
       *
       * @returns {Summary} summary instance
       */
      addHeading(c, u) {
        const h = `h${u}`, g = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(h) ? h : "h1", d = this.wrap(g, c);
        return this.addRaw(d).addEOL();
      }
      /**
       * Adds an HTML thematic break (<hr>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addSeparator() {
        const c = this.wrap("hr", null);
        return this.addRaw(c).addEOL();
      }
      /**
       * Adds an HTML line break (<br>) to the summary buffer
       *
       * @returns {Summary} summary instance
       */
      addBreak() {
        const c = this.wrap("br", null);
        return this.addRaw(c).addEOL();
      }
      /**
       * Adds an HTML blockquote to the summary buffer
       *
       * @param {string} text quote text
       * @param {string} cite (optional) citation url
       *
       * @returns {Summary} summary instance
       */
      addQuote(c, u) {
        const h = Object.assign({}, u && { cite: u }), g = this.wrap("blockquote", c, h);
        return this.addRaw(g).addEOL();
      }
      /**
       * Adds an HTML anchor tag to the summary buffer
       *
       * @param {string} text link text/content
       * @param {string} href hyperlink
       *
       * @returns {Summary} summary instance
       */
      addLink(c, u) {
        const h = this.wrap("a", c, { href: u });
        return this.addRaw(h).addEOL();
      }
    }
    const s = new o();
    r.markdownSummary = s, r.summary = s;
  }(Zo)), Zo;
}
var OA = {}, ou;
function gp() {
  if (ou)
    return OA;
  ou = 1;
  var r = se && se.__createBinding || (Object.create ? function(o, s, l, c) {
    c === void 0 && (c = l), Object.defineProperty(o, c, { enumerable: !0, get: function() {
      return s[l];
    } });
  } : function(o, s, l, c) {
    c === void 0 && (c = l), o[c] = s[l];
  }), t = se && se.__setModuleDefault || (Object.create ? function(o, s) {
    Object.defineProperty(o, "default", { enumerable: !0, value: s });
  } : function(o, s) {
    o.default = s;
  }), e = se && se.__importStar || function(o) {
    if (o && o.__esModule)
      return o;
    var s = {};
    if (o != null)
      for (var l in o)
        l !== "default" && Object.hasOwnProperty.call(o, l) && r(s, o, l);
    return t(s, o), s;
  };
  Object.defineProperty(OA, "__esModule", { value: !0 }), OA.toPlatformPath = OA.toWin32Path = OA.toPosixPath = void 0;
  const A = e(L);
  function n(o) {
    return o.replace(/[\\]/g, "/");
  }
  OA.toPosixPath = n;
  function i(o) {
    return o.replace(/[/]/g, "\\");
  }
  OA.toWin32Path = i;
  function a(o) {
    return o.replace(/[/\\]/g, A.sep);
  }
  return OA.toPlatformPath = a, OA;
}
var su;
function yg() {
  return su || (su = 1, function(r) {
    var t = se && se.__createBinding || (Object.create ? function(b, W, v, F) {
      F === void 0 && (F = v), Object.defineProperty(b, F, { enumerable: !0, get: function() {
        return W[v];
      } });
    } : function(b, W, v, F) {
      F === void 0 && (F = v), b[F] = W[v];
    }), e = se && se.__setModuleDefault || (Object.create ? function(b, W) {
      Object.defineProperty(b, "default", { enumerable: !0, value: W });
    } : function(b, W) {
      b.default = W;
    }), A = se && se.__importStar || function(b) {
      if (b && b.__esModule)
        return b;
      var W = {};
      if (b != null)
        for (var v in b)
          v !== "default" && Object.hasOwnProperty.call(b, v) && t(W, b, v);
      return e(W, b), W;
    }, n = se && se.__awaiter || function(b, W, v, F) {
      function T(S) {
        return S instanceof v ? S : new v(function(U) {
          U(S);
        });
      }
      return new (v || (v = Promise))(function(S, U) {
        function Y(H) {
          try {
            j(F.next(H));
          } catch (ie) {
            U(ie);
          }
        }
        function O(H) {
          try {
            j(F.throw(H));
          } catch (ie) {
            U(ie);
          }
        }
        function j(H) {
          H.done ? S(H.value) : T(H.value).then(Y, O);
        }
        j((F = F.apply(b, W || [])).next());
      });
    };
    Object.defineProperty(r, "__esModule", { value: !0 }), r.getIDToken = r.getState = r.saveState = r.group = r.endGroup = r.startGroup = r.info = r.notice = r.warning = r.error = r.debug = r.isDebug = r.setFailed = r.setCommandEcho = r.setOutput = r.getBooleanInput = r.getMultilineInput = r.getInput = r.addPath = r.setSecret = r.exportVariable = r.ExitCode = void 0;
    const i = zt, a = er, o = Et, s = A(L), l = A(L), c = hp();
    var u;
    (function(b) {
      b[b.Success = 0] = "Success", b[b.Failure = 1] = "Failure";
    })(u = r.ExitCode || (r.ExitCode = {}));
    function h(b, W) {
      const v = o.toCommandValue(W);
      if (process.env[b] = v, process.env.GITHUB_ENV || "")
        return a.issueFileCommand("ENV", a.prepareKeyValueMessage(b, W));
      i.issueCommand("set-env", { name: b }, v);
    }
    r.exportVariable = h;
    function g(b) {
      i.issueCommand("add-mask", {}, b);
    }
    r.setSecret = g;
    function d(b) {
      process.env.GITHUB_PATH || "" ? a.issueFileCommand("PATH", b) : i.issueCommand("add-path", {}, b), process.env.PATH = `${b}${l.delimiter}${process.env.PATH}`;
    }
    r.addPath = d;
    function I(b, W) {
      const v = process.env[`INPUT_${b.replace(/ /g, "_").toUpperCase()}`] || "";
      if (W && W.required && !v)
        throw new Error(`Input required and not supplied: ${b}`);
      return W && W.trimWhitespace === !1 ? v : v.trim();
    }
    r.getInput = I;
    function y(b, W) {
      const v = I(b, W).split(`
`).filter((F) => F !== "");
      return W && W.trimWhitespace === !1 ? v : v.map((F) => F.trim());
    }
    r.getMultilineInput = y;
    function Q(b, W) {
      const v = ["true", "True", "TRUE"], F = ["false", "False", "FALSE"], T = I(b, W);
      if (v.includes(T))
        return !0;
      if (F.includes(T))
        return !1;
      throw new TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${b}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
    }
    r.getBooleanInput = Q;
    function E(b, W) {
      if (process.env.GITHUB_OUTPUT || "")
        return a.issueFileCommand("OUTPUT", a.prepareKeyValueMessage(b, W));
      process.stdout.write(s.EOL), i.issueCommand("set-output", { name: b }, o.toCommandValue(W));
    }
    r.setOutput = E;
    function B(b) {
      i.issue("echo", b ? "on" : "off");
    }
    r.setCommandEcho = B;
    function w(b) {
      process.exitCode = u.Failure, p(b);
    }
    r.setFailed = w;
    function C() {
      return process.env.RUNNER_DEBUG === "1";
    }
    r.isDebug = C;
    function f(b) {
      i.issueCommand("debug", {}, b);
    }
    r.debug = f;
    function p(b, W = {}) {
      i.issueCommand("error", o.toCommandProperties(W), b instanceof Error ? b.toString() : b);
    }
    r.error = p;
    function m(b, W = {}) {
      i.issueCommand("warning", o.toCommandProperties(W), b instanceof Error ? b.toString() : b);
    }
    r.warning = m;
    function R(b, W = {}) {
      i.issueCommand("notice", o.toCommandProperties(W), b instanceof Error ? b.toString() : b);
    }
    r.notice = R;
    function P(b) {
      process.stdout.write(b + s.EOL);
    }
    r.info = P;
    function N(b) {
      i.issue("group", b);
    }
    r.startGroup = N;
    function $() {
      i.issue("endgroup");
    }
    r.endGroup = $;
    function V(b, W) {
      return n(this, void 0, void 0, function* () {
        N(b);
        let v;
        try {
          v = yield W();
        } finally {
          $();
        }
        return v;
      });
    }
    r.group = V;
    function ne(b, W) {
      if (process.env.GITHUB_STATE || "")
        return a.issueFileCommand("STATE", a.prepareKeyValueMessage(b, W));
      i.issueCommand("save-state", { name: b }, o.toCommandValue(W));
    }
    r.saveState = ne;
    function _(b) {
      return process.env[`STATE_${b}`] || "";
    }
    r.getState = _;
    function X(b) {
      return n(this, void 0, void 0, function* () {
        return yield c.OidcClient.getIDToken(b);
      });
    }
    r.getIDToken = X;
    var te = au();
    Object.defineProperty(r, "summary", { enumerable: !0, get: function() {
      return te.summary;
    } });
    var ee = au();
    Object.defineProperty(r, "markdownSummary", { enumerable: !0, get: function() {
      return ee.markdownSummary;
    } });
    var Z = gp();
    Object.defineProperty(r, "toPosixPath", { enumerable: !0, get: function() {
      return Z.toPosixPath;
    } }), Object.defineProperty(r, "toWin32Path", { enumerable: !0, get: function() {
      return Z.toWin32Path;
    } }), Object.defineProperty(r, "toPlatformPath", { enumerable: !0, get: function() {
      return Z.toPlatformPath;
    } });
  }(Ba)), Ba;
}
var jt = yg(), oi = {};
function Ep(r) {
  throw new Error('Could not dynamically require "' + r + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var le = {}, Qs = { exports: {} }, mg = { exports: {} };
(function(r) {
  r.exports = t;
  function t(A) {
    if (A)
      return e(A);
  }
  function e(A) {
    for (var n in t.prototype)
      A[n] = t.prototype[n];
    return A;
  }
  t.prototype.on = t.prototype.addEventListener = function(A, n) {
    return this._callbacks = this._callbacks || {}, (this._callbacks["$" + A] = this._callbacks["$" + A] || []).push(n), this;
  }, t.prototype.once = function(A, n) {
    function i() {
      this.off(A, i), n.apply(this, arguments);
    }
    return i.fn = n, this.on(A, i), this;
  }, t.prototype.off = t.prototype.removeListener = t.prototype.removeAllListeners = t.prototype.removeEventListener = function(A, n) {
    if (this._callbacks = this._callbacks || {}, arguments.length == 0)
      return this._callbacks = {}, this;
    var i = this._callbacks["$" + A];
    if (!i)
      return this;
    if (arguments.length == 1)
      return delete this._callbacks["$" + A], this;
    for (var a, o = 0; o < i.length; o++)
      if (a = i[o], a === n || a.fn === n) {
        i.splice(o, 1);
        break;
      }
    return i.length === 0 && delete this._callbacks["$" + A], this;
  }, t.prototype.emit = function(A) {
    this._callbacks = this._callbacks || {};
    for (var n = new Array(arguments.length - 1), i = this._callbacks["$" + A], a = 1; a < arguments.length; a++)
      n[a - 1] = arguments[a];
    if (i) {
      i = i.slice(0);
      for (var a = 0, o = i.length; a < o; ++a)
        i[a].apply(this, n);
    }
    return this;
  }, t.prototype.listeners = function(A) {
    return this._callbacks = this._callbacks || {}, this._callbacks["$" + A] || [];
  }, t.prototype.hasListeners = function(A) {
    return !!this.listeners(A).length;
  };
})(mg);
var Cp = mg.exports, fp = Dr;
Dr.default = Dr;
Dr.stable = kg;
Dr.stableStringify = kg;
var Ci = "[...]", wg = "[Circular]", St = [], Tt = [];
function vg() {
  return {
    depthLimit: Number.MAX_SAFE_INTEGER,
    edgesLimit: Number.MAX_SAFE_INTEGER
  };
}
function Dr(r, t, e, A) {
  typeof A > "u" && (A = vg()), Bs(r, "", 0, [], void 0, 0, A);
  var n;
  try {
    Tt.length === 0 ? n = JSON.stringify(r, t, e) : n = JSON.stringify(r, bg(t), e);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; St.length !== 0; ) {
      var i = St.pop();
      i.length === 4 ? Object.defineProperty(i[0], i[1], i[3]) : i[0][i[1]] = i[2];
    }
  }
  return n;
}
function Kt(r, t, e, A) {
  var n = Object.getOwnPropertyDescriptor(A, e);
  n.get !== void 0 ? n.configurable ? (Object.defineProperty(A, e, { value: r }), St.push([A, e, t, n])) : Tt.push([t, e, r]) : (A[e] = r, St.push([A, e, t]));
}
function Bs(r, t, e, A, n, i, a) {
  i += 1;
  var o;
  if (typeof r == "object" && r !== null) {
    for (o = 0; o < A.length; o++)
      if (A[o] === r) {
        Kt(wg, r, t, n);
        return;
      }
    if (typeof a.depthLimit < "u" && i > a.depthLimit) {
      Kt(Ci, r, t, n);
      return;
    }
    if (typeof a.edgesLimit < "u" && e + 1 > a.edgesLimit) {
      Kt(Ci, r, t, n);
      return;
    }
    if (A.push(r), Array.isArray(r))
      for (o = 0; o < r.length; o++)
        Bs(r[o], o, o, A, r, i, a);
    else {
      var s = Object.keys(r);
      for (o = 0; o < s.length; o++) {
        var l = s[o];
        Bs(r[l], l, o, A, r, i, a);
      }
    }
    A.pop();
  }
}
function Qp(r, t) {
  return r < t ? -1 : r > t ? 1 : 0;
}
function kg(r, t, e, A) {
  typeof A > "u" && (A = vg());
  var n = Is(r, "", 0, [], void 0, 0, A) || r, i;
  try {
    Tt.length === 0 ? i = JSON.stringify(n, t, e) : i = JSON.stringify(n, bg(t), e);
  } catch {
    return JSON.stringify("[unable to serialize, circular reference is too complex to analyze]");
  } finally {
    for (; St.length !== 0; ) {
      var a = St.pop();
      a.length === 4 ? Object.defineProperty(a[0], a[1], a[3]) : a[0][a[1]] = a[2];
    }
  }
  return i;
}
function Is(r, t, e, A, n, i, a) {
  i += 1;
  var o;
  if (typeof r == "object" && r !== null) {
    for (o = 0; o < A.length; o++)
      if (A[o] === r) {
        Kt(wg, r, t, n);
        return;
      }
    try {
      if (typeof r.toJSON == "function")
        return;
    } catch {
      return;
    }
    if (typeof a.depthLimit < "u" && i > a.depthLimit) {
      Kt(Ci, r, t, n);
      return;
    }
    if (typeof a.edgesLimit < "u" && e + 1 > a.edgesLimit) {
      Kt(Ci, r, t, n);
      return;
    }
    if (A.push(r), Array.isArray(r))
      for (o = 0; o < r.length; o++)
        Is(r[o], o, o, A, r, i, a);
    else {
      var s = {}, l = Object.keys(r).sort(Qp);
      for (o = 0; o < l.length; o++) {
        var c = l[o];
        Is(r[c], c, o, A, r, i, a), s[c] = r[c];
      }
      if (typeof n < "u")
        St.push([n, t, r]), n[t] = s;
      else
        return s;
    }
    A.pop();
  }
}
function bg(r) {
  return r = typeof r < "u" ? r : function(t, e) {
    return e;
  }, function(t, e) {
    if (Tt.length > 0)
      for (var A = 0; A < Tt.length; A++) {
        var n = Tt[A];
        if (n[1] === t && n[0] === e) {
          e = n[2], Tt.splice(A, 1);
          break;
        }
      }
    return r.call(this, t, e);
  };
}
function si(r) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? si = function(e) {
    return typeof e;
  } : si = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, si(r);
}
function Bp(r) {
  return r !== null && si(r) === "object";
}
var Tg = Bp;
function ci(r) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ci = function(e) {
    return typeof e;
  } : ci = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, ci(r);
}
var fi = Tg, Ip = fe;
function fe(r) {
  if (r)
    return dp(r);
}
function dp(r) {
  for (var t in fe.prototype)
    Object.prototype.hasOwnProperty.call(fe.prototype, t) && (r[t] = fe.prototype[t]);
  return r;
}
fe.prototype.clearTimeout = function() {
  return clearTimeout(this._timer), clearTimeout(this._responseTimeoutTimer), clearTimeout(this._uploadTimeoutTimer), delete this._timer, delete this._responseTimeoutTimer, delete this._uploadTimeoutTimer, this;
};
fe.prototype.parse = function(r) {
  return this._parser = r, this;
};
fe.prototype.responseType = function(r) {
  return this._responseType = r, this;
};
fe.prototype.serialize = function(r) {
  return this._serializer = r, this;
};
fe.prototype.timeout = function(r) {
  if (!r || ci(r) !== "object")
    return this._timeout = r, this._responseTimeout = 0, this._uploadTimeout = 0, this;
  for (var t in r)
    if (Object.prototype.hasOwnProperty.call(r, t))
      switch (t) {
        case "deadline":
          this._timeout = r.deadline;
          break;
        case "response":
          this._responseTimeout = r.response;
          break;
        case "upload":
          this._uploadTimeout = r.upload;
          break;
        default:
          console.warn("Unknown timeout option", t);
      }
  return this;
};
fe.prototype.retry = function(r, t) {
  return (arguments.length === 0 || r === !0) && (r = 1), r <= 0 && (r = 0), this._maxRetries = r, this._retries = 0, this._retryCallback = t, this;
};
var pp = ["ECONNRESET", "ETIMEDOUT", "EADDRINFO", "ESOCKETTIMEDOUT"];
fe.prototype._shouldRetry = function(r, t) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries)
    return !1;
  if (this._retryCallback)
    try {
      var e = this._retryCallback(r, t);
      if (e === !0)
        return !0;
      if (e === !1)
        return !1;
    } catch (A) {
      console.error(A);
    }
  return !!(t && t.status && t.status >= 500 && t.status !== 501 || r && (r.code && pp.includes(r.code) || r.timeout && r.code === "ECONNABORTED" || r.crossDomain));
};
fe.prototype._retry = function() {
  return this.clearTimeout(), this.req && (this.req = null, this.req = this.request()), this._aborted = !1, this.timedout = !1, this.timedoutError = null, this._end();
};
fe.prototype.then = function(r, t) {
  var e = this;
  if (!this._fullfilledPromise) {
    var A = this;
    this._endCalled && console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"), this._fullfilledPromise = new Promise(function(n, i) {
      A.on("abort", function() {
        if (!(e._maxRetries && e._maxRetries > e._retries)) {
          if (e.timedout && e.timedoutError) {
            i(e.timedoutError);
            return;
          }
          var a = new Error("Aborted");
          a.code = "ABORTED", a.status = e.status, a.method = e.method, a.url = e.url, i(a);
        }
      }), A.end(function(a, o) {
        a ? i(a) : n(o);
      });
    });
  }
  return this._fullfilledPromise.then(r, t);
};
fe.prototype.catch = function(r) {
  return this.then(void 0, r);
};
fe.prototype.use = function(r) {
  return r(this), this;
};
fe.prototype.ok = function(r) {
  if (typeof r != "function")
    throw new Error("Callback required");
  return this._okCallback = r, this;
};
fe.prototype._isResponseOK = function(r) {
  return r ? this._okCallback ? this._okCallback(r) : r.status >= 200 && r.status < 300 : !1;
};
fe.prototype.get = function(r) {
  return this._header[r.toLowerCase()];
};
fe.prototype.getHeader = fe.prototype.get;
fe.prototype.set = function(r, t) {
  if (fi(r)) {
    for (var e in r)
      Object.prototype.hasOwnProperty.call(r, e) && this.set(e, r[e]);
    return this;
  }
  return this._header[r.toLowerCase()] = t, this.header[r] = t, this;
};
fe.prototype.unset = function(r) {
  return delete this._header[r.toLowerCase()], delete this.header[r], this;
};
fe.prototype.field = function(r, t) {
  if (r == null)
    throw new Error(".field(name, val) name can not be empty");
  if (this._data)
    throw new Error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  if (fi(r)) {
    for (var e in r)
      Object.prototype.hasOwnProperty.call(r, e) && this.field(e, r[e]);
    return this;
  }
  if (Array.isArray(t)) {
    for (var A in t)
      Object.prototype.hasOwnProperty.call(t, A) && this.field(r, t[A]);
    return this;
  }
  if (t == null)
    throw new Error(".field(name, val) val can not be empty");
  return typeof t == "boolean" && (t = String(t)), this._getFormData().append(r, t), this;
};
fe.prototype.abort = function() {
  return this._aborted ? this : (this._aborted = !0, this.xhr && this.xhr.abort(), this.req && this.req.abort(), this.clearTimeout(), this.emit("abort"), this);
};
fe.prototype._auth = function(r, t, e, A) {
  switch (e.type) {
    case "basic":
      this.set("Authorization", "Basic ".concat(A("".concat(r, ":").concat(t))));
      break;
    case "auto":
      this.username = r, this.password = t;
      break;
    case "bearer":
      this.set("Authorization", "Bearer ".concat(r));
      break;
  }
  return this;
};
fe.prototype.withCredentials = function(r) {
  return r === void 0 && (r = !0), this._withCredentials = r, this;
};
fe.prototype.redirects = function(r) {
  return this._maxRedirects = r, this;
};
fe.prototype.maxResponseSize = function(r) {
  if (typeof r != "number")
    throw new TypeError("Invalid argument");
  return this._maxResponseSize = r, this;
};
fe.prototype.toJSON = function() {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header
  };
};
fe.prototype.send = function(r) {
  var t = fi(r), e = this._header["content-type"];
  if (this._formData)
    throw new Error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  if (t && !this._data)
    Array.isArray(r) ? this._data = [] : this._isHost(r) || (this._data = {});
  else if (r && this._data && this._isHost(this._data))
    throw new Error("Can't merge these send calls");
  if (t && fi(this._data))
    for (var A in r)
      Object.prototype.hasOwnProperty.call(r, A) && (this._data[A] = r[A]);
  else
    typeof r == "string" ? (e || this.type("form"), e = this._header["content-type"], e === "application/x-www-form-urlencoded" ? this._data = this._data ? "".concat(this._data, "&").concat(r) : r : this._data = (this._data || "") + r) : this._data = r;
  return !t || this._isHost(r) ? this : (e || this.type("json"), this);
};
fe.prototype.sortQuery = function(r) {
  return this._sort = typeof r > "u" ? !0 : r, this;
};
fe.prototype._finalizeQueryString = function() {
  var r = this._query.join("&");
  if (r && (this.url += (this.url.includes("?") ? "&" : "?") + r), this._query.length = 0, this._sort) {
    var t = this.url.indexOf("?");
    if (t >= 0) {
      var e = this.url.slice(t + 1).split("&");
      typeof this._sort == "function" ? e.sort(this._sort) : e.sort(), this.url = this.url.slice(0, t) + "?" + e.join("&");
    }
  }
};
fe.prototype._appendQueryString = function() {
  console.warn("Unsupported");
};
fe.prototype._timeoutError = function(r, t, e) {
  if (!this._aborted) {
    var A = new Error("".concat(r + t, "ms exceeded"));
    A.timeout = t, A.code = "ECONNABORTED", A.errno = e, this.timedout = !0, this.timedoutError = A, this.abort(), this.callback(A);
  }
};
fe.prototype._setTimeouts = function() {
  var r = this;
  this._timeout && !this._timer && (this._timer = setTimeout(function() {
    r._timeoutError("Timeout of ", r._timeout, "ETIME");
  }, this._timeout)), this._responseTimeout && !this._responseTimeoutTimer && (this._responseTimeoutTimer = setTimeout(function() {
    r._timeoutError("Response timeout of ", r._responseTimeout, "ETIMEDOUT");
  }, this._responseTimeout));
};
var mn = {};
mn.type = function(r) {
  return r.split(/ *; */).shift();
};
mn.params = function(r) {
  return r.split(/ *; */).reduce(function(t, e) {
    var A = e.split(/ *= */), n = A.shift(), i = A.shift();
    return n && i && (t[n] = i), t;
  }, {});
};
mn.parseLinks = function(r) {
  return r.split(/ *, */).reduce(function(t, e) {
    var A = e.split(/ *; */), n = A[0].slice(1, -1), i = A[1].split(/ *= */)[1].slice(1, -1);
    return t[i] = n, t;
  }, {});
};
mn.cleanHeader = function(r, t) {
  return delete r["content-type"], delete r["content-length"], delete r["transfer-encoding"], delete r.host, t && (delete r.authorization, delete r.cookie), r;
};
var Ko = mn, yp = Dt;
function Dt(r) {
  if (r)
    return mp(r);
}
function mp(r) {
  for (var t in Dt.prototype)
    Object.prototype.hasOwnProperty.call(Dt.prototype, t) && (r[t] = Dt.prototype[t]);
  return r;
}
Dt.prototype.get = function(r) {
  return this.header[r.toLowerCase()];
};
Dt.prototype._setHeaderProperties = function(r) {
  var t = r["content-type"] || "";
  this.type = Ko.type(t);
  var e = Ko.params(t);
  for (var A in e)
    Object.prototype.hasOwnProperty.call(e, A) && (this[A] = e[A]);
  this.links = {};
  try {
    r.link && (this.links = Ko.parseLinks(r.link));
  } catch {
  }
};
Dt.prototype._setStatusProperties = function(r) {
  var t = r / 100 | 0;
  this.statusCode = r, this.status = this.statusCode, this.statusType = t, this.info = t === 1, this.ok = t === 2, this.redirect = t === 3, this.clientError = t === 4, this.serverError = t === 5, this.error = t === 4 || t === 5 ? this.toError() : !1, this.created = r === 201, this.accepted = r === 202, this.noContent = r === 204, this.badRequest = r === 400, this.unauthorized = r === 401, this.notAcceptable = r === 406, this.forbidden = r === 403, this.notFound = r === 404, this.unprocessableEntity = r === 422;
};
function wp(r) {
  return Tp(r) || bp(r) || kp(r) || vp();
}
function vp() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function kp(r, t) {
  if (r) {
    if (typeof r == "string")
      return ds(r, t);
    var e = Object.prototype.toString.call(r).slice(8, -1);
    if (e === "Object" && r.constructor && (e = r.constructor.name), e === "Map" || e === "Set")
      return Array.from(r);
    if (e === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e))
      return ds(r, t);
  }
}
function bp(r) {
  if (typeof Symbol < "u" && Symbol.iterator in Object(r))
    return Array.from(r);
}
function Tp(r) {
  if (Array.isArray(r))
    return ds(r);
}
function ds(r, t) {
  (t == null || t > r.length) && (t = r.length);
  for (var e = 0, A = new Array(t); e < t; e++)
    A[e] = r[e];
  return A;
}
function Ws() {
  this._defaults = [];
}
["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects", "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert", "disableTLSCerts"].forEach(function(r) {
  Ws.prototype[r] = function() {
    for (var t = arguments.length, e = new Array(t), A = 0; A < t; A++)
      e[A] = arguments[A];
    return this._defaults.push({
      fn: r,
      args: e
    }), this;
  };
});
Ws.prototype._setDefaults = function(r) {
  this._defaults.forEach(function(t) {
    r[t.fn].apply(r, wp(t.args));
  });
};
var Fp = Ws;
(function(r, t) {
  function e(C) {
    "@babel/helpers - typeof";
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? e = function(p) {
      return typeof p;
    } : e = function(p) {
      return p && typeof Symbol == "function" && p.constructor === Symbol && p !== Symbol.prototype ? "symbol" : typeof p;
    }, e(C);
  }
  var A;
  typeof window < "u" ? A = window : typeof self > "u" ? (console.warn("Using browser-only version of superagent in non-browser environment"), A = void 0) : A = self;
  var n = Cp, i = fp, a = Ip, o = Tg, s = yp, l = Fp;
  function c() {
  }
  r.exports = function(C, f) {
    return typeof f == "function" ? new t.Request("GET", C).end(f) : arguments.length === 1 ? new t.Request("GET", C) : new t.Request(C, f);
  }, t = r.exports;
  var u = t;
  t.Request = B, u.getXHR = function() {
    if (A.XMLHttpRequest && (!A.location || A.location.protocol !== "file:" || !A.ActiveXObject))
      return new XMLHttpRequest();
    try {
      return new ActiveXObject("Microsoft.XMLHTTP");
    } catch {
    }
    try {
      return new ActiveXObject("Msxml2.XMLHTTP.6.0");
    } catch {
    }
    try {
      return new ActiveXObject("Msxml2.XMLHTTP.3.0");
    } catch {
    }
    try {
      return new ActiveXObject("Msxml2.XMLHTTP");
    } catch {
    }
    throw new Error("Browser-only version of superagent could not find XHR");
  };
  var h = "".trim ? function(C) {
    return C.trim();
  } : function(C) {
    return C.replace(/(^\s*|\s*$)/g, "");
  };
  function g(C) {
    if (!o(C))
      return C;
    var f = [];
    for (var p in C)
      Object.prototype.hasOwnProperty.call(C, p) && d(f, p, C[p]);
    return f.join("&");
  }
  function d(C, f, p) {
    if (p !== void 0) {
      if (p === null) {
        C.push(encodeURI(f));
        return;
      }
      if (Array.isArray(p))
        p.forEach(function(R) {
          d(C, f, R);
        });
      else if (o(p))
        for (var m in p)
          Object.prototype.hasOwnProperty.call(p, m) && d(C, "".concat(f, "[").concat(m, "]"), p[m]);
      else
        C.push(encodeURI(f) + "=" + encodeURIComponent(p));
    }
  }
  u.serializeObject = g;
  function I(C) {
    for (var f = {}, p = C.split("&"), m, R, P = 0, N = p.length; P < N; ++P)
      m = p[P], R = m.indexOf("="), R === -1 ? f[decodeURIComponent(m)] = "" : f[decodeURIComponent(m.slice(0, R))] = decodeURIComponent(m.slice(R + 1));
    return f;
  }
  u.parseString = I, u.types = {
    html: "text/html",
    json: "application/json",
    xml: "text/xml",
    urlencoded: "application/x-www-form-urlencoded",
    form: "application/x-www-form-urlencoded",
    "form-data": "application/x-www-form-urlencoded"
  }, u.serialize = {
    "application/x-www-form-urlencoded": g,
    "application/json": i
  }, u.parse = {
    "application/x-www-form-urlencoded": I,
    "application/json": JSON.parse
  };
  function y(C) {
    for (var f = C.split(/\r?\n/), p = {}, m, R, P, N, $ = 0, V = f.length; $ < V; ++$)
      R = f[$], m = R.indexOf(":"), m !== -1 && (P = R.slice(0, m).toLowerCase(), N = h(R.slice(m + 1)), p[P] = N);
    return p;
  }
  function Q(C) {
    return /[/+]json($|[^-\w])/.test(C);
  }
  function E(C) {
    this.req = C, this.xhr = this.req.xhr, this.text = this.req.method !== "HEAD" && (this.xhr.responseType === "" || this.xhr.responseType === "text") || typeof this.xhr.responseType > "u" ? this.xhr.responseText : null, this.statusText = this.req.xhr.statusText;
    var f = this.xhr.status;
    f === 1223 && (f = 204), this._setStatusProperties(f), this.headers = y(this.xhr.getAllResponseHeaders()), this.header = this.headers, this.header["content-type"] = this.xhr.getResponseHeader("content-type"), this._setHeaderProperties(this.header), this.text === null && C._responseType ? this.body = this.xhr.response : this.body = this.req.method === "HEAD" ? null : this._parseBody(this.text ? this.text : this.xhr.response);
  }
  s(E.prototype), E.prototype._parseBody = function(C) {
    var f = u.parse[this.type];
    return this.req._parser ? this.req._parser(this, C) : (!f && Q(this.type) && (f = u.parse["application/json"]), f && C && (C.length > 0 || C instanceof Object) ? f(C) : null);
  }, E.prototype.toError = function() {
    var C = this.req, f = C.method, p = C.url, m = "cannot ".concat(f, " ").concat(p, " (").concat(this.status, ")"), R = new Error(m);
    return R.status = this.status, R.method = f, R.url = p, R;
  }, u.Response = E;
  function B(C, f) {
    var p = this;
    this._query = this._query || [], this.method = C, this.url = f, this.header = {}, this._header = {}, this.on("end", function() {
      var m = null, R = null;
      try {
        R = new E(p);
      } catch (N) {
        return m = new Error("Parser is unable to parse the response"), m.parse = !0, m.original = N, p.xhr ? (m.rawResponse = typeof p.xhr.responseType > "u" ? p.xhr.responseText : p.xhr.response, m.status = p.xhr.status ? p.xhr.status : null, m.statusCode = m.status) : (m.rawResponse = null, m.status = null), p.callback(m);
      }
      p.emit("response", R);
      var P;
      try {
        p._isResponseOK(R) || (P = new Error(R.statusText || R.text || "Unsuccessful HTTP response"));
      } catch (N) {
        P = N;
      }
      P ? (P.original = m, P.response = R, P.status = R.status, p.callback(P, R)) : p.callback(null, R);
    });
  }
  n(B.prototype), a(B.prototype), B.prototype.type = function(C) {
    return this.set("Content-Type", u.types[C] || C), this;
  }, B.prototype.accept = function(C) {
    return this.set("Accept", u.types[C] || C), this;
  }, B.prototype.auth = function(C, f, p) {
    arguments.length === 1 && (f = ""), e(f) === "object" && f !== null && (p = f, f = ""), p || (p = {
      type: typeof btoa == "function" ? "basic" : "auto"
    });
    var m = function(P) {
      if (typeof btoa == "function")
        return btoa(P);
      throw new Error("Cannot use basic auth, btoa is not a function");
    };
    return this._auth(C, f, p, m);
  }, B.prototype.query = function(C) {
    return typeof C != "string" && (C = g(C)), C && this._query.push(C), this;
  }, B.prototype.attach = function(C, f, p) {
    if (f) {
      if (this._data)
        throw new Error("superagent can't mix .send() and .attach()");
      this._getFormData().append(C, f, p || f.name);
    }
    return this;
  }, B.prototype._getFormData = function() {
    return this._formData || (this._formData = new A.FormData()), this._formData;
  }, B.prototype.callback = function(C, f) {
    if (this._shouldRetry(C, f))
      return this._retry();
    var p = this._callback;
    this.clearTimeout(), C && (this._maxRetries && (C.retries = this._retries - 1), this.emit("error", C)), p(C, f);
  }, B.prototype.crossDomainError = function() {
    var C = new Error(`Request has been terminated
Possible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.`);
    C.crossDomain = !0, C.status = this.status, C.method = this.method, C.url = this.url, this.callback(C);
  }, B.prototype.agent = function() {
    return console.warn("This is not supported in browser version of superagent"), this;
  }, B.prototype.ca = B.prototype.agent, B.prototype.buffer = B.prototype.ca, B.prototype.write = function() {
    throw new Error("Streaming is not supported in browser version of superagent");
  }, B.prototype.pipe = B.prototype.write, B.prototype._isHost = function(C) {
    return C && e(C) === "object" && !Array.isArray(C) && Object.prototype.toString.call(C) !== "[object Object]";
  }, B.prototype.end = function(C) {
    this._endCalled && console.warn("Warning: .end() was called twice. This is not supported in superagent"), this._endCalled = !0, this._callback = C || c, this._finalizeQueryString(), this._end();
  }, B.prototype._setUploadTimeout = function() {
    var C = this;
    this._uploadTimeout && !this._uploadTimeoutTimer && (this._uploadTimeoutTimer = setTimeout(function() {
      C._timeoutError("Upload timeout of ", C._uploadTimeout, "ETIMEDOUT");
    }, this._uploadTimeout));
  }, B.prototype._end = function() {
    if (this._aborted)
      return this.callback(new Error("The request has been aborted even before .end() was called"));
    var C = this;
    this.xhr = u.getXHR();
    var f = this.xhr, p = this._formData || this._data;
    this._setTimeouts(), f.onreadystatechange = function() {
      var $ = f.readyState;
      if ($ >= 2 && C._responseTimeoutTimer && clearTimeout(C._responseTimeoutTimer), $ === 4) {
        var V;
        try {
          V = f.status;
        } catch {
          V = 0;
        }
        if (!V)
          return C.timedout || C._aborted ? void 0 : C.crossDomainError();
        C.emit("end");
      }
    };
    var m = function(V, ne) {
      ne.total > 0 && (ne.percent = ne.loaded / ne.total * 100, ne.percent === 100 && clearTimeout(C._uploadTimeoutTimer)), ne.direction = V, C.emit("progress", ne);
    };
    if (this.hasListeners("progress"))
      try {
        f.addEventListener("progress", m.bind(null, "download")), f.upload && f.upload.addEventListener("progress", m.bind(null, "upload"));
      } catch {
      }
    f.upload && this._setUploadTimeout();
    try {
      this.username && this.password ? f.open(this.method, this.url, !0, this.username, this.password) : f.open(this.method, this.url, !0);
    } catch ($) {
      return this.callback($);
    }
    if (this._withCredentials && (f.withCredentials = !0), !this._formData && this.method !== "GET" && this.method !== "HEAD" && typeof p != "string" && !this._isHost(p)) {
      var R = this._header["content-type"], P = this._serializer || u.serialize[R ? R.split(";")[0] : ""];
      !P && Q(R) && (P = u.serialize["application/json"]), P && (p = P(p));
    }
    for (var N in this.header)
      this.header[N] !== null && Object.prototype.hasOwnProperty.call(this.header, N) && f.setRequestHeader(N, this.header[N]);
    this._responseType && (f.responseType = this._responseType), this.emit("request", this), f.send(typeof p > "u" ? null : p);
  }, u.agent = function() {
    return new l();
  }, ["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function(C) {
    l.prototype[C.toLowerCase()] = function(f, p) {
      var m = new u.Request(C, f);
      return this._setDefaults(m), p && m.end(p), m;
    };
  }), l.prototype.del = l.prototype.delete, u.get = function(C, f, p) {
    var m = u("GET", C);
    return typeof f == "function" && (p = f, f = null), f && m.query(f), p && m.end(p), m;
  }, u.head = function(C, f, p) {
    var m = u("HEAD", C);
    return typeof f == "function" && (p = f, f = null), f && m.query(f), p && m.end(p), m;
  }, u.options = function(C, f, p) {
    var m = u("OPTIONS", C);
    return typeof f == "function" && (p = f, f = null), f && m.send(f), p && m.end(p), m;
  };
  function w(C, f, p) {
    var m = u("DELETE", C);
    return typeof f == "function" && (p = f, f = null), f && m.send(f), p && m.end(p), m;
  }
  u.del = w, u.delete = w, u.patch = function(C, f, p) {
    var m = u("PATCH", C);
    return typeof f == "function" && (p = f, f = null), f && m.send(f), p && m.end(p), m;
  }, u.post = function(C, f, p) {
    var m = u("POST", C);
    return typeof f == "function" && (p = f, f = null), f && m.send(f), p && m.end(p), m;
  }, u.put = function(C, f, p) {
    var m = u("PUT", C);
    return typeof f == "function" && (p = f, f = null), f && m.send(f), p && m.end(p), m;
  };
})(Qs, Qs.exports);
var Rp = Qs.exports;
Object.defineProperty(le, "__esModule", {
  value: !0
});
le.ApiClient = void 0;
var cu = Dp(Rp);
function Dp(r) {
  return r && r.__esModule ? r : { default: r };
}
function Ut(r) {
  "@babel/helpers - typeof";
  return Ut = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ut(r);
}
function Np(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function lu(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Fg(A.key), A);
  }
}
function Sp(r, t, e) {
  return t && lu(r.prototype, t), e && lu(r, e), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Up(r, t, e) {
  return t = Fg(t), t in r ? Object.defineProperty(r, t, { value: e, enumerable: !0, configurable: !0, writable: !0 }) : r[t] = e, r;
}
function Fg(r) {
  var t = Pp(r, "string");
  return Ut(t) == "symbol" ? t : t + "";
}
function Pp(r, t) {
  if (Ut(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t || "default");
    if (Ut(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(r);
}
var ps = le.ApiClient = /* @__PURE__ */ function() {
  function r() {
    Np(this, r), this.basePath = "https://app.asana.com/api/1.0".replace(/\/+$/, ""), this.RETURN_COLLECTION = !0, this.authentications = {
      // Add an option to support bearer OAS security definition
      token: {
        type: "personalAccessToken"
      }
    }, this.defaultHeaders = {}, this.timeout = 6e4, this.cache = !0, this.enableCookies = !1, typeof window > "u" && (this.agent = new cu.default.agent()), this.requestAgent = null;
  }
  return Sp(r, [{
    key: "paramToString",
    value: function(e) {
      return e == null || e == null ? "" : e instanceof Date ? e.toJSON() : e.toString();
    }
    /**
    * Builds full URL by appending the given path to the base URL and replacing path parameter place-holders with parameter values.
    * NOTE: query parameters are not handled here.
    * @param {String} path The path to append to the base URL.
    * @param {Object} pathParams The parameter values to append.
    * @returns {String} The encoded path with parameter values substituted.
    */
  }, {
    key: "buildUrl",
    value: function(e, A) {
      var n = this;
      e.match(/^\//) || (e = "/" + e);
      var i = this.basePath + e;
      return i = i.replace(/\{([\w-]+)\}/g, function(a, o) {
        var s;
        return A.hasOwnProperty(o) ? s = n.paramToString(A[o]) : s = a, encodeURIComponent(s);
      }), i;
    }
    /**
    * Checks whether the given content type represents JSON.<br>
    * JSON content type examples:<br>
    * <ul>
    * <li>application/json</li>
    * <li>application/json; charset=UTF8</li>
    * <li>APPLICATION/JSON</li>
    * </ul>
    * @param {String} contentType The MIME content type to check.
    * @returns {Boolean} <code>true</code> if <code>contentType</code> represents JSON, otherwise <code>false</code>.
    */
  }, {
    key: "isJsonMime",
    value: function(e) {
      return !!(e != null && e.match(/^application\/json(;.*)?$/i));
    }
    /**
    * Chooses a content type from the given array, with JSON preferred; i.e. return JSON if included, otherwise return the first.
    * @param {Array.<String>} contentTypes
    * @returns {String} The chosen content type, preferring JSON.
    */
  }, {
    key: "jsonPreferredMime",
    value: function(e) {
      for (var A = 0; A < e.length; A++)
        if (this.isJsonMime(e[A]))
          return e[A];
      return e[0];
    }
    /**
    * Checks whether the given parameter value represents file-like content.
    * @param param The parameter to check.
    * @returns {Boolean} <code>true</code> if <code>param</code> represents a file.
    */
  }, {
    key: "isFileParam",
    value: function(e) {
      if (typeof Ep == "function") {
        var A;
        try {
          A = L;
        } catch {
        }
        if (A && A.ReadStream && e instanceof A.ReadStream)
          return !0;
      }
      return typeof Buffer == "function" && e instanceof Buffer || typeof Blob == "function" && e instanceof Blob || typeof File == "function" && e instanceof File;
    }
    /**
    * Normalizes parameter values:
    * <ul>
    * <li>remove nils</li>
    * <li>keep files and arrays</li>
    * <li>format to string with `paramToString` for other cases</li>
    * </ul>
    * @param {Object.<String, Object>} params The parameters as object properties.
    * @returns {Object.<String, Object>} normalized parameters.
    */
  }, {
    key: "normalizeParams",
    value: function(e) {
      var A = {};
      for (var n in e)
        if (e.hasOwnProperty(n) && e[n] != null && e[n] != null) {
          var i = e[n];
          this.isFileParam(i) || Array.isArray(i) ? A[n] = i : A[n] = this.paramToString(i);
        }
      return A;
    }
    /**
    * Enumeration of collection format separator strategies.
    * @enum {String}
    * @readonly
    */
  }, {
    key: "buildCollectionParam",
    value: (
      /**
      * Builds a string representation of an array-type actual parameter, according to the given collection format.
      * @param {Array} param An array parameter.
      * @param {module:ApiClient.CollectionFormatEnum} collectionFormat The array element separator strategy.
      * @returns {String|Array} A string representation of the supplied collection, using the specified delimiter. Returns
      * <code>param</code> as is if <code>collectionFormat</code> is <code>multi</code>.
      */
      function(e, A) {
        if (e == null)
          return null;
        switch (A) {
          case "csv":
            return e.map(this.paramToString).join(",");
          case "ssv":
            return e.map(this.paramToString).join(" ");
          case "tsv":
            return e.map(this.paramToString).join("	");
          case "pipes":
            return e.map(this.paramToString).join("|");
          case "multi":
            return e.map(this.paramToString);
          default:
            throw new Error("Unknown collection format: " + A);
        }
      }
    )
    /**
    * Applies authentication headers to the request.
    * @param {Object} request The request object created by a <code>superagent()</code> call.
    * @param {Array.<String>} authNames An array of authentication method names.
    */
  }, {
    key: "applyAuthToRequest",
    value: function(e, A) {
      var n = this;
      A.forEach(function(i) {
        var a = {};
        switch (i === "personalAccessToken" ? a = n.authentications.token : a = n.authentications[i], a.type) {
          case "basic":
            (a.username || a.password) && e.auth(a.username || "", a.password || "");
            break;
          case "apiKey":
            if (a.apiKey) {
              var o = {};
              a.apiKeyPrefix ? o[a.name] = a.apiKeyPrefix + " " + a.apiKey : o[a.name] = a.apiKey, a.in === "header" ? e.set(o) : e.query(o);
            }
            break;
          case "oauth2":
            a.accessToken && e.set({
              Authorization: "Bearer " + a.accessToken
            });
            break;
          case "personalAccessToken":
            a.accessToken && e.set({
              Authorization: "Bearer " + a.accessToken
            });
            break;
          default:
            throw new Error("Unknown authentication type: " + a.type);
        }
      });
    }
    /**
    * Deserializes an HTTP response body into a value of the specified type.
    * @param {Object} response A SuperAgent response object.
    * @param {(String|Array.<String>|Object.<String, Object>|Function)} returnType The type to return. Pass a string for simple types
    * or the constructor function for a complex type. Pass an array containing the type name to return an array of that type. To
    * return an object, pass an object with one property whose name is the key type and whose value is the corresponding value type:
    * all properties on <code>data<code> will be converted to this type.
    * @returns A value of the specified type.
    */
  }, {
    key: "deserialize",
    value: function(e, A) {
      if (e == null || A == null || e.status == 204)
        return null;
      var n = e.body;
      return (n == null || Ut(n) === "object" && typeof n.length > "u" && !Object.keys(n).length) && (n = e.text), r.convertToType(n, A);
    }
    /**
    * Invokes the REST service using the supplied settings and parameters.
    * @param {String} path The base URL to invoke.
    * @param {String} httpMethod The HTTP method to use.
    * @param {Object.<String, String>} pathParams A map of path parameters and their values.
    * @param {Object.<String, Object>} queryParams A map of query parameters and their values.
    * @param {Object.<String, Object>} headerParams A map of header parameters and their values.
    * @param {Object.<String, Object>} formParams A map of form parameters and their values.
    * @param {Object} bodyParam The value to pass as the request body.
    * @param {Array.<String>} authNames An array of authentication type names.
    * @param {Array.<String>} contentTypes An array of request MIME types.
    * @param {Array.<String>} accepts An array of acceptable response MIME types.
    * @param {(String|Array|ObjectFunction)} returnType The required type to return; can be a string for simple types or the
    * constructor for a complex type.
    * @returns {Promise} A {@link https://www.promisejs.org/|Promise} object.
    */
  }, {
    key: "callApi",
    value: function(e, A, n, i, a, o, s, l, c, u, h) {
      var g = this, d = this.buildUrl(e, n), I = (0, cu.default)(A, d);
      this.applyAuthToRequest(I, l), A.toUpperCase() === "GET" && this.cache === !1 && (i._ = (/* @__PURE__ */ new Date()).getTime()), I.query(this.normalizeParams(i)), typeof navigator > "u" || typeof window > "u" ? a["X-Asana-Client-Lib"] = new URLSearchParams({
        version: "3.0.4",
        language: "NodeJS",
        language_version: process.version,
        os: process.platform
      }).toString() : a["X-Asana-Client-Lib"] = new URLSearchParams({
        version: "3.0.4",
        language: "BrowserJS"
      }).toString(), I.set(this.defaultHeaders).set(this.normalizeParams(a)), this.requestAgent && I.agent(this.requestAgent), I.timeout(this.timeout);
      var y = this.jsonPreferredMime(c);
      if (y ? y != "multipart/form-data" && I.type(y) : I.header["Content-Type"] || I.type("application/json"), y === "application/x-www-form-urlencoded")
        I.send(new URLSearchParams(this.normalizeParams(o)).toString());
      else if (y == "multipart/form-data") {
        var Q = this.normalizeParams(o);
        for (var E in Q)
          Q.hasOwnProperty(E) && (this.isFileParam(Q[E]) ? I.attach(E, Q[E]) : I.field(E, Q[E]));
      } else
        s && (s.data.hasOwnProperty("_public") && (s.data.public = s.data._public, delete s.data._public), I.send(s));
      var B = this.jsonPreferredMime(u);
      return B && I.accept(B), this.enableCookies && (typeof window > "u" ? this.agent.attachCookies(I) : I.withCredentials()), new Promise(function(w, C) {
        I.end(function(f, p) {
          if (f)
            C(f);
          else
            try {
              var m = g.deserialize(p, h);
              g.enableCookies && typeof window > "u" && g.agent.saveCookies(p), w({
                data: m,
                response: p
              });
            } catch (R) {
              C(R);
            }
        });
      });
    }
    /**
    * Parses an ISO-8601 string representation of a date value.
    * @param {String} str The date value as a string.
    * @returns {Date} The parsed date object.
    */
  }], [{
    key: "parseDate",
    value: function(e) {
      return new Date(e);
    }
    /**
    * Converts a value to the specified type.
    * @param {(String|Object)} data The data to convert, as a string or object.
    * @param {(String|Array.<String>|Object.<String, Object>|Function)} type The type to return. Pass a string for simple types
    * or the constructor function for a complex type. Pass an array containing the type name to return an array of that type. To
    * return an object, pass an object with one property whose name is the key type and whose value is the corresponding value type:
    * all properties on <code>data<code> will be converted to this type.
    * @returns An instance of the specified type or null or undefined if data is null or undefined.
    */
  }, {
    key: "convertToType",
    value: function(e, A) {
      if (e == null)
        return e;
      switch (A) {
        case "Boolean":
          return !!e;
        case "Integer":
          return parseInt(e, 10);
        case "Number":
          return parseFloat(e);
        case "String":
          return String(e);
        case "Date":
          return r.parseDate(String(e));
        case "Blob":
          return e;
        default:
          if (A === Object)
            return e;
          if (typeof A == "function")
            return A.constructFromObject(e);
          if (Array.isArray(A)) {
            var n = A[0];
            return e.map(function(u) {
              return r.convertToType(u, n);
            });
          } else if (Ut(A) === "object") {
            var i, a;
            for (var o in A)
              if (A.hasOwnProperty(o)) {
                i = o, a = A[o];
                break;
              }
            var s = {};
            for (var o in e)
              if (e.hasOwnProperty(o)) {
                var l = r.convertToType(o, i), c = r.convertToType(e[o], a);
                s[l] = c;
              }
            return s;
          } else
            return e;
      }
    }
    /**
    * Constructs a new map or array model from REST data.
    * @param data {Object|Array} The REST data.
    * @param obj {Object|Array} The target object or array.
    */
  }, {
    key: "constructFromObject",
    value: function(e, A, n) {
      if (Array.isArray(e))
        for (var i = 0; i < e.length; i++)
          e.hasOwnProperty(i) && (A[i] = r.convertToType(e[i], n));
      else
        for (var a in e)
          e.hasOwnProperty(a) && (A[a] = r.convertToType(e[a], n));
    }
  }]);
}();
Up(ps, "CollectionFormatEnum", {
  /**
   * Comma-separated values. Value: <code>csv</code>
   * @const
   */
  CSV: ",",
  /**
   * Space-separated values. Value: <code>ssv</code>
   * @const
   */
  SSV: " ",
  /**
   * Tab-separated values. Value: <code>tsv</code>
   * @const
   */
  TSV: "	",
  /**
   * Pipe(|)-separated values. Value: <code>pipes</code>
   * @const
   */
  PIPES: "|",
  /**
   * Native array. Value: <code>multi</code>
   * @const
   */
  MULTI: "multi"
});
ps.instance = new ps();
var Ni = {};
function Nr(r) {
  "@babel/helpers - typeof";
  return Nr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Nr(r);
}
function Pt(r, t, e) {
  if (!Pt.isCollectionResponse(r.data.data))
    throw new Error("Cannot create Collection from response that does not have resources");
  this.data = r.data.data, this._response = r.data, this._apiClient = t, this._apiRequestData = e;
}
Pt.fromApiClient = function(r, t, e) {
  return r.then(function(A) {
    return new Pt(A, t, e);
  });
};
Pt.isCollectionResponse = function(r) {
  return Nr(r) === "object" && Nr(r) === "object" && typeof r.length == "number";
};
var de = Pt;
Pt.prototype.nextPage = function() {
  var r = this, t = r._response.next_page, e = r._apiRequestData;
  return Nr(t) === "object" && t !== null && r.data && r.data.length > 0 ? (e.queryParams.offset = t.offset, Pt.fromApiClient(r._apiClient.callApi(e.path, e.httpMethod, e.pathParams, e.queryParams, e.headerParams, e.formParams, e.bodyParam, e.authNames, e.contentTypes, e.accepts, e.returnType), r._apiClient, r._apiRequestData)) : Promise.resolve({
    data: null
  });
};
Object.defineProperty(Ni, "__esModule", {
  value: !0
});
Ni.AllocationsApi = void 0;
var Mp = le;
function Sr(r) {
  "@babel/helpers - typeof";
  return Sr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Sr(r);
}
function Lp(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Hp(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Wp(A.key), A);
  }
}
function Gp(r, t, e) {
  return t && Hp(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Wp(r) {
  var t = Yp(r, "string");
  return Sr(t) == "symbol" ? t : t + "";
}
function Yp(r, t) {
  if (Sr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Sr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var Jp = de;
Ni.AllocationsApi = /* @__PURE__ */ function() {
  function r(t) {
    Lp(this, r), this.apiClient = t || Mp.ApiClient.instance;
  }
  return Gp(r, [{
    key: "createAllocationWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createAllocation");
      var i = {}, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/allocations", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Create an allocation
     * Creates a new allocation.  Returns the full record of the newly created allocation.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The allocation to create.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AllocationResponseData}
     */
  }, {
    key: "createAllocation",
    value: function(e, A) {
      return this.createAllocationWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Delete an allocation
     * A specific, existing allocation can be deleted by making a DELETE request on the URL for that allocation.  Returns an empty data record.
     * @param {String} allocation_gid Globally unique identifier for the allocation.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deleteAllocationWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'allocation_gid' when calling deleteAllocation");
      var n = {
        allocation_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/allocations/{allocation_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete an allocation
     * A specific, existing allocation can be deleted by making a DELETE request on the URL for that allocation.  Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} allocation_gid Globally unique identifier for the allocation.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteAllocation",
    value: function(e) {
      return this.deleteAllocationWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get an allocation
     * Returns the complete allocation record for a single allocation.
     * @param {String} allocation_gid Globally unique identifier for the allocation.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getAllocationWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'allocation_gid' when calling getAllocation");
      var i = {
        allocation_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/allocations/{allocation_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get an allocation
     * Returns the complete allocation record for a single allocation.
     * @param {<&vendorExtensions.x-jsdoc-type>} allocation_gid Globally unique identifier for the allocation.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AllocationResponseData}
     */
  }, {
    key: "getAllocation",
    value: function(e, A) {
      return this.getAllocationWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get multiple allocations
     * Returns a list of allocations filtered to a specific project or user.
     * @param {Object} opts Optional parameters
     * @param {String} opts.parent Globally unique identifier for the project to filter allocations by.
     * @param {String} opts.assignee Globally unique identifier for the user the allocation is assigned to.
     * @param {String} opts.workspace Globally unique identifier for the workspace.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getAllocationsWithHttpInfo",
    value: function(e) {
      e = e || {};
      var A = null, n = {}, i = {};
      e = e || {}, i = e;
      var a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.RETURN_COLLECTION ? Jp.fromApiClient(this.apiClient.callApi("/allocations", "GET", n, i, a, o, A, s, l, c, u), this.apiClient, {
        path: "/allocations",
        httpMethod: "GET",
        pathParams: n,
        queryParams: i,
        headerParams: a,
        formParams: o,
        bodyParam: A,
        authNames: s,
        contentTypes: l,
        accepts: c,
        returnType: u
      }) : this.apiClient.callApi("/allocations", "GET", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Get multiple allocations
     * Returns a list of allocations filtered to a specific project or user.
     * @param {Object} opts Optional parameters
     * @param {String} opts.parent Globally unique identifier for the project to filter allocations by.
     * @param {String} opts.assignee Globally unique identifier for the user the allocation is assigned to.
     * @param {String} opts.workspace Globally unique identifier for the workspace.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AllocationResponseArray}
     */
  }, {
    key: "getAllocations",
    value: function(e) {
      return this.apiClient.RETURN_COLLECTION ? this.getAllocationsWithHttpInfo(e) : this.getAllocationsWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Update an allocation
     * An existing allocation can be updated by making a PUT request on the URL for that allocation. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated allocation record.
     * @param {module:model/Object} body The updated fields for the allocation.
     * @param {String} allocation_gid Globally unique identifier for the allocation.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateAllocationWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling updateAllocation");
      if (A == null)
        throw new Error("Missing the required parameter 'allocation_gid' when calling updateAllocation");
      var a = {
        allocation_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/allocations/{allocation_gid}", "PUT", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Update an allocation
     * An existing allocation can be updated by making a PUT request on the URL for that allocation. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated allocation record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The updated fields for the allocation.
     * @param {<&vendorExtensions.x-jsdoc-type>} allocation_gid Globally unique identifier for the allocation.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AllocationResponseData}
     */
  }, {
    key: "updateAllocation",
    value: function(e, A, n) {
      return this.updateAllocationWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
  }]);
}();
var Si = {};
Object.defineProperty(Si, "__esModule", {
  value: !0
});
Si.AttachmentsApi = void 0;
var _p = le;
function Ur(r) {
  "@babel/helpers - typeof";
  return Ur = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ur(r);
}
function xp(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Op(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, jp(A.key), A);
  }
}
function qp(r, t, e) {
  return t && Op(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function jp(r) {
  var t = Vp(r, "string");
  return Ur(t) == "symbol" ? t : t + "";
}
function Vp(r, t) {
  if (Ur(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Ur(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var $p = de;
Si.AttachmentsApi = /* @__PURE__ */ function() {
  function r(t) {
    xp(this, r), this.apiClient = t || _p.ApiClient.instance;
  }
  return qp(r, [{
    key: "createAttachmentForObjectWithHttpInfo",
    value: function(e) {
      e = e || {};
      var A = null, n = {}, i = {};
      e = e || {}, i = e;
      var a = {}, o = {
        resource_subtype: e.resource_subtype,
        file: e.file,
        parent: e.parent,
        url: e.url,
        name: e.name,
        connect_to_app: e.connect_to_app
      }, s = ["personalAccessToken"], l = ["multipart/form-data"], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/attachments", "POST", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Upload an attachment
     * Upload an attachment.  This method uploads an attachment on an object and returns the compact record for the created attachment object. This is possible by either:  - Providing the URL of the external resource being attached, or - Downloading the file content first and then uploading it as any other attachment. Note that it is not possible to attach files from third party services such as Dropbox, Box, Vimeo &amp; Google Drive via the API  The 100MB size limit on attachments in Asana is enforced on this endpoint.  This endpoint expects a multipart/form-data encoded request containing the full contents of the file to be uploaded.  Requests made should follow the HTTP/1.1 specification that line terminators are of the form &#x60;CRLF&#x60; or &#x60;\\r\\n&#x60; outlined [here](http://www.w3.org/Protocols/HTTP/1.1/draft-ietf-http-v11-spec-01#Basic-Rules) in order for the server to reliably and properly handle the request.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.resource_subtype 
     * @param {Blob} opts.file 
     * @param {String} opts.parent 
     * @param {String} opts.url 
     * @param {String} opts.name 
     * @param {Boolean} opts.connect_to_app 
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AttachmentResponseData}
     */
  }, {
    key: "createAttachmentForObject",
    value: function(e) {
      return this.createAttachmentForObjectWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Delete an attachment
     * Deletes a specific, existing attachment.  Returns an empty data record.
     * @param {String} attachment_gid Globally unique identifier for the attachment.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deleteAttachmentWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'attachment_gid' when calling deleteAttachment");
      var n = {
        attachment_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/attachments/{attachment_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete an attachment
     * Deletes a specific, existing attachment.  Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} attachment_gid Globally unique identifier for the attachment.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteAttachment",
    value: function(e) {
      return this.deleteAttachmentWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get an attachment
     * Get the full record for a single attachment.
     * @param {String} attachment_gid Globally unique identifier for the attachment.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getAttachmentWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'attachment_gid' when calling getAttachment");
      var i = {
        attachment_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/attachments/{attachment_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get an attachment
     * Get the full record for a single attachment.
     * @param {<&vendorExtensions.x-jsdoc-type>} attachment_gid Globally unique identifier for the attachment.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AttachmentResponseData}
     */
  }, {
    key: "getAttachment",
    value: function(e, A) {
      return this.getAttachmentWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get attachments from an object
     * Returns the compact records for all attachments on the object.  There are three possible &#x60;parent&#x60; values for this request: &#x60;project&#x60;, &#x60;project_brief&#x60;, and &#x60;task&#x60;. For a project, an attachment refers to a file uploaded to the \&quot;Key resources\&quot; section in the project Overview. For a project brief, an attachment refers to inline files in the project brief itself. For a task, an attachment refers to a file directly associated to that task.  Note that within the Asana app, inline images in the task description do not appear in the index of image thumbnails nor as stories in the task. However, requests made to &#x60;GET /attachments&#x60; for a task will return all of the images in the task, including inline images.
     * @param {String} parent Globally unique identifier for object to fetch statuses from. Must be a GID for a &#x60;project&#x60;, &#x60;project_brief&#x60;, or &#x60;task&#x60;.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getAttachmentsForObjectWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'parent' when calling getAttachmentsForObject");
      var i = {}, a = {};
      A = A || {}, a = A, a.parent = e;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? $p.fromApiClient(this.apiClient.callApi("/attachments", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/attachments",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/attachments", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get attachments from an object
     * Returns the compact records for all attachments on the object.  There are three possible &#x60;parent&#x60; values for this request: &#x60;project&#x60;, &#x60;project_brief&#x60;, and &#x60;task&#x60;. For a project, an attachment refers to a file uploaded to the \&quot;Key resources\&quot; section in the project Overview. For a project brief, an attachment refers to inline files in the project brief itself. For a task, an attachment refers to a file directly associated to that task.  Note that within the Asana app, inline images in the task description do not appear in the index of image thumbnails nor as stories in the task. However, requests made to &#x60;GET /attachments&#x60; for a task will return all of the images in the task, including inline images.
     * @param {<&vendorExtensions.x-jsdoc-type>} parent Globally unique identifier for object to fetch statuses from. Must be a GID for a &#x60;project&#x60;, &#x60;project_brief&#x60;, or &#x60;task&#x60;.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AttachmentResponseArray}
     */
  }, {
    key: "getAttachmentsForObject",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getAttachmentsForObjectWithHttpInfo(e, A) : this.getAttachmentsForObjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var Ui = {};
Object.defineProperty(Ui, "__esModule", {
  value: !0
});
Ui.AuditLogAPIApi = void 0;
var Xp = le;
function Pr(r) {
  "@babel/helpers - typeof";
  return Pr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Pr(r);
}
function Zp(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Kp(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, ey(A.key), A);
  }
}
function zp(r, t, e) {
  return t && Kp(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function ey(r) {
  var t = Ay(r, "string");
  return Pr(t) == "symbol" ? t : t + "";
}
function Ay(r, t) {
  if (Pr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Pr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var ty = de;
Ui.AuditLogAPIApi = /* @__PURE__ */ function() {
  function r(t) {
    Zp(this, r), this.apiClient = t || Xp.ApiClient.instance;
  }
  return zp(r, [{
    key: "getAuditLogEventsWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling getAuditLogEvents");
      var i = {
        workspace_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? ty.fromApiClient(this.apiClient.callApi("/workspaces/{workspace_gid}/audit_log_events", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/workspaces/{workspace_gid}/audit_log_events",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/workspaces/{workspace_gid}/audit_log_events", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get audit log events
     * Retrieve the audit log events that have been captured in your domain.  This endpoint will return a list of [AuditLogEvent](/reference/audit-log-api) objects, sorted by creation time in ascending order. Note that the Audit Log API captures events from October 8th, 2021 and later. Queries for events before this date will not return results.  There are a number of query parameters (below) that can be used to filter the set of [AuditLogEvent](/reference/audit-log-api) objects that are returned in the response. Any combination of query parameters is valid. When no filters are provided, all of the events that have been captured in your domain will match.  The list of events will always be [paginated](/docs/pagination). The default limit is 1000 events. The next set of events can be retrieved using the &#x60;offset&#x60; from the previous response. If there are no events that match the provided filters in your domain, the endpoint will return &#x60;null&#x60; for the &#x60;next_page&#x60; field. Querying again with the same filters may return new events if they were captured after the last request. Once a response includes a &#x60;next_page&#x60; with an &#x60;offset&#x60;, subsequent requests can be made with the latest &#x60;offset&#x60; to poll for new events that match the provided filters.  *Note: If the filters you provided match events in your domain and &#x60;next_page&#x60; is present in the response, we will continue to send &#x60;next_page&#x60; on subsequent requests even when there are no more events that match the filters. This was put in place so that you can implement an audit log stream that will return future events that match these filters. If you are not interested in future events that match the filters you have defined, you can rely on checking empty &#x60;data&#x60; response for the end of current events that match your filters.*  When no &#x60;offset&#x60; is provided, the response will begin with the oldest events that match the provided filters. It is important to note that [AuditLogEvent](/reference/audit-log-api) objects will be permanently deleted from our systems after 90 days. If you wish to keep a permanent record of these events, we recommend using a SIEM tool to ingest and store these logs.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Date} opts.start_at Filter to events created after this time (inclusive).
     * @param {Date} opts.end_at Filter to events created before this time (exclusive).
     * @param {String} opts.event_type Filter to events of this type. Refer to the [supported audit log events](/docs/audit-log-events#supported-audit-log-events) for a full list of values.
     * @param {module:model/String} opts.actor_type Filter to events with an actor of this type. This only needs to be included if querying for actor types without an ID. If &#x60;actor_gid&#x60; is included, this should be excluded.
     * @param {String} opts.actor_gid Filter to events triggered by the actor with this ID.
     * @param {String} opts.resource_gid Filter to events with this resource ID.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AuditLogEventArray}
     */
  }, {
    key: "getAuditLogEvents",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getAuditLogEventsWithHttpInfo(e, A) : this.getAuditLogEventsWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var Pi = {};
Object.defineProperty(Pi, "__esModule", {
  value: !0
});
Pi.BatchAPIApi = void 0;
var ry = le;
function Mr(r) {
  "@babel/helpers - typeof";
  return Mr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Mr(r);
}
function ny(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function iy(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, oy(A.key), A);
  }
}
function ay(r, t, e) {
  return t && iy(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function oy(r) {
  var t = sy(r, "string");
  return Mr(t) == "symbol" ? t : t + "";
}
function sy(r, t) {
  if (Mr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Mr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var cy = de;
Pi.BatchAPIApi = /* @__PURE__ */ function() {
  function r(t) {
    ny(this, r), this.apiClient = t || ry.ApiClient.instance;
  }
  return ay(r, [{
    key: "createBatchRequestWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createBatchRequest");
      var i = {}, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? cy.fromApiClient(this.apiClient.callApi("/batch", "POST", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/batch",
        httpMethod: "POST",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/batch", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Submit parallel requests
     * Make multiple requests in parallel to Asana&#x27;s API.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The requests to batch together via the Batch API.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/BatchResponseArray}
     */
  }, {
    key: "createBatchRequest",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.createBatchRequestWithHttpInfo(e, A) : this.createBatchRequestWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var Mi = {};
Object.defineProperty(Mi, "__esModule", {
  value: !0
});
Mi.CustomFieldSettingsApi = void 0;
var ly = le;
function Lr(r) {
  "@babel/helpers - typeof";
  return Lr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Lr(r);
}
function uy(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function hy(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Ey(A.key), A);
  }
}
function gy(r, t, e) {
  return t && hy(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Ey(r) {
  var t = Cy(r, "string");
  return Lr(t) == "symbol" ? t : t + "";
}
function Cy(r, t) {
  if (Lr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Lr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var uu = de;
Mi.CustomFieldSettingsApi = /* @__PURE__ */ function() {
  function r(t) {
    uy(this, r), this.apiClient = t || ly.ApiClient.instance;
  }
  return gy(r, [{
    key: "getCustomFieldSettingsForPortfolioWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'portfolio_gid' when calling getCustomFieldSettingsForPortfolio");
      var i = {
        portfolio_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? uu.fromApiClient(this.apiClient.callApi("/portfolios/{portfolio_gid}/custom_field_settings", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/portfolios/{portfolio_gid}/custom_field_settings",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/portfolios/{portfolio_gid}/custom_field_settings", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a portfolio&#x27;s custom fields
     * Returns a list of all of the custom fields settings on a portfolio, in compact form.
     * @param {<&vendorExtensions.x-jsdoc-type>} portfolio_gid Globally unique identifier for the portfolio.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CustomFieldSettingResponseArray}
     */
  }, {
    key: "getCustomFieldSettingsForPortfolio",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getCustomFieldSettingsForPortfolioWithHttpInfo(e, A) : this.getCustomFieldSettingsForPortfolioWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get a project&#x27;s custom fields
     * Returns a list of all of the custom fields settings on a project, in compact form. Note that, as in all queries to collections which return compact representation, &#x60;opt_fields&#x60; can be used to include more data than is returned in the compact representation. See the [documentation for input/output options](https://developers.asana.com/docs/inputoutput-options) for more information.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getCustomFieldSettingsForProjectWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'project_gid' when calling getCustomFieldSettingsForProject");
      var i = {
        project_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? uu.fromApiClient(this.apiClient.callApi("/projects/{project_gid}/custom_field_settings", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/projects/{project_gid}/custom_field_settings",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/projects/{project_gid}/custom_field_settings", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a project&#x27;s custom fields
     * Returns a list of all of the custom fields settings on a project, in compact form. Note that, as in all queries to collections which return compact representation, &#x60;opt_fields&#x60; can be used to include more data than is returned in the compact representation. See the [documentation for input/output options](https://developers.asana.com/docs/inputoutput-options) for more information.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CustomFieldSettingResponseArray}
     */
  }, {
    key: "getCustomFieldSettingsForProject",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getCustomFieldSettingsForProjectWithHttpInfo(e, A) : this.getCustomFieldSettingsForProjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var Li = {};
Object.defineProperty(Li, "__esModule", {
  value: !0
});
Li.CustomFieldsApi = void 0;
var fy = le;
function Hr(r) {
  "@babel/helpers - typeof";
  return Hr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Hr(r);
}
function Qy(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function By(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, dy(A.key), A);
  }
}
function Iy(r, t, e) {
  return t && By(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function dy(r) {
  var t = py(r, "string");
  return Hr(t) == "symbol" ? t : t + "";
}
function py(r, t) {
  if (Hr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Hr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var yy = de;
Li.CustomFieldsApi = /* @__PURE__ */ function() {
  function r(t) {
    Qy(this, r), this.apiClient = t || fy.ApiClient.instance;
  }
  return Iy(r, [{
    key: "createCustomFieldWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createCustomField");
      var i = {}, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/custom_fields", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Create a custom field
     * Creates a new custom field in a workspace. Every custom field is required to be created in a specific workspace, and this workspace cannot be changed once set.  A custom fields name must be unique within a workspace and not conflict with names of existing task properties such as &#x60;Due Date&#x60; or &#x60;Assignee&#x60;. A custom fields type must be one of &#x60;text&#x60;, &#x60;enum&#x60;, &#x60;multi_enum&#x60;, &#x60;number&#x60;, &#x60;date&#x60;, or &#x60;people&#x60;.  Returns the full record of the newly created custom field.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The custom field object to create.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CustomFieldResponseData}
     */
  }, {
    key: "createCustomField",
    value: function(e, A) {
      return this.createCustomFieldWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Create an enum option
     * Creates an enum option and adds it to this custom fields list of enum options. A custom field can have at most 500 enum options (including disabled options). By default new enum options are inserted at the end of a custom fields list. Locked custom fields can only have enum options added by the user who locked the field. Returns the full record of the newly created enum option.
     * @param {String} custom_field_gid Globally unique identifier for the custom field.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The enum option object to create.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "createEnumOptionForCustomFieldWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = A.body;
      if (e == null)
        throw new Error("Missing the required parameter 'custom_field_gid' when calling createEnumOptionForCustomField");
      var i = {
        custom_field_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/custom_fields/{custom_field_gid}/enum_options", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Create an enum option
     * Creates an enum option and adds it to this custom fields list of enum options. A custom field can have at most 500 enum options (including disabled options). By default new enum options are inserted at the end of a custom fields list. Locked custom fields can only have enum options added by the user who locked the field. Returns the full record of the newly created enum option.
     * @param {<&vendorExtensions.x-jsdoc-type>} custom_field_gid Globally unique identifier for the custom field.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The enum option object to create.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EnumOptionData}
     */
  }, {
    key: "createEnumOptionForCustomField",
    value: function(e, A) {
      return this.createEnumOptionForCustomFieldWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Delete a custom field
     * A specific, existing custom field can be deleted by making a DELETE request on the URL for that custom field. Locked custom fields can only be deleted by the user who locked the field. Returns an empty data record.
     * @param {String} custom_field_gid Globally unique identifier for the custom field.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deleteCustomFieldWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'custom_field_gid' when calling deleteCustomField");
      var n = {
        custom_field_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/custom_fields/{custom_field_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a custom field
     * A specific, existing custom field can be deleted by making a DELETE request on the URL for that custom field. Locked custom fields can only be deleted by the user who locked the field. Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} custom_field_gid Globally unique identifier for the custom field.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteCustomField",
    value: function(e) {
      return this.deleteCustomFieldWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get a custom field
     * Get the complete definition of a custom fields metadata.  Since custom fields can be defined for one of a number of types, and these types have different data and behaviors, there are fields that are relevant to a particular type. For instance, as noted above, enum_options is only relevant for the enum type and defines the set of choices that the enum could represent. The examples below show some of these type-specific custom field definitions.
     * @param {String} custom_field_gid Globally unique identifier for the custom field.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getCustomFieldWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'custom_field_gid' when calling getCustomField");
      var i = {
        custom_field_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/custom_fields/{custom_field_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a custom field
     * Get the complete definition of a custom fields metadata.  Since custom fields can be defined for one of a number of types, and these types have different data and behaviors, there are fields that are relevant to a particular type. For instance, as noted above, enum_options is only relevant for the enum type and defines the set of choices that the enum could represent. The examples below show some of these type-specific custom field definitions.
     * @param {<&vendorExtensions.x-jsdoc-type>} custom_field_gid Globally unique identifier for the custom field.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CustomFieldResponseData}
     */
  }, {
    key: "getCustomField",
    value: function(e, A) {
      return this.getCustomFieldWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get a workspace&#x27;s custom fields
     * Returns a list of the compact representation of all of the custom fields in a workspace.
     * @param {String} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getCustomFieldsForWorkspaceWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling getCustomFieldsForWorkspace");
      var i = {
        workspace_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? yy.fromApiClient(this.apiClient.callApi("/workspaces/{workspace_gid}/custom_fields", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/workspaces/{workspace_gid}/custom_fields",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/workspaces/{workspace_gid}/custom_fields", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a workspace&#x27;s custom fields
     * Returns a list of the compact representation of all of the custom fields in a workspace.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CustomFieldResponseArray}
     */
  }, {
    key: "getCustomFieldsForWorkspace",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getCustomFieldsForWorkspaceWithHttpInfo(e, A) : this.getCustomFieldsForWorkspaceWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Reorder a custom field&#x27;s enum
     * Moves a particular enum option to be either before or after another specified enum option in the custom field. Locked custom fields can only be reordered by the user who locked the field.
     * @param {String} custom_field_gid Globally unique identifier for the custom field.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The enum option object to create.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "insertEnumOptionForCustomFieldWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = A.body;
      if (e == null)
        throw new Error("Missing the required parameter 'custom_field_gid' when calling insertEnumOptionForCustomField");
      var i = {
        custom_field_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/custom_fields/{custom_field_gid}/enum_options/insert", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Reorder a custom field&#x27;s enum
     * Moves a particular enum option to be either before or after another specified enum option in the custom field. Locked custom fields can only be reordered by the user who locked the field.
     * @param {<&vendorExtensions.x-jsdoc-type>} custom_field_gid Globally unique identifier for the custom field.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The enum option object to create.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EnumOptionData}
     */
  }, {
    key: "insertEnumOptionForCustomField",
    value: function(e, A) {
      return this.insertEnumOptionForCustomFieldWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Update a custom field
     * A specific, existing custom field can be updated by making a PUT request on the URL for that custom field. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the custom field. A custom fields &#x60;type&#x60; cannot be updated. An enum custom fields &#x60;enum_options&#x60; cannot be updated with this endpoint. Instead see Work With Enum Options for information on how to update &#x60;enum_options&#x60;. Locked custom fields can only be updated by the user who locked the field. Returns the complete updated custom field record.
     * @param {String} custom_field_gid Globally unique identifier for the custom field.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The custom field object with all updated properties.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateCustomFieldWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = A.body;
      if (e == null)
        throw new Error("Missing the required parameter 'custom_field_gid' when calling updateCustomField");
      var i = {
        custom_field_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/custom_fields/{custom_field_gid}", "PUT", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Update a custom field
     * A specific, existing custom field can be updated by making a PUT request on the URL for that custom field. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the custom field. A custom fields &#x60;type&#x60; cannot be updated. An enum custom fields &#x60;enum_options&#x60; cannot be updated with this endpoint. Instead see Work With Enum Options for information on how to update &#x60;enum_options&#x60;. Locked custom fields can only be updated by the user who locked the field. Returns the complete updated custom field record.
     * @param {<&vendorExtensions.x-jsdoc-type>} custom_field_gid Globally unique identifier for the custom field.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The custom field object with all updated properties.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CustomFieldResponseData}
     */
  }, {
    key: "updateCustomField",
    value: function(e, A) {
      return this.updateCustomFieldWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Update an enum option
     * Updates an existing enum option. Enum custom fields require at least one enabled enum option. Locked custom fields can only be updated by the user who locked the field. Returns the full record of the updated enum option.
     * @param {String} enum_option_gid Globally unique identifier for the enum option.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The enum option object to update
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateEnumOptionWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = A.body;
      if (e == null)
        throw new Error("Missing the required parameter 'enum_option_gid' when calling updateEnumOption");
      var i = {
        enum_option_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/enum_options/{enum_option_gid}", "PUT", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Update an enum option
     * Updates an existing enum option. Enum custom fields require at least one enabled enum option. Locked custom fields can only be updated by the user who locked the field. Returns the full record of the updated enum option.
     * @param {<&vendorExtensions.x-jsdoc-type>} enum_option_gid Globally unique identifier for the enum option.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The enum option object to update
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EnumOptionData}
     */
  }, {
    key: "updateEnumOption",
    value: function(e, A) {
      return this.updateEnumOptionWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var Hi = {};
Object.defineProperty(Hi, "__esModule", {
  value: !0
});
Hi.EventsApi = void 0;
var my = le;
function Gr(r) {
  "@babel/helpers - typeof";
  return Gr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Gr(r);
}
function wy(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function vy(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, by(A.key), A);
  }
}
function ky(r, t, e) {
  return t && vy(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function by(r) {
  var t = Ty(r, "string");
  return Gr(t) == "symbol" ? t : t + "";
}
function Ty(r, t) {
  if (Gr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Gr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var Fy = de;
Hi.EventsApi = /* @__PURE__ */ function() {
  function r(t) {
    wy(this, r), this.apiClient = t || my.ApiClient.instance;
  }
  return ky(r, [{
    key: "getEventsWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'resource' when calling getEvents");
      var i = {}, a = {};
      A = A || {}, a = A, a.resource = e;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? Fy.fromApiClient(this.apiClient.callApi("/events", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/events",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/events", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get events on a resource
     * Returns the full record for all events that have occurred since the sync token was created.  A &#x60;GET&#x60; request to the endpoint &#x60;/[path_to_resource]/events&#x60; can be made in lieu of including the resource ID in the data for the request.  Asana limits a single sync token to 100 events. If more than 100 events exist for a given resource, &#x60;has_more: true&#x60; will be returned in the response, indicating that there are more events to pull.  *Note: The resource returned will be the resource that triggered the event. This may be different from the one that the events were requested for. For example, a subscription to a project will contain events for tasks contained within the project.*
     * @param {<&vendorExtensions.x-jsdoc-type>} resource A resource ID to subscribe to. The resource can be a task, project, or goal.
     * @param {Object} opts Optional parameters
     * @param {String} opts.sync A sync token received from the last request, or none on first sync. Events will be returned from the point in time that the sync token was generated. *Note: On your first request, omit the sync token. The response will be the same as for an expired sync token, and will include a new valid sync token.If the sync token is too old (which may happen from time to time) the API will return a &#x60;412 Precondition Failed&#x60; error, and include a fresh sync token in the response.*
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EventResponseArray}
     */
  }, {
    key: "getEvents",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getEventsWithHttpInfo(e, A) : this.getEventsWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var Gi = {};
Object.defineProperty(Gi, "__esModule", {
  value: !0
});
Gi.GoalRelationshipsApi = void 0;
var Ry = le;
function Wr(r) {
  "@babel/helpers - typeof";
  return Wr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Wr(r);
}
function Dy(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ny(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Uy(A.key), A);
  }
}
function Sy(r, t, e) {
  return t && Ny(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Uy(r) {
  var t = Py(r, "string");
  return Wr(t) == "symbol" ? t : t + "";
}
function Py(r, t) {
  if (Wr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Wr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var My = de;
Gi.GoalRelationshipsApi = /* @__PURE__ */ function() {
  function r(t) {
    Dy(this, r), this.apiClient = t || Ry.ApiClient.instance;
  }
  return Sy(r, [{
    key: "addSupportingRelationshipWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling addSupportingRelationship");
      if (A == null)
        throw new Error("Missing the required parameter 'goal_gid' when calling addSupportingRelationship");
      var a = {
        goal_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/goals/{goal_gid}/addSupportingRelationship", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Add a supporting goal relationship
     * Creates a goal relationship by adding a supporting resource to a given goal.  Returns the newly created goal relationship record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The supporting resource to be added to the goal
     * @param {<&vendorExtensions.x-jsdoc-type>} goal_gid Globally unique identifier for the goal.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GoalRelationshipResponseData}
     */
  }, {
    key: "addSupportingRelationship",
    value: function(e, A, n) {
      return this.addSupportingRelationshipWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Get a goal relationship
     * Returns the complete updated goal relationship record for a single goal relationship.
     * @param {String} goal_relationship_gid Globally unique identifier for the goal relationship.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getGoalRelationshipWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'goal_relationship_gid' when calling getGoalRelationship");
      var i = {
        goal_relationship_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/goal_relationships/{goal_relationship_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a goal relationship
     * Returns the complete updated goal relationship record for a single goal relationship.
     * @param {<&vendorExtensions.x-jsdoc-type>} goal_relationship_gid Globally unique identifier for the goal relationship.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GoalRelationshipResponseData}
     */
  }, {
    key: "getGoalRelationship",
    value: function(e, A) {
      return this.getGoalRelationshipWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get goal relationships
     * Returns compact goal relationship records.
     * @param {String} supported_goal Globally unique identifier for the supported goal in the goal relationship.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.resource_subtype If provided, filter to goal relationships with a given resource_subtype.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getGoalRelationshipsWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'supported_goal' when calling getGoalRelationships");
      var i = {}, a = {};
      A = A || {}, a = A, a.supported_goal = e;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? My.fromApiClient(this.apiClient.callApi("/goal_relationships", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/goal_relationships",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/goal_relationships", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get goal relationships
     * Returns compact goal relationship records.
     * @param {<&vendorExtensions.x-jsdoc-type>} supported_goal Globally unique identifier for the supported goal in the goal relationship.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.resource_subtype If provided, filter to goal relationships with a given resource_subtype.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GoalRelationshipResponseArray}
     */
  }, {
    key: "getGoalRelationships",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getGoalRelationshipsWithHttpInfo(e, A) : this.getGoalRelationshipsWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Removes a supporting goal relationship
     * Removes a goal relationship for a given parent goal.
     * @param {module:model/Object} body The supporting resource to be removed from the goal
     * @param {String} goal_gid Globally unique identifier for the goal.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "removeSupportingRelationshipWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling removeSupportingRelationship");
      if (A == null)
        throw new Error("Missing the required parameter 'goal_gid' when calling removeSupportingRelationship");
      var i = {
        goal_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/goals/{goal_gid}/removeSupportingRelationship", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Removes a supporting goal relationship
     * Removes a goal relationship for a given parent goal.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The supporting resource to be removed from the goal
     * @param {<&vendorExtensions.x-jsdoc-type>} goal_gid Globally unique identifier for the goal.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "removeSupportingRelationship",
    value: function(e, A) {
      return this.removeSupportingRelationshipWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Update a goal relationship
     * An existing goal relationship can be updated by making a PUT request on the URL for that goal relationship. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated goal relationship record.
     * @param {module:model/Object} body The updated fields for the goal relationship.
     * @param {String} goal_relationship_gid Globally unique identifier for the goal relationship.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateGoalRelationshipWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling updateGoalRelationship");
      if (A == null)
        throw new Error("Missing the required parameter 'goal_relationship_gid' when calling updateGoalRelationship");
      var a = {
        goal_relationship_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/goal_relationships/{goal_relationship_gid}", "PUT", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Update a goal relationship
     * An existing goal relationship can be updated by making a PUT request on the URL for that goal relationship. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated goal relationship record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The updated fields for the goal relationship.
     * @param {<&vendorExtensions.x-jsdoc-type>} goal_relationship_gid Globally unique identifier for the goal relationship.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GoalRelationshipResponseData}
     */
  }, {
    key: "updateGoalRelationship",
    value: function(e, A, n) {
      return this.updateGoalRelationshipWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
  }]);
}();
var Wi = {};
Object.defineProperty(Wi, "__esModule", {
  value: !0
});
Wi.GoalsApi = void 0;
var Ly = le;
function Yr(r) {
  "@babel/helpers - typeof";
  return Yr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Yr(r);
}
function Hy(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Gy(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Yy(A.key), A);
  }
}
function Wy(r, t, e) {
  return t && Gy(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Yy(r) {
  var t = Jy(r, "string");
  return Yr(t) == "symbol" ? t : t + "";
}
function Jy(r, t) {
  if (Yr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Yr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var hu = de;
Wi.GoalsApi = /* @__PURE__ */ function() {
  function r(t) {
    Hy(this, r), this.apiClient = t || Ly.ApiClient.instance;
  }
  return Wy(r, [{
    key: "addFollowersWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling addFollowers");
      if (A == null)
        throw new Error("Missing the required parameter 'goal_gid' when calling addFollowers");
      var a = {
        goal_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/goals/{goal_gid}/addFollowers", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Add a collaborator to a goal
     * Adds followers to a goal. Returns the goal the followers were added to. Each goal can be associated with zero or more followers in the system. Requests to add/remove followers, if successful, will return the complete updated goal record, described above.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The followers to be added as collaborators
     * @param {<&vendorExtensions.x-jsdoc-type>} goal_gid Globally unique identifier for the goal.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GoalResponseData}
     */
  }, {
    key: "addFollowers",
    value: function(e, A, n) {
      return this.addFollowersWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Create a goal
     * Creates a new goal in a workspace or team.  Returns the full record of the newly created goal.
     * @param {module:model/Object} body The goal to create.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "createGoalWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createGoal");
      var i = {}, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/goals", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Create a goal
     * Creates a new goal in a workspace or team.  Returns the full record of the newly created goal.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The goal to create.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GoalResponseData}
     */
  }, {
    key: "createGoal",
    value: function(e, A) {
      return this.createGoalWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Create a goal metric
     * Creates and adds a goal metric to a specified goal. Note that this replaces an existing goal metric if one already exists.
     * @param {module:model/Object} body The goal metric to create.
     * @param {String} goal_gid Globally unique identifier for the goal.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "createGoalMetricWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createGoalMetric");
      if (A == null)
        throw new Error("Missing the required parameter 'goal_gid' when calling createGoalMetric");
      var a = {
        goal_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/goals/{goal_gid}/setMetric", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Create a goal metric
     * Creates and adds a goal metric to a specified goal. Note that this replaces an existing goal metric if one already exists.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The goal metric to create.
     * @param {<&vendorExtensions.x-jsdoc-type>} goal_gid Globally unique identifier for the goal.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GoalResponseData}
     */
  }, {
    key: "createGoalMetric",
    value: function(e, A, n) {
      return this.createGoalMetricWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Delete a goal
     * A specific, existing goal can be deleted by making a DELETE request on the URL for that goal.  Returns an empty data record.
     * @param {String} goal_gid Globally unique identifier for the goal.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deleteGoalWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'goal_gid' when calling deleteGoal");
      var n = {
        goal_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/goals/{goal_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a goal
     * A specific, existing goal can be deleted by making a DELETE request on the URL for that goal.  Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} goal_gid Globally unique identifier for the goal.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteGoal",
    value: function(e) {
      return this.deleteGoalWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get a goal
     * Returns the complete goal record for a single goal.
     * @param {String} goal_gid Globally unique identifier for the goal.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getGoalWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'goal_gid' when calling getGoal");
      var i = {
        goal_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/goals/{goal_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a goal
     * Returns the complete goal record for a single goal.
     * @param {<&vendorExtensions.x-jsdoc-type>} goal_gid Globally unique identifier for the goal.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GoalResponseData}
     */
  }, {
    key: "getGoal",
    value: function(e, A) {
      return this.getGoalWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get goals
     * Returns compact goal records.
     * @param {Object} opts Optional parameters
     * @param {String} opts.portfolio Globally unique identifier for supporting portfolio.
     * @param {String} opts.project Globally unique identifier for supporting project.
     * @param {String} opts.task Globally unique identifier for supporting task.
     * @param {Boolean} opts.is_workspace_level Filter to goals with is_workspace_level set to query value. Must be used with the workspace parameter.
     * @param {String} opts.team Globally unique identifier for the team.
     * @param {String} opts.workspace Globally unique identifier for the workspace.
     * @param {Array.<String>} opts.time_periods Globally unique identifiers for the time periods.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getGoalsWithHttpInfo",
    value: function(e) {
      e = e || {};
      var A = null, n = {}, i = {};
      e = e || {}, i = e;
      var a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.RETURN_COLLECTION ? hu.fromApiClient(this.apiClient.callApi("/goals", "GET", n, i, a, o, A, s, l, c, u), this.apiClient, {
        path: "/goals",
        httpMethod: "GET",
        pathParams: n,
        queryParams: i,
        headerParams: a,
        formParams: o,
        bodyParam: A,
        authNames: s,
        contentTypes: l,
        accepts: c,
        returnType: u
      }) : this.apiClient.callApi("/goals", "GET", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Get goals
     * Returns compact goal records.
     * @param {Object} opts Optional parameters
     * @param {String} opts.portfolio Globally unique identifier for supporting portfolio.
     * @param {String} opts.project Globally unique identifier for supporting project.
     * @param {String} opts.task Globally unique identifier for supporting task.
     * @param {Boolean} opts.is_workspace_level Filter to goals with is_workspace_level set to query value. Must be used with the workspace parameter.
     * @param {String} opts.team Globally unique identifier for the team.
     * @param {String} opts.workspace Globally unique identifier for the workspace.
     * @param {Array.<String>} opts.time_periods Globally unique identifiers for the time periods.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GoalResponseArray}
     */
  }, {
    key: "getGoals",
    value: function(e) {
      return this.apiClient.RETURN_COLLECTION ? this.getGoalsWithHttpInfo(e) : this.getGoalsWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get parent goals from a goal
     * Returns a compact representation of all of the parent goals of a goal.
     * @param {String} goal_gid Globally unique identifier for the goal.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getParentGoalsForGoalWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'goal_gid' when calling getParentGoalsForGoal");
      var i = {
        goal_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? hu.fromApiClient(this.apiClient.callApi("/goals/{goal_gid}/parentGoals", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/goals/{goal_gid}/parentGoals",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/goals/{goal_gid}/parentGoals", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get parent goals from a goal
     * Returns a compact representation of all of the parent goals of a goal.
     * @param {<&vendorExtensions.x-jsdoc-type>} goal_gid Globally unique identifier for the goal.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GoalResponseArray}
     */
  }, {
    key: "getParentGoalsForGoal",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getParentGoalsForGoalWithHttpInfo(e, A) : this.getParentGoalsForGoalWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Remove a collaborator from a goal
     * Removes followers from a goal. Returns the goal the followers were removed from. Each goal can be associated with zero or more followers in the system. Requests to add/remove followers, if successful, will return the complete updated goal record, described above.
     * @param {module:model/Object} body The followers to be removed as collaborators
     * @param {String} goal_gid Globally unique identifier for the goal.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "removeFollowersWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling removeFollowers");
      if (A == null)
        throw new Error("Missing the required parameter 'goal_gid' when calling removeFollowers");
      var a = {
        goal_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/goals/{goal_gid}/removeFollowers", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Remove a collaborator from a goal
     * Removes followers from a goal. Returns the goal the followers were removed from. Each goal can be associated with zero or more followers in the system. Requests to add/remove followers, if successful, will return the complete updated goal record, described above.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The followers to be removed as collaborators
     * @param {<&vendorExtensions.x-jsdoc-type>} goal_gid Globally unique identifier for the goal.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GoalResponseData}
     */
  }, {
    key: "removeFollowers",
    value: function(e, A, n) {
      return this.removeFollowersWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Update a goal
     * An existing goal can be updated by making a PUT request on the URL for that goal. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated goal record.
     * @param {module:model/Object} body The updated fields for the goal.
     * @param {String} goal_gid Globally unique identifier for the goal.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateGoalWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling updateGoal");
      if (A == null)
        throw new Error("Missing the required parameter 'goal_gid' when calling updateGoal");
      var a = {
        goal_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/goals/{goal_gid}", "PUT", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Update a goal
     * An existing goal can be updated by making a PUT request on the URL for that goal. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated goal record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The updated fields for the goal.
     * @param {<&vendorExtensions.x-jsdoc-type>} goal_gid Globally unique identifier for the goal.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GoalResponseData}
     */
  }, {
    key: "updateGoal",
    value: function(e, A, n) {
      return this.updateGoalWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Update a goal metric
     * Updates a goal&#x27;s existing metric&#x27;s &#x60;current_number_value&#x60; if one exists, otherwise responds with a 400 status code.  Returns the complete updated goal metric record.
     * @param {module:model/Object} body The updated fields for the goal metric.
     * @param {String} goal_gid Globally unique identifier for the goal.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateGoalMetricWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling updateGoalMetric");
      if (A == null)
        throw new Error("Missing the required parameter 'goal_gid' when calling updateGoalMetric");
      var a = {
        goal_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/goals/{goal_gid}/setMetricCurrentValue", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Update a goal metric
     * Updates a goal&#x27;s existing metric&#x27;s &#x60;current_number_value&#x60; if one exists, otherwise responds with a 400 status code.  Returns the complete updated goal metric record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The updated fields for the goal metric.
     * @param {<&vendorExtensions.x-jsdoc-type>} goal_gid Globally unique identifier for the goal.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/GoalResponseData}
     */
  }, {
    key: "updateGoalMetric",
    value: function(e, A, n) {
      return this.updateGoalMetricWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
  }]);
}();
var Yi = {};
Object.defineProperty(Yi, "__esModule", {
  value: !0
});
Yi.JobsApi = void 0;
var _y = le;
function Jr(r) {
  "@babel/helpers - typeof";
  return Jr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Jr(r);
}
function xy(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Oy(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, jy(A.key), A);
  }
}
function qy(r, t, e) {
  return t && Oy(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function jy(r) {
  var t = Vy(r, "string");
  return Jr(t) == "symbol" ? t : t + "";
}
function Vy(r, t) {
  if (Jr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Jr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
Yi.JobsApi = /* @__PURE__ */ function() {
  function r(t) {
    xy(this, r), this.apiClient = t || _y.ApiClient.instance;
  }
  return qy(r, [{
    key: "getJobWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'job_gid' when calling getJob");
      var i = {
        job_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/jobs/{job_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a job by id
     * Returns the full record for a job.
     * @param {<&vendorExtensions.x-jsdoc-type>} job_gid Globally unique identifier for the job.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/JobResponseData}
     */
  }, {
    key: "getJob",
    value: function(e, A) {
      return this.getJobWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var Ji = {};
Object.defineProperty(Ji, "__esModule", {
  value: !0
});
Ji.MembershipsApi = void 0;
var $y = le;
function _r(r) {
  "@babel/helpers - typeof";
  return _r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, _r(r);
}
function Xy(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Zy(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, zy(A.key), A);
  }
}
function Ky(r, t, e) {
  return t && Zy(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function zy(r) {
  var t = em(r, "string");
  return _r(t) == "symbol" ? t : t + "";
}
function em(r, t) {
  if (_r(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (_r(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var Am = de;
Ji.MembershipsApi = /* @__PURE__ */ function() {
  function r(t) {
    Xy(this, r), this.apiClient = t || $y.ApiClient.instance;
  }
  return Ky(r, [{
    key: "createMembershipWithHttpInfo",
    value: function(e) {
      e = e || {};
      var A = e.body, n = {}, i = {};
      e = e || {}, i = e;
      var a = {}, o = {}, s = ["personalAccessToken"], l = ["application/json; charset=UTF-8"], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/memberships", "POST", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Create a membership
     * Creates a new membership in a &#x60;goal&#x60; or &#x60;project&#x60;. &#x60;Teams&#x60; or &#x60;users&#x60; can be a member of &#x60;goals&#x60; or &#x60;projects&#x60;.  Returns the full record of the newly created membership.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The updated fields for the membership.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MembershipResponseData}
     */
  }, {
    key: "createMembership",
    value: function(e) {
      return this.createMembershipWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Delete a membership
     * A specific, existing membership for a &#x60;goal&#x60; or &#x60;project&#x60; can be deleted by making a &#x60;DELETE&#x60; request on the URL for that membership.  Returns an empty data record.
     * @param {String} membership_gid Globally unique identifier for the membership.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deleteMembershipWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'membership_gid' when calling deleteMembership");
      var n = {
        membership_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/memberships/{membership_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a membership
     * A specific, existing membership for a &#x60;goal&#x60; or &#x60;project&#x60; can be deleted by making a &#x60;DELETE&#x60; request on the URL for that membership.  Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} membership_gid Globally unique identifier for the membership.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteMembership",
    value: function(e) {
      return this.deleteMembershipWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get a membership
     * Returns compact &#x60;project_membership&#x60; record for a single membership. &#x60;GET&#x60; only supports project memberships currently
     * @param {String} membership_gid Globally unique identifier for the membership.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getMembershipWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'membership_gid' when calling getMembership");
      var i = {
        membership_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/memberships/{membership_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a membership
     * Returns compact &#x60;project_membership&#x60; record for a single membership. &#x60;GET&#x60; only supports project memberships currently
     * @param {<&vendorExtensions.x-jsdoc-type>} membership_gid Globally unique identifier for the membership.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectMembershipCompactResponseData}
     */
  }, {
    key: "getMembership",
    value: function(e, A) {
      return this.getMembershipWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get multiple memberships
     * Returns compact &#x60;goal_membership&#x60; or &#x60;project_membership&#x60; records. The possible types for &#x60;parent&#x60; in this request are &#x60;goal&#x60; or &#x60;project&#x60;. An additional member (user GID or team GID) can be passed in to filter to a specific membership.
     * @param {Object} opts Optional parameters
     * @param {String} opts.parent Globally unique identifier for &#x60;goal&#x60; or &#x60;project&#x60;.
     * @param {String} opts.member Globally unique identifier for &#x60;team&#x60; or &#x60;user&#x60;.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getMembershipsWithHttpInfo",
    value: function(e) {
      e = e || {};
      var A = null, n = {}, i = {};
      e = e || {}, i = e;
      var a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.RETURN_COLLECTION ? Am.fromApiClient(this.apiClient.callApi("/memberships", "GET", n, i, a, o, A, s, l, c, u), this.apiClient, {
        path: "/memberships",
        httpMethod: "GET",
        pathParams: n,
        queryParams: i,
        headerParams: a,
        formParams: o,
        bodyParam: A,
        authNames: s,
        contentTypes: l,
        accepts: c,
        returnType: u
      }) : this.apiClient.callApi("/memberships", "GET", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Get multiple memberships
     * Returns compact &#x60;goal_membership&#x60; or &#x60;project_membership&#x60; records. The possible types for &#x60;parent&#x60; in this request are &#x60;goal&#x60; or &#x60;project&#x60;. An additional member (user GID or team GID) can be passed in to filter to a specific membership.
     * @param {Object} opts Optional parameters
     * @param {String} opts.parent Globally unique identifier for &#x60;goal&#x60; or &#x60;project&#x60;.
     * @param {String} opts.member Globally unique identifier for &#x60;team&#x60; or &#x60;user&#x60;.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MembershipResponseArray}
     */
  }, {
    key: "getMemberships",
    value: function(e) {
      return this.apiClient.RETURN_COLLECTION ? this.getMembershipsWithHttpInfo(e) : this.getMembershipsWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Update a membership
     * An existing membership can be updated by making a &#x60;PUT&#x60; request on the URL for that goal. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged. Memberships on &#x60;goals&#x60; and &#x60;projects&#x60; can be updated.  Returns the full record of the updated membership.
     * @param {module:model/Object} body The membership to update.
     * @param {String} membership_gid Globally unique identifier for the membership.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateMembershipWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling updateMembership");
      if (A == null)
        throw new Error("Missing the required parameter 'membership_gid' when calling updateMembership");
      var i = {
        membership_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/memberships/{membership_gid}", "PUT", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Update a membership
     * An existing membership can be updated by making a &#x60;PUT&#x60; request on the URL for that goal. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged. Memberships on &#x60;goals&#x60; and &#x60;projects&#x60; can be updated.  Returns the full record of the updated membership.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The membership to update.
     * @param {<&vendorExtensions.x-jsdoc-type>} membership_gid Globally unique identifier for the membership.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/MembershipResponseData}
     */
  }, {
    key: "updateMembership",
    value: function(e, A) {
      return this.updateMembershipWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var _i = {};
Object.defineProperty(_i, "__esModule", {
  value: !0
});
_i.OrganizationExportsApi = void 0;
var tm = le;
function xr(r) {
  "@babel/helpers - typeof";
  return xr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, xr(r);
}
function rm(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function nm(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, am(A.key), A);
  }
}
function im(r, t, e) {
  return t && nm(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function am(r) {
  var t = om(r, "string");
  return xr(t) == "symbol" ? t : t + "";
}
function om(r, t) {
  if (xr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (xr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
_i.OrganizationExportsApi = /* @__PURE__ */ function() {
  function r(t) {
    rm(this, r), this.apiClient = t || tm.ApiClient.instance;
  }
  return im(r, [{
    key: "createOrganizationExportWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createOrganizationExport");
      var i = {}, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/organization_exports", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Create an organization export request
     * This method creates a request to export an Organization. Asana will complete the export at some point after you create the request.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The organization to export.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/OrganizationExportResponseData}
     */
  }, {
    key: "createOrganizationExport",
    value: function(e, A) {
      return this.createOrganizationExportWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get details on an org export request
     * Returns details of a previously-requested Organization export.
     * @param {String} organization_export_gid Globally unique identifier for the organization export.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getOrganizationExportWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'organization_export_gid' when calling getOrganizationExport");
      var i = {
        organization_export_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/organization_exports/{organization_export_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get details on an org export request
     * Returns details of a previously-requested Organization export.
     * @param {<&vendorExtensions.x-jsdoc-type>} organization_export_gid Globally unique identifier for the organization export.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/OrganizationExportResponseData}
     */
  }, {
    key: "getOrganizationExport",
    value: function(e, A) {
      return this.getOrganizationExportWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var xi = {};
Object.defineProperty(xi, "__esModule", {
  value: !0
});
xi.PortfolioMembershipsApi = void 0;
var sm = le;
function Or(r) {
  "@babel/helpers - typeof";
  return Or = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Or(r);
}
function cm(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function lm(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, hm(A.key), A);
  }
}
function um(r, t, e) {
  return t && lm(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function hm(r) {
  var t = gm(r, "string");
  return Or(t) == "symbol" ? t : t + "";
}
function gm(r, t) {
  if (Or(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Or(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var gu = de;
xi.PortfolioMembershipsApi = /* @__PURE__ */ function() {
  function r(t) {
    cm(this, r), this.apiClient = t || sm.ApiClient.instance;
  }
  return um(r, [{
    key: "getPortfolioMembershipWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'portfolio_membership_gid' when calling getPortfolioMembership");
      var i = {
        portfolio_membership_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/portfolio_memberships/{portfolio_membership_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a portfolio membership
     * Returns the complete portfolio record for a single portfolio membership.
     * @param {<&vendorExtensions.x-jsdoc-type>} portfolio_membership_gid 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PortfolioMembershipResponseData}
     */
  }, {
    key: "getPortfolioMembership",
    value: function(e, A) {
      return this.getPortfolioMembershipWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get multiple portfolio memberships
     * Returns a list of portfolio memberships in compact representation. You must specify &#x60;portfolio&#x60;, &#x60;portfolio&#x60; and &#x60;user&#x60;, or &#x60;workspace&#x60; and &#x60;user&#x60;.
     * @param {Object} opts Optional parameters
     * @param {String} opts.portfolio The portfolio to filter results on.
     * @param {String} opts.workspace The workspace to filter results on.
     * @param {String} opts.user A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getPortfolioMembershipsWithHttpInfo",
    value: function(e) {
      e = e || {};
      var A = null, n = {}, i = {};
      e = e || {}, i = e;
      var a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.RETURN_COLLECTION ? gu.fromApiClient(this.apiClient.callApi("/portfolio_memberships", "GET", n, i, a, o, A, s, l, c, u), this.apiClient, {
        path: "/portfolio_memberships",
        httpMethod: "GET",
        pathParams: n,
        queryParams: i,
        headerParams: a,
        formParams: o,
        bodyParam: A,
        authNames: s,
        contentTypes: l,
        accepts: c,
        returnType: u
      }) : this.apiClient.callApi("/portfolio_memberships", "GET", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Get multiple portfolio memberships
     * Returns a list of portfolio memberships in compact representation. You must specify &#x60;portfolio&#x60;, &#x60;portfolio&#x60; and &#x60;user&#x60;, or &#x60;workspace&#x60; and &#x60;user&#x60;.
     * @param {Object} opts Optional parameters
     * @param {String} opts.portfolio The portfolio to filter results on.
     * @param {String} opts.workspace The workspace to filter results on.
     * @param {String} opts.user A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PortfolioMembershipResponseArray}
     */
  }, {
    key: "getPortfolioMemberships",
    value: function(e) {
      return this.apiClient.RETURN_COLLECTION ? this.getPortfolioMembershipsWithHttpInfo(e) : this.getPortfolioMembershipsWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get memberships from a portfolio
     * Returns the compact portfolio membership records for the portfolio.
     * @param {String} portfolio_gid Globally unique identifier for the portfolio.
     * @param {Object} opts Optional parameters
     * @param {String} opts.user A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getPortfolioMembershipsForPortfolioWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'portfolio_gid' when calling getPortfolioMembershipsForPortfolio");
      var i = {
        portfolio_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? gu.fromApiClient(this.apiClient.callApi("/portfolios/{portfolio_gid}/portfolio_memberships", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/portfolios/{portfolio_gid}/portfolio_memberships",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/portfolios/{portfolio_gid}/portfolio_memberships", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get memberships from a portfolio
     * Returns the compact portfolio membership records for the portfolio.
     * @param {<&vendorExtensions.x-jsdoc-type>} portfolio_gid Globally unique identifier for the portfolio.
     * @param {Object} opts Optional parameters
     * @param {String} opts.user A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PortfolioMembershipResponseArray}
     */
  }, {
    key: "getPortfolioMembershipsForPortfolio",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getPortfolioMembershipsForPortfolioWithHttpInfo(e, A) : this.getPortfolioMembershipsForPortfolioWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var Oi = {};
Object.defineProperty(Oi, "__esModule", {
  value: !0
});
Oi.PortfoliosApi = void 0;
var Em = le;
function qr(r) {
  "@babel/helpers - typeof";
  return qr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, qr(r);
}
function Cm(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function fm(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Bm(A.key), A);
  }
}
function Qm(r, t, e) {
  return t && fm(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Bm(r) {
  var t = Im(r, "string");
  return qr(t) == "symbol" ? t : t + "";
}
function Im(r, t) {
  if (qr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (qr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var Eu = de;
Oi.PortfoliosApi = /* @__PURE__ */ function() {
  function r(t) {
    Cm(this, r), this.apiClient = t || Em.ApiClient.instance;
  }
  return Qm(r, [{
    key: "addCustomFieldSettingForPortfolioWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling addCustomFieldSettingForPortfolio");
      if (A == null)
        throw new Error("Missing the required parameter 'portfolio_gid' when calling addCustomFieldSettingForPortfolio");
      var i = {
        portfolio_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/portfolios/{portfolio_gid}/addCustomFieldSetting", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Add a custom field to a portfolio
     * Custom fields are associated with portfolios by way of custom field settings.  This method creates a setting for the portfolio.
     * @param {<&vendorExtensions.x-jsdoc-type>} body Information about the custom field setting.
     * @param {<&vendorExtensions.x-jsdoc-type>} portfolio_gid Globally unique identifier for the portfolio.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CustomFieldSettingResponseData}
     */
  }, {
    key: "addCustomFieldSettingForPortfolio",
    value: function(e, A) {
      return this.addCustomFieldSettingForPortfolioWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Add a portfolio item
     * Add an item to a portfolio. Returns an empty data block.
     * @param {module:model/Object} body Information about the item being inserted.
     * @param {String} portfolio_gid Globally unique identifier for the portfolio.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "addItemForPortfolioWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling addItemForPortfolio");
      if (A == null)
        throw new Error("Missing the required parameter 'portfolio_gid' when calling addItemForPortfolio");
      var i = {
        portfolio_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/portfolios/{portfolio_gid}/addItem", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Add a portfolio item
     * Add an item to a portfolio. Returns an empty data block.
     * @param {<&vendorExtensions.x-jsdoc-type>} body Information about the item being inserted.
     * @param {<&vendorExtensions.x-jsdoc-type>} portfolio_gid Globally unique identifier for the portfolio.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "addItemForPortfolio",
    value: function(e, A) {
      return this.addItemForPortfolioWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Add users to a portfolio
     * Adds the specified list of users as members of the portfolio. Returns the updated portfolio record.
     * @param {module:model/Object} body Information about the members being added.
     * @param {String} portfolio_gid Globally unique identifier for the portfolio.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "addMembersForPortfolioWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling addMembersForPortfolio");
      if (A == null)
        throw new Error("Missing the required parameter 'portfolio_gid' when calling addMembersForPortfolio");
      var a = {
        portfolio_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/portfolios/{portfolio_gid}/addMembers", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Add users to a portfolio
     * Adds the specified list of users as members of the portfolio. Returns the updated portfolio record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body Information about the members being added.
     * @param {<&vendorExtensions.x-jsdoc-type>} portfolio_gid Globally unique identifier for the portfolio.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PortfolioResponseData}
     */
  }, {
    key: "addMembersForPortfolio",
    value: function(e, A, n) {
      return this.addMembersForPortfolioWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Create a portfolio
     * Creates a new portfolio in the given workspace with the supplied name.  Note that portfolios created in the Asana UI may have some state (like the Priority custom field) which is automatically added to the portfolio when it is created. Portfolios created via our API will *not* be created with the same initial state to allow integrations to create their own starting state on a portfolio.
     * @param {module:model/Object} body The portfolio to create.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "createPortfolioWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createPortfolio");
      var i = {}, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/portfolios", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Create a portfolio
     * Creates a new portfolio in the given workspace with the supplied name.  Note that portfolios created in the Asana UI may have some state (like the Priority custom field) which is automatically added to the portfolio when it is created. Portfolios created via our API will *not* be created with the same initial state to allow integrations to create their own starting state on a portfolio.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The portfolio to create.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PortfolioResponseData}
     */
  }, {
    key: "createPortfolio",
    value: function(e, A) {
      return this.createPortfolioWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Delete a portfolio
     * An existing portfolio can be deleted by making a DELETE request on the URL for that portfolio.  Returns an empty data record.
     * @param {String} portfolio_gid Globally unique identifier for the portfolio.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deletePortfolioWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'portfolio_gid' when calling deletePortfolio");
      var n = {
        portfolio_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/portfolios/{portfolio_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a portfolio
     * An existing portfolio can be deleted by making a DELETE request on the URL for that portfolio.  Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} portfolio_gid Globally unique identifier for the portfolio.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deletePortfolio",
    value: function(e) {
      return this.deletePortfolioWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get portfolio items
     * Get a list of the items in compact form in a portfolio.
     * @param {String} portfolio_gid Globally unique identifier for the portfolio.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getItemsForPortfolioWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'portfolio_gid' when calling getItemsForPortfolio");
      var i = {
        portfolio_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? Eu.fromApiClient(this.apiClient.callApi("/portfolios/{portfolio_gid}/items", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/portfolios/{portfolio_gid}/items",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/portfolios/{portfolio_gid}/items", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get portfolio items
     * Get a list of the items in compact form in a portfolio.
     * @param {<&vendorExtensions.x-jsdoc-type>} portfolio_gid Globally unique identifier for the portfolio.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectResponseArray}
     */
  }, {
    key: "getItemsForPortfolio",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getItemsForPortfolioWithHttpInfo(e, A) : this.getItemsForPortfolioWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get a portfolio
     * Returns the complete portfolio record for a single portfolio.
     * @param {String} portfolio_gid Globally unique identifier for the portfolio.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getPortfolioWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'portfolio_gid' when calling getPortfolio");
      var i = {
        portfolio_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/portfolios/{portfolio_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a portfolio
     * Returns the complete portfolio record for a single portfolio.
     * @param {<&vendorExtensions.x-jsdoc-type>} portfolio_gid Globally unique identifier for the portfolio.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PortfolioResponseData}
     */
  }, {
    key: "getPortfolio",
    value: function(e, A) {
      return this.getPortfolioWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get multiple portfolios
     * Returns a list of the portfolios in compact representation that are owned by the current API user.
     * @param {String} workspace The workspace or organization to filter portfolios on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.owner The user who owns the portfolio. Currently, API users can only get a list of portfolios that they themselves own, unless the request is made from a Service Account. In the case of a Service Account, if this parameter is specified, then all portfolios owned by this parameter are returned. Otherwise, all portfolios across the workspace are returned.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getPortfoliosWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'workspace' when calling getPortfolios");
      var i = {}, a = {};
      A = A || {}, a = A, a.workspace = e;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? Eu.fromApiClient(this.apiClient.callApi("/portfolios", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/portfolios",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/portfolios", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get multiple portfolios
     * Returns a list of the portfolios in compact representation that are owned by the current API user.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace The workspace or organization to filter portfolios on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.owner The user who owns the portfolio. Currently, API users can only get a list of portfolios that they themselves own, unless the request is made from a Service Account. In the case of a Service Account, if this parameter is specified, then all portfolios owned by this parameter are returned. Otherwise, all portfolios across the workspace are returned.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PortfolioResponseArray}
     */
  }, {
    key: "getPortfolios",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getPortfoliosWithHttpInfo(e, A) : this.getPortfoliosWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Remove a custom field from a portfolio
     * Removes a custom field setting from a portfolio.
     * @param {module:model/Object} body Information about the custom field setting being removed.
     * @param {String} portfolio_gid Globally unique identifier for the portfolio.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "removeCustomFieldSettingForPortfolioWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling removeCustomFieldSettingForPortfolio");
      if (A == null)
        throw new Error("Missing the required parameter 'portfolio_gid' when calling removeCustomFieldSettingForPortfolio");
      var i = {
        portfolio_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/portfolios/{portfolio_gid}/removeCustomFieldSetting", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Remove a custom field from a portfolio
     * Removes a custom field setting from a portfolio.
     * @param {<&vendorExtensions.x-jsdoc-type>} body Information about the custom field setting being removed.
     * @param {<&vendorExtensions.x-jsdoc-type>} portfolio_gid Globally unique identifier for the portfolio.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "removeCustomFieldSettingForPortfolio",
    value: function(e, A) {
      return this.removeCustomFieldSettingForPortfolioWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Remove a portfolio item
     * Remove an item from a portfolio. Returns an empty data block.
     * @param {module:model/Object} body Information about the item being removed.
     * @param {String} portfolio_gid Globally unique identifier for the portfolio.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "removeItemForPortfolioWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling removeItemForPortfolio");
      if (A == null)
        throw new Error("Missing the required parameter 'portfolio_gid' when calling removeItemForPortfolio");
      var i = {
        portfolio_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/portfolios/{portfolio_gid}/removeItem", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Remove a portfolio item
     * Remove an item from a portfolio. Returns an empty data block.
     * @param {<&vendorExtensions.x-jsdoc-type>} body Information about the item being removed.
     * @param {<&vendorExtensions.x-jsdoc-type>} portfolio_gid Globally unique identifier for the portfolio.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "removeItemForPortfolio",
    value: function(e, A) {
      return this.removeItemForPortfolioWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Remove users from a portfolio
     * Removes the specified list of users from members of the portfolio. Returns the updated portfolio record.
     * @param {module:model/Object} body Information about the members being removed.
     * @param {String} portfolio_gid Globally unique identifier for the portfolio.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "removeMembersForPortfolioWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling removeMembersForPortfolio");
      if (A == null)
        throw new Error("Missing the required parameter 'portfolio_gid' when calling removeMembersForPortfolio");
      var a = {
        portfolio_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/portfolios/{portfolio_gid}/removeMembers", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Remove users from a portfolio
     * Removes the specified list of users from members of the portfolio. Returns the updated portfolio record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body Information about the members being removed.
     * @param {<&vendorExtensions.x-jsdoc-type>} portfolio_gid Globally unique identifier for the portfolio.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PortfolioResponseData}
     */
  }, {
    key: "removeMembersForPortfolio",
    value: function(e, A, n) {
      return this.removeMembersForPortfolioWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Update a portfolio
     * An existing portfolio can be updated by making a PUT request on the URL for that portfolio. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated portfolio record.
     * @param {module:model/Object} body The updated fields for the portfolio.
     * @param {String} portfolio_gid Globally unique identifier for the portfolio.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updatePortfolioWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling updatePortfolio");
      if (A == null)
        throw new Error("Missing the required parameter 'portfolio_gid' when calling updatePortfolio");
      var a = {
        portfolio_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/portfolios/{portfolio_gid}", "PUT", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Update a portfolio
     * An existing portfolio can be updated by making a PUT request on the URL for that portfolio. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated portfolio record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The updated fields for the portfolio.
     * @param {<&vendorExtensions.x-jsdoc-type>} portfolio_gid Globally unique identifier for the portfolio.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/PortfolioResponseData}
     */
  }, {
    key: "updatePortfolio",
    value: function(e, A, n) {
      return this.updatePortfolioWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
  }]);
}();
var qi = {};
Object.defineProperty(qi, "__esModule", {
  value: !0
});
qi.ProjectBriefsApi = void 0;
var dm = le;
function jr(r) {
  "@babel/helpers - typeof";
  return jr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, jr(r);
}
function pm(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ym(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, wm(A.key), A);
  }
}
function mm(r, t, e) {
  return t && ym(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function wm(r) {
  var t = vm(r, "string");
  return jr(t) == "symbol" ? t : t + "";
}
function vm(r, t) {
  if (jr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (jr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
qi.ProjectBriefsApi = /* @__PURE__ */ function() {
  function r(t) {
    pm(this, r), this.apiClient = t || dm.ApiClient.instance;
  }
  return mm(r, [{
    key: "createProjectBriefWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createProjectBrief");
      if (A == null)
        throw new Error("Missing the required parameter 'project_gid' when calling createProjectBrief");
      var a = {
        project_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}/project_briefs", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Create a project brief
     * Creates a new project brief.  Returns the full record of the newly created project brief.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The project brief to create.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectBriefResponseData}
     */
  }, {
    key: "createProjectBrief",
    value: function(e, A, n) {
      return this.createProjectBriefWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Delete a project brief
     * Deletes a specific, existing project brief.  Returns an empty data record.
     * @param {String} project_brief_gid Globally unique identifier for the project brief.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deleteProjectBriefWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'project_brief_gid' when calling deleteProjectBrief");
      var n = {
        project_brief_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/project_briefs/{project_brief_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a project brief
     * Deletes a specific, existing project brief.  Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_brief_gid Globally unique identifier for the project brief.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteProjectBrief",
    value: function(e) {
      return this.deleteProjectBriefWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get a project brief
     * Get the full record for a project brief.
     * @param {String} project_brief_gid Globally unique identifier for the project brief.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getProjectBriefWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'project_brief_gid' when calling getProjectBrief");
      var i = {
        project_brief_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/project_briefs/{project_brief_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a project brief
     * Get the full record for a project brief.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_brief_gid Globally unique identifier for the project brief.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectBriefResponseData}
     */
  }, {
    key: "getProjectBrief",
    value: function(e, A) {
      return this.getProjectBriefWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Update a project brief
     * An existing project brief can be updated by making a PUT request on the URL for that project brief. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated project brief record.
     * @param {module:model/Object} body The updated fields for the project brief.
     * @param {String} project_brief_gid Globally unique identifier for the project brief.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateProjectBriefWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling updateProjectBrief");
      if (A == null)
        throw new Error("Missing the required parameter 'project_brief_gid' when calling updateProjectBrief");
      var a = {
        project_brief_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/project_briefs/{project_brief_gid}", "PUT", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Update a project brief
     * An existing project brief can be updated by making a PUT request on the URL for that project brief. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  Returns the complete updated project brief record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The updated fields for the project brief.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_brief_gid Globally unique identifier for the project brief.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectBriefResponseData}
     */
  }, {
    key: "updateProjectBrief",
    value: function(e, A, n) {
      return this.updateProjectBriefWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
  }]);
}();
var ji = {};
Object.defineProperty(ji, "__esModule", {
  value: !0
});
ji.ProjectMembershipsApi = void 0;
var km = le;
function Vr(r) {
  "@babel/helpers - typeof";
  return Vr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Vr(r);
}
function bm(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Tm(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Rm(A.key), A);
  }
}
function Fm(r, t, e) {
  return t && Tm(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Rm(r) {
  var t = Dm(r, "string");
  return Vr(t) == "symbol" ? t : t + "";
}
function Dm(r, t) {
  if (Vr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Vr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var Nm = de;
ji.ProjectMembershipsApi = /* @__PURE__ */ function() {
  function r(t) {
    bm(this, r), this.apiClient = t || km.ApiClient.instance;
  }
  return Fm(r, [{
    key: "getProjectMembershipWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'project_membership_gid' when calling getProjectMembership");
      var i = {
        project_membership_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/project_memberships/{project_membership_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a project membership
     * Returns the complete project record for a single project membership.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_membership_gid 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectMembershipNormalResponseData}
     */
  }, {
    key: "getProjectMembership",
    value: function(e, A) {
      return this.getProjectMembershipWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get memberships from a project
     * Returns the compact project membership records for the project.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {String} opts.user A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getProjectMembershipsForProjectWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'project_gid' when calling getProjectMembershipsForProject");
      var i = {
        project_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? Nm.fromApiClient(this.apiClient.callApi("/projects/{project_gid}/project_memberships", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/projects/{project_gid}/project_memberships",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/projects/{project_gid}/project_memberships", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get memberships from a project
     * Returns the compact project membership records for the project.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {String} opts.user A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectMembershipCompactArray}
     */
  }, {
    key: "getProjectMembershipsForProject",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getProjectMembershipsForProjectWithHttpInfo(e, A) : this.getProjectMembershipsForProjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var Vi = {};
Object.defineProperty(Vi, "__esModule", {
  value: !0
});
Vi.ProjectStatusesApi = void 0;
var Sm = le;
function $r(r) {
  "@babel/helpers - typeof";
  return $r = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, $r(r);
}
function Um(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Pm(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Lm(A.key), A);
  }
}
function Mm(r, t, e) {
  return t && Pm(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Lm(r) {
  var t = Hm(r, "string");
  return $r(t) == "symbol" ? t : t + "";
}
function Hm(r, t) {
  if ($r(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if ($r(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var Gm = de;
Vi.ProjectStatusesApi = /* @__PURE__ */ function() {
  function r(t) {
    Um(this, r), this.apiClient = t || Sm.ApiClient.instance;
  }
  return Mm(r, [{
    key: "createProjectStatusForProjectWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createProjectStatusForProject");
      if (A == null)
        throw new Error("Missing the required parameter 'project_gid' when calling createProjectStatusForProject");
      var a = {
        project_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}/project_statuses", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Create a project status
     * *Deprecated: new integrations should prefer the &#x60;/status_updates&#x60; route.*  Creates a new status update on the project.  Returns the full record of the newly created project status update.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The project status to create.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectStatusResponseData}
     */
  }, {
    key: "createProjectStatusForProject",
    value: function(e, A, n) {
      return this.createProjectStatusForProjectWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Delete a project status
     * *Deprecated: new integrations should prefer the &#x60;/status_updates/{status_gid}&#x60; route.*  Deletes a specific, existing project status update.  Returns an empty data record.
     * @param {String} project_status_gid The project status update to get.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deleteProjectStatusWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'project_status_gid' when calling deleteProjectStatus");
      var n = {
        project_status_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/project_statuses/{project_status_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a project status
     * *Deprecated: new integrations should prefer the &#x60;/status_updates/{status_gid}&#x60; route.*  Deletes a specific, existing project status update.  Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_status_gid The project status update to get.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteProjectStatus",
    value: function(e) {
      return this.deleteProjectStatusWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get a project status
     * *Deprecated: new integrations should prefer the &#x60;/status_updates/{status_gid}&#x60; route.*  Returns the complete record for a single status update.
     * @param {String} project_status_gid The project status update to get.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getProjectStatusWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'project_status_gid' when calling getProjectStatus");
      var i = {
        project_status_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/project_statuses/{project_status_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a project status
     * *Deprecated: new integrations should prefer the &#x60;/status_updates/{status_gid}&#x60; route.*  Returns the complete record for a single status update.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_status_gid The project status update to get.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectStatusResponseData}
     */
  }, {
    key: "getProjectStatus",
    value: function(e, A) {
      return this.getProjectStatusWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get statuses from a project
     * *Deprecated: new integrations should prefer the &#x60;/status_updates&#x60; route.*  Returns the compact project status update records for all updates on the project.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getProjectStatusesForProjectWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'project_gid' when calling getProjectStatusesForProject");
      var i = {
        project_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? Gm.fromApiClient(this.apiClient.callApi("/projects/{project_gid}/project_statuses", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/projects/{project_gid}/project_statuses",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/projects/{project_gid}/project_statuses", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get statuses from a project
     * *Deprecated: new integrations should prefer the &#x60;/status_updates&#x60; route.*  Returns the compact project status update records for all updates on the project.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectStatusResponseArray}
     */
  }, {
    key: "getProjectStatusesForProject",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getProjectStatusesForProjectWithHttpInfo(e, A) : this.getProjectStatusesForProjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var $i = {};
Object.defineProperty($i, "__esModule", {
  value: !0
});
$i.ProjectTemplatesApi = void 0;
var Wm = le;
function Xr(r) {
  "@babel/helpers - typeof";
  return Xr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Xr(r);
}
function Ym(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Jm(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, xm(A.key), A);
  }
}
function _m(r, t, e) {
  return t && Jm(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function xm(r) {
  var t = Om(r, "string");
  return Xr(t) == "symbol" ? t : t + "";
}
function Om(r, t) {
  if (Xr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Xr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var Cu = de;
$i.ProjectTemplatesApi = /* @__PURE__ */ function() {
  function r(t) {
    Ym(this, r), this.apiClient = t || Wm.ApiClient.instance;
  }
  return _m(r, [{
    key: "deleteProjectTemplateWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'project_template_gid' when calling deleteProjectTemplate");
      var n = {
        project_template_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/project_templates/{project_template_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a project template
     * A specific, existing project template can be deleted by making a DELETE request on the URL for that project template.  Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_template_gid Globally unique identifier for the project template.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteProjectTemplate",
    value: function(e) {
      return this.deleteProjectTemplateWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get a project template
     * Returns the complete project template record for a single project template.
     * @param {String} project_template_gid Globally unique identifier for the project template.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getProjectTemplateWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'project_template_gid' when calling getProjectTemplate");
      var i = {
        project_template_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/project_templates/{project_template_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a project template
     * Returns the complete project template record for a single project template.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_template_gid Globally unique identifier for the project template.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectTemplateResponseData}
     */
  }, {
    key: "getProjectTemplate",
    value: function(e, A) {
      return this.getProjectTemplateWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get multiple project templates
     * Returns the compact project template records for all project templates in the given team or workspace.
     * @param {Object} opts Optional parameters
     * @param {String} opts.workspace The workspace to filter results on.
     * @param {String} opts.team The team to filter projects on.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getProjectTemplatesWithHttpInfo",
    value: function(e) {
      e = e || {};
      var A = null, n = {}, i = {};
      e = e || {}, i = e;
      var a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.RETURN_COLLECTION ? Cu.fromApiClient(this.apiClient.callApi("/project_templates", "GET", n, i, a, o, A, s, l, c, u), this.apiClient, {
        path: "/project_templates",
        httpMethod: "GET",
        pathParams: n,
        queryParams: i,
        headerParams: a,
        formParams: o,
        bodyParam: A,
        authNames: s,
        contentTypes: l,
        accepts: c,
        returnType: u
      }) : this.apiClient.callApi("/project_templates", "GET", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Get multiple project templates
     * Returns the compact project template records for all project templates in the given team or workspace.
     * @param {Object} opts Optional parameters
     * @param {String} opts.workspace The workspace to filter results on.
     * @param {String} opts.team The team to filter projects on.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectTemplateResponseArray}
     */
  }, {
    key: "getProjectTemplates",
    value: function(e) {
      return this.apiClient.RETURN_COLLECTION ? this.getProjectTemplatesWithHttpInfo(e) : this.getProjectTemplatesWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get a team&#x27;s project templates
     * Returns the compact project template records for all project templates in the team.
     * @param {String} team_gid Globally unique identifier for the team.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getProjectTemplatesForTeamWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'team_gid' when calling getProjectTemplatesForTeam");
      var i = {
        team_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? Cu.fromApiClient(this.apiClient.callApi("/teams/{team_gid}/project_templates", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/teams/{team_gid}/project_templates",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/teams/{team_gid}/project_templates", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a team&#x27;s project templates
     * Returns the compact project template records for all project templates in the team.
     * @param {<&vendorExtensions.x-jsdoc-type>} team_gid Globally unique identifier for the team.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectTemplateResponseArray}
     */
  }, {
    key: "getProjectTemplatesForTeam",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getProjectTemplatesForTeamWithHttpInfo(e, A) : this.getProjectTemplatesForTeamWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Instantiate a project from a project template
     * Creates and returns a job that will asynchronously handle the project instantiation.  To form this request, it is recommended to first make a request to [get a project template](/reference/getprojecttemplate). Then, from the response, copy the &#x60;gid&#x60; from the object in the &#x60;requested_dates&#x60; array. This &#x60;gid&#x60; should be used in &#x60;requested_dates&#x60; to instantiate a project.  _Note: The body of this request will differ if your workspace is an organization. To determine if your workspace is an organization, use the [is_organization](/reference/workspaces) parameter._
     * @param {String} project_template_gid Globally unique identifier for the project template.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body Describes the inputs used for instantiating a project, such as the resulting project&#x27;s name, which team it should be created in, and values for date variables.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "instantiateProjectWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = A.body;
      if (e == null)
        throw new Error("Missing the required parameter 'project_template_gid' when calling instantiateProject");
      var i = {
        project_template_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/project_templates/{project_template_gid}/instantiateProject", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Instantiate a project from a project template
     * Creates and returns a job that will asynchronously handle the project instantiation.  To form this request, it is recommended to first make a request to [get a project template](/reference/getprojecttemplate). Then, from the response, copy the &#x60;gid&#x60; from the object in the &#x60;requested_dates&#x60; array. This &#x60;gid&#x60; should be used in &#x60;requested_dates&#x60; to instantiate a project.  _Note: The body of this request will differ if your workspace is an organization. To determine if your workspace is an organization, use the [is_organization](/reference/workspaces) parameter._
     * @param {<&vendorExtensions.x-jsdoc-type>} project_template_gid Globally unique identifier for the project template.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body Describes the inputs used for instantiating a project, such as the resulting project&#x27;s name, which team it should be created in, and values for date variables.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/JobResponseData}
     */
  }, {
    key: "instantiateProject",
    value: function(e, A) {
      return this.instantiateProjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var Xi = {};
Object.defineProperty(Xi, "__esModule", {
  value: !0
});
Xi.ProjectsApi = void 0;
var qm = le;
function Zr(r) {
  "@babel/helpers - typeof";
  return Zr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Zr(r);
}
function jm(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Vm(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Xm(A.key), A);
  }
}
function $m(r, t, e) {
  return t && Vm(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Xm(r) {
  var t = Zm(r, "string");
  return Zr(t) == "symbol" ? t : t + "";
}
function Zm(r, t) {
  if (Zr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Zr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var zn = de;
Xi.ProjectsApi = /* @__PURE__ */ function() {
  function r(t) {
    jm(this, r), this.apiClient = t || qm.ApiClient.instance;
  }
  return $m(r, [{
    key: "addCustomFieldSettingForProjectWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling addCustomFieldSettingForProject");
      if (A == null)
        throw new Error("Missing the required parameter 'project_gid' when calling addCustomFieldSettingForProject");
      var a = {
        project_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}/addCustomFieldSetting", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Add a custom field to a project
     * Custom fields are associated with projects by way of custom field settings.  This method creates a setting for the project.
     * @param {<&vendorExtensions.x-jsdoc-type>} body Information about the custom field setting.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/CustomFieldSettingResponseData}
     */
  }, {
    key: "addCustomFieldSettingForProject",
    value: function(e, A, n) {
      return this.addCustomFieldSettingForProjectWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Add followers to a project
     * Adds the specified list of users as followers to the project. Followers are a subset of members who have opted in to receive \&quot;tasks added\&quot; notifications for a project. Therefore, if the users are not already members of the project, they will also become members as a result of this operation. Returns the updated project record.
     * @param {module:model/Object} body Information about the followers being added.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "addFollowersForProjectWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling addFollowersForProject");
      if (A == null)
        throw new Error("Missing the required parameter 'project_gid' when calling addFollowersForProject");
      var a = {
        project_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}/addFollowers", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Add followers to a project
     * Adds the specified list of users as followers to the project. Followers are a subset of members who have opted in to receive \&quot;tasks added\&quot; notifications for a project. Therefore, if the users are not already members of the project, they will also become members as a result of this operation. Returns the updated project record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body Information about the followers being added.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectResponseData}
     */
  }, {
    key: "addFollowersForProject",
    value: function(e, A, n) {
      return this.addFollowersForProjectWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Add users to a project
     * Adds the specified list of users as members of the project. Note that a user being added as a member may also be added as a *follower* as a result of this operation. This is because the user&#x27;s default notification settings (i.e., in the \&quot;Notifcations\&quot; tab of \&quot;My Profile Settings\&quot;) will override this endpoint&#x27;s default behavior of setting \&quot;Tasks added\&quot; notifications to &#x60;false&#x60;. Returns the updated project record.
     * @param {module:model/Object} body Information about the members being added.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "addMembersForProjectWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling addMembersForProject");
      if (A == null)
        throw new Error("Missing the required parameter 'project_gid' when calling addMembersForProject");
      var a = {
        project_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}/addMembers", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Add users to a project
     * Adds the specified list of users as members of the project. Note that a user being added as a member may also be added as a *follower* as a result of this operation. This is because the user&#x27;s default notification settings (i.e., in the \&quot;Notifcations\&quot; tab of \&quot;My Profile Settings\&quot;) will override this endpoint&#x27;s default behavior of setting \&quot;Tasks added\&quot; notifications to &#x60;false&#x60;. Returns the updated project record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body Information about the members being added.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectResponseData}
     */
  }, {
    key: "addMembersForProject",
    value: function(e, A, n) {
      return this.addMembersForProjectWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Create a project
     * Create a new project in a workspace or team.  Every project is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the &#x60;workspace&#x60; parameter regardless of whether or not it is an organization.  If the workspace for your project is an organization, you must also supply a &#x60;team&#x60; to share the project with.  Returns the full record of the newly created project.
     * @param {module:model/Object} body The project to create.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "createProjectWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createProject");
      var i = {}, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/projects", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Create a project
     * Create a new project in a workspace or team.  Every project is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the &#x60;workspace&#x60; parameter regardless of whether or not it is an organization.  If the workspace for your project is an organization, you must also supply a &#x60;team&#x60; to share the project with.  Returns the full record of the newly created project.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The project to create.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectResponseData}
     */
  }, {
    key: "createProject",
    value: function(e, A) {
      return this.createProjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Create a project in a team
     * Creates a project shared with the given team.  Returns the full record of the newly created project.
     * @param {module:model/Object} body The new project to create.
     * @param {String} team_gid Globally unique identifier for the team.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "createProjectForTeamWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createProjectForTeam");
      if (A == null)
        throw new Error("Missing the required parameter 'team_gid' when calling createProjectForTeam");
      var a = {
        team_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/teams/{team_gid}/projects", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Create a project in a team
     * Creates a project shared with the given team.  Returns the full record of the newly created project.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The new project to create.
     * @param {<&vendorExtensions.x-jsdoc-type>} team_gid Globally unique identifier for the team.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectResponseData}
     */
  }, {
    key: "createProjectForTeam",
    value: function(e, A, n) {
      return this.createProjectForTeamWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Create a project in a workspace
     * Creates a project in the workspace.  If the workspace for your project is an organization, you must also supply a team to share the project with.  Returns the full record of the newly created project.
     * @param {module:model/Object} body The new project to create.
     * @param {String} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "createProjectForWorkspaceWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createProjectForWorkspace");
      if (A == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling createProjectForWorkspace");
      var a = {
        workspace_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/workspaces/{workspace_gid}/projects", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Create a project in a workspace
     * Creates a project in the workspace.  If the workspace for your project is an organization, you must also supply a team to share the project with.  Returns the full record of the newly created project.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The new project to create.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectResponseData}
     */
  }, {
    key: "createProjectForWorkspace",
    value: function(e, A, n) {
      return this.createProjectForWorkspaceWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Delete a project
     * A specific, existing project can be deleted by making a DELETE request on the URL for that project.  Returns an empty data record.
     * @param {String} project_gid Globally unique identifier for the project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deleteProjectWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'project_gid' when calling deleteProject");
      var n = {
        project_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a project
     * A specific, existing project can be deleted by making a DELETE request on the URL for that project.  Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteProject",
    value: function(e) {
      return this.deleteProjectWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Duplicate a project
     * Creates and returns a job that will asynchronously handle the duplication.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body Describes the duplicate&#x27;s name and the elements that will be duplicated.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "duplicateProjectWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = A.body;
      if (e == null)
        throw new Error("Missing the required parameter 'project_gid' when calling duplicateProject");
      var i = {
        project_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}/duplicate", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Duplicate a project
     * Creates and returns a job that will asynchronously handle the duplication.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body Describes the duplicate&#x27;s name and the elements that will be duplicated.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/JobResponseData}
     */
  }, {
    key: "duplicateProject",
    value: function(e, A) {
      return this.duplicateProjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get a project
     * Returns the complete project record for a single project.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getProjectWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'project_gid' when calling getProject");
      var i = {
        project_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a project
     * Returns the complete project record for a single project.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectResponseData}
     */
  }, {
    key: "getProject",
    value: function(e, A) {
      return this.getProjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get multiple projects
     * Returns the compact project records for some filtered set of projects. Use one or more of the parameters provided to filter the projects returned. *Note: This endpoint may timeout for large domains. Try filtering by team!*
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.workspace The workspace or organization to filter projects on.
     * @param {String} opts.team The team to filter projects on.
     * @param {Boolean} opts.archived Only return projects whose &#x60;archived&#x60; field takes on the value of this parameter.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getProjectsWithHttpInfo",
    value: function(e) {
      e = e || {};
      var A = null, n = {}, i = {};
      e = e || {}, i = e;
      var a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.RETURN_COLLECTION ? zn.fromApiClient(this.apiClient.callApi("/projects", "GET", n, i, a, o, A, s, l, c, u), this.apiClient, {
        path: "/projects",
        httpMethod: "GET",
        pathParams: n,
        queryParams: i,
        headerParams: a,
        formParams: o,
        bodyParam: A,
        authNames: s,
        contentTypes: l,
        accepts: c,
        returnType: u
      }) : this.apiClient.callApi("/projects", "GET", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Get multiple projects
     * Returns the compact project records for some filtered set of projects. Use one or more of the parameters provided to filter the projects returned. *Note: This endpoint may timeout for large domains. Try filtering by team!*
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.workspace The workspace or organization to filter projects on.
     * @param {String} opts.team The team to filter projects on.
     * @param {Boolean} opts.archived Only return projects whose &#x60;archived&#x60; field takes on the value of this parameter.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectResponseArray}
     */
  }, {
    key: "getProjects",
    value: function(e) {
      return this.apiClient.RETURN_COLLECTION ? this.getProjectsWithHttpInfo(e) : this.getProjectsWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get projects a task is in
     * Returns a compact representation of all of the projects the task is in.
     * @param {String} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getProjectsForTaskWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'task_gid' when calling getProjectsForTask");
      var i = {
        task_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? zn.fromApiClient(this.apiClient.callApi("/tasks/{task_gid}/projects", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/tasks/{task_gid}/projects",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/tasks/{task_gid}/projects", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get projects a task is in
     * Returns a compact representation of all of the projects the task is in.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectResponseArray}
     */
  }, {
    key: "getProjectsForTask",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getProjectsForTaskWithHttpInfo(e, A) : this.getProjectsForTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get a team&#x27;s projects
     * Returns the compact project records for all projects in the team.
     * @param {String} team_gid Globally unique identifier for the team.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Boolean} opts.archived Only return projects whose &#x60;archived&#x60; field takes on the value of this parameter.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getProjectsForTeamWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'team_gid' when calling getProjectsForTeam");
      var i = {
        team_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? zn.fromApiClient(this.apiClient.callApi("/teams/{team_gid}/projects", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/teams/{team_gid}/projects",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/teams/{team_gid}/projects", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a team&#x27;s projects
     * Returns the compact project records for all projects in the team.
     * @param {<&vendorExtensions.x-jsdoc-type>} team_gid Globally unique identifier for the team.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Boolean} opts.archived Only return projects whose &#x60;archived&#x60; field takes on the value of this parameter.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectResponseArray}
     */
  }, {
    key: "getProjectsForTeam",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getProjectsForTeamWithHttpInfo(e, A) : this.getProjectsForTeamWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get all projects in a workspace
     * Returns the compact project records for all projects in the workspace. *Note: This endpoint may timeout for large domains. Prefer the &#x60;/teams/{team_gid}/projects&#x60; endpoint.*
     * @param {String} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Boolean} opts.archived Only return projects whose &#x60;archived&#x60; field takes on the value of this parameter.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getProjectsForWorkspaceWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling getProjectsForWorkspace");
      var i = {
        workspace_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? zn.fromApiClient(this.apiClient.callApi("/workspaces/{workspace_gid}/projects", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/workspaces/{workspace_gid}/projects",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/workspaces/{workspace_gid}/projects", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get all projects in a workspace
     * Returns the compact project records for all projects in the workspace. *Note: This endpoint may timeout for large domains. Prefer the &#x60;/teams/{team_gid}/projects&#x60; endpoint.*
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Boolean} opts.archived Only return projects whose &#x60;archived&#x60; field takes on the value of this parameter.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectResponseArray}
     */
  }, {
    key: "getProjectsForWorkspace",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getProjectsForWorkspaceWithHttpInfo(e, A) : this.getProjectsForWorkspaceWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get task count of a project
     * Get an object that holds task count fields. **All fields are excluded by default**. You must [opt in](/docs/inputoutput-options) using &#x60;opt_fields&#x60; to get any information from this endpoint.  This endpoint has an additional [rate limit](/docs/rate-limits) and each field counts especially high against our [cost limits](/docs/rate-limits#cost-limits).  Milestones are just tasks, so they are included in the &#x60;num_tasks&#x60;, &#x60;num_incomplete_tasks&#x60;, and &#x60;num_completed_tasks&#x60; counts.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTaskCountsForProjectWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'project_gid' when calling getTaskCountsForProject");
      var i = {
        project_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}/task_counts", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get task count of a project
     * Get an object that holds task count fields. **All fields are excluded by default**. You must [opt in](/docs/inputoutput-options) using &#x60;opt_fields&#x60; to get any information from this endpoint.  This endpoint has an additional [rate limit](/docs/rate-limits) and each field counts especially high against our [cost limits](/docs/rate-limits#cost-limits).  Milestones are just tasks, so they are included in the &#x60;num_tasks&#x60;, &#x60;num_incomplete_tasks&#x60;, and &#x60;num_completed_tasks&#x60; counts.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskCountResponseData}
     */
  }, {
    key: "getTaskCountsForProject",
    value: function(e, A) {
      return this.getTaskCountsForProjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Create a project template from a project
     * Creates and returns a job that will asynchronously handle the project template creation. Note that while the resulting project template can be accessed with the API, it won&#x27;t be visible in the Asana UI until Project Templates 2.0 is launched in the app. See more in [this forum post](https://forum.asana.com/t/a-new-api-for-project-templates/156432).
     * @param {module:model/Object} body Describes the inputs used for creating a project template, such as the resulting project template&#x27;s name, which team it should be created in.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "projectSaveAsTemplateWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling projectSaveAsTemplate");
      if (A == null)
        throw new Error("Missing the required parameter 'project_gid' when calling projectSaveAsTemplate");
      var a = {
        project_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}/saveAsTemplate", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Create a project template from a project
     * Creates and returns a job that will asynchronously handle the project template creation. Note that while the resulting project template can be accessed with the API, it won&#x27;t be visible in the Asana UI until Project Templates 2.0 is launched in the app. See more in [this forum post](https://forum.asana.com/t/a-new-api-for-project-templates/156432).
     * @param {<&vendorExtensions.x-jsdoc-type>} body Describes the inputs used for creating a project template, such as the resulting project template&#x27;s name, which team it should be created in.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/JobResponseData}
     */
  }, {
    key: "projectSaveAsTemplate",
    value: function(e, A, n) {
      return this.projectSaveAsTemplateWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Remove a custom field from a project
     * Removes a custom field setting from a project.
     * @param {module:model/Object} body Information about the custom field setting being removed.
     * @param {String} project_gid Globally unique identifier for the project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "removeCustomFieldSettingForProjectWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling removeCustomFieldSettingForProject");
      if (A == null)
        throw new Error("Missing the required parameter 'project_gid' when calling removeCustomFieldSettingForProject");
      var i = {
        project_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}/removeCustomFieldSetting", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Remove a custom field from a project
     * Removes a custom field setting from a project.
     * @param {<&vendorExtensions.x-jsdoc-type>} body Information about the custom field setting being removed.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "removeCustomFieldSettingForProject",
    value: function(e, A) {
      return this.removeCustomFieldSettingForProjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Remove followers from a project
     * Removes the specified list of users from following the project, this will not affect project membership status. Returns the updated project record.
     * @param {module:model/Object} body Information about the followers being removed.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "removeFollowersForProjectWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling removeFollowersForProject");
      if (A == null)
        throw new Error("Missing the required parameter 'project_gid' when calling removeFollowersForProject");
      var a = {
        project_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}/removeFollowers", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Remove followers from a project
     * Removes the specified list of users from following the project, this will not affect project membership status. Returns the updated project record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body Information about the followers being removed.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectResponseData}
     */
  }, {
    key: "removeFollowersForProject",
    value: function(e, A, n) {
      return this.removeFollowersForProjectWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Remove users from a project
     * Removes the specified list of users from members of the project. Returns the updated project record.
     * @param {module:model/Object} body Information about the members being removed.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "removeMembersForProjectWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling removeMembersForProject");
      if (A == null)
        throw new Error("Missing the required parameter 'project_gid' when calling removeMembersForProject");
      var a = {
        project_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}/removeMembers", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Remove users from a project
     * Removes the specified list of users from members of the project. Returns the updated project record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body Information about the members being removed.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectResponseData}
     */
  }, {
    key: "removeMembersForProject",
    value: function(e, A, n) {
      return this.removeMembersForProjectWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Update a project
     * A specific, existing project can be updated by making a PUT request on the URL for that project. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated project record.
     * @param {module:model/Object} body The updated fields for the project.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateProjectWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling updateProject");
      if (A == null)
        throw new Error("Missing the required parameter 'project_gid' when calling updateProject");
      var a = {
        project_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}", "PUT", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Update a project
     * A specific, existing project can be updated by making a PUT request on the URL for that project. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated project record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The updated fields for the project.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/ProjectResponseData}
     */
  }, {
    key: "updateProject",
    value: function(e, A, n) {
      return this.updateProjectWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
  }]);
}();
var Zi = {};
Object.defineProperty(Zi, "__esModule", {
  value: !0
});
Zi.RulesApi = void 0;
var Km = le;
function Kr(r) {
  "@babel/helpers - typeof";
  return Kr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Kr(r);
}
function zm(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ew(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, tw(A.key), A);
  }
}
function Aw(r, t, e) {
  return t && ew(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function tw(r) {
  var t = rw(r, "string");
  return Kr(t) == "symbol" ? t : t + "";
}
function rw(r, t) {
  if (Kr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Kr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
Zi.RulesApi = /* @__PURE__ */ function() {
  function r(t) {
    zm(this, r), this.apiClient = t || Km.ApiClient.instance;
  }
  return Aw(r, [{
    key: "triggerRuleWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling triggerRule");
      if (A == null)
        throw new Error("Missing the required parameter 'rule_trigger_gid' when calling triggerRule");
      var i = {
        rule_trigger_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/rule_triggers/{rule_trigger_gid}/run", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Trigger a rule
     * Trigger a rule which uses an [\&quot;incoming web request\&quot;](/docs/incoming-web-requests) trigger.
     * @param {<&vendorExtensions.x-jsdoc-type>} body A dictionary of variables accessible from within the rule.
     * @param {<&vendorExtensions.x-jsdoc-type>} rule_trigger_gid The ID of the incoming web request trigger. This value is a path parameter that is automatically generated for the API endpoint.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/RuleTriggerResponseData}
     */
  }, {
    key: "triggerRule",
    value: function(e, A) {
      return this.triggerRuleWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var Ki = {};
Object.defineProperty(Ki, "__esModule", {
  value: !0
});
Ki.SectionsApi = void 0;
var nw = le;
function zr(r) {
  "@babel/helpers - typeof";
  return zr = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, zr(r);
}
function iw(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function aw(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, sw(A.key), A);
  }
}
function ow(r, t, e) {
  return t && aw(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function sw(r) {
  var t = cw(r, "string");
  return zr(t) == "symbol" ? t : t + "";
}
function cw(r, t) {
  if (zr(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (zr(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var lw = de;
Ki.SectionsApi = /* @__PURE__ */ function() {
  function r(t) {
    iw(this, r), this.apiClient = t || nw.ApiClient.instance;
  }
  return ow(r, [{
    key: "addTaskForSectionWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = A.body;
      if (e == null)
        throw new Error("Missing the required parameter 'section_gid' when calling addTaskForSection");
      var i = {
        section_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/sections/{section_gid}/addTask", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Add task to section
     * Add a task to a specific, existing section. This will remove the task from other sections of the project.  The task will be inserted at the top of a section unless an insert_before or insert_after parameter is declared.  This does not work for separators (tasks with the resource_subtype of section).
     * @param {<&vendorExtensions.x-jsdoc-type>} section_gid The globally unique identifier for the section.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The task and optionally the insert location.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "addTaskForSection",
    value: function(e, A) {
      return this.addTaskForSectionWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Create a section in a project
     * Creates a new section in a project. Returns the full record of the newly created section.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The section to create.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "createSectionForProjectWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = A.body;
      if (e == null)
        throw new Error("Missing the required parameter 'project_gid' when calling createSectionForProject");
      var i = {
        project_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}/sections", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Create a section in a project
     * Creates a new section in a project. Returns the full record of the newly created section.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The section to create.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/SectionResponseData}
     */
  }, {
    key: "createSectionForProject",
    value: function(e, A) {
      return this.createSectionForProjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Delete a section
     * A specific, existing section can be deleted by making a DELETE request on the URL for that section.  Note that sections must be empty to be deleted.  The last remaining section cannot be deleted.  Returns an empty data block.
     * @param {String} section_gid The globally unique identifier for the section.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deleteSectionWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'section_gid' when calling deleteSection");
      var n = {
        section_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/sections/{section_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a section
     * A specific, existing section can be deleted by making a DELETE request on the URL for that section.  Note that sections must be empty to be deleted.  The last remaining section cannot be deleted.  Returns an empty data block.
     * @param {<&vendorExtensions.x-jsdoc-type>} section_gid The globally unique identifier for the section.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteSection",
    value: function(e) {
      return this.deleteSectionWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get a section
     * Returns the complete record for a single section.
     * @param {String} section_gid The globally unique identifier for the section.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getSectionWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'section_gid' when calling getSection");
      var i = {
        section_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/sections/{section_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a section
     * Returns the complete record for a single section.
     * @param {<&vendorExtensions.x-jsdoc-type>} section_gid The globally unique identifier for the section.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/SectionResponseData}
     */
  }, {
    key: "getSection",
    value: function(e, A) {
      return this.getSectionWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get sections in a project
     * Returns the compact records for all sections in the specified project.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getSectionsForProjectWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'project_gid' when calling getSectionsForProject");
      var i = {
        project_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? lw.fromApiClient(this.apiClient.callApi("/projects/{project_gid}/sections", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/projects/{project_gid}/sections",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/projects/{project_gid}/sections", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get sections in a project
     * Returns the compact records for all sections in the specified project.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/SectionResponseArray}
     */
  }, {
    key: "getSectionsForProject",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getSectionsForProjectWithHttpInfo(e, A) : this.getSectionsForProjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Move or Insert sections
     * Move sections relative to each other. One of &#x60;before_section&#x60; or &#x60;after_section&#x60; is required.  Sections cannot be moved between projects.  Returns an empty data block.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The section&#x27;s move action.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "insertSectionForProjectWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = A.body;
      if (e == null)
        throw new Error("Missing the required parameter 'project_gid' when calling insertSectionForProject");
      var i = {
        project_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/projects/{project_gid}/sections/insert", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Move or Insert sections
     * Move sections relative to each other. One of &#x60;before_section&#x60; or &#x60;after_section&#x60; is required.  Sections cannot be moved between projects.  Returns an empty data block.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The section&#x27;s move action.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "insertSectionForProject",
    value: function(e, A) {
      return this.insertSectionForProjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Update a section
     * A specific, existing section can be updated by making a PUT request on the URL for that project. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged. (note that at this time, the only field that can be updated is the &#x60;name&#x60; field.)  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated section record.
     * @param {String} section_gid The globally unique identifier for the section.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The section to create.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateSectionWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = A.body;
      if (e == null)
        throw new Error("Missing the required parameter 'section_gid' when calling updateSection");
      var i = {
        section_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/sections/{section_gid}", "PUT", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Update a section
     * A specific, existing section can be updated by making a PUT request on the URL for that project. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged. (note that at this time, the only field that can be updated is the &#x60;name&#x60; field.)  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated section record.
     * @param {<&vendorExtensions.x-jsdoc-type>} section_gid The globally unique identifier for the section.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body The section to create.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/SectionResponseData}
     */
  }, {
    key: "updateSection",
    value: function(e, A) {
      return this.updateSectionWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var zi = {};
Object.defineProperty(zi, "__esModule", {
  value: !0
});
zi.StatusUpdatesApi = void 0;
var uw = le;
function en(r) {
  "@babel/helpers - typeof";
  return en = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, en(r);
}
function hw(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function gw(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Cw(A.key), A);
  }
}
function Ew(r, t, e) {
  return t && gw(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Cw(r) {
  var t = fw(r, "string");
  return en(t) == "symbol" ? t : t + "";
}
function fw(r, t) {
  if (en(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (en(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var Qw = de;
zi.StatusUpdatesApi = /* @__PURE__ */ function() {
  function r(t) {
    hw(this, r), this.apiClient = t || uw.ApiClient.instance;
  }
  return Ew(r, [{
    key: "createStatusForObjectWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createStatusForObject");
      var i = {}, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/status_updates", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Create a status update
     * Creates a new status update on an object. Returns the full record of the newly created status update.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The status update to create.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/StatusUpdateResponseData}
     */
  }, {
    key: "createStatusForObject",
    value: function(e, A) {
      return this.createStatusForObjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Delete a status update
     * Deletes a specific, existing status update.  Returns an empty data record.
     * @param {String} status_update_gid The status update to get.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deleteStatusWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'status_update_gid' when calling deleteStatus");
      var n = {
        status_update_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/status_updates/{status_update_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a status update
     * Deletes a specific, existing status update.  Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} status_update_gid The status update to get.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteStatus",
    value: function(e) {
      return this.deleteStatusWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get a status update
     * Returns the complete record for a single status update.
     * @param {String} status_update_gid The status update to get.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getStatusWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'status_update_gid' when calling getStatus");
      var i = {
        status_update_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/status_updates/{status_update_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a status update
     * Returns the complete record for a single status update.
     * @param {<&vendorExtensions.x-jsdoc-type>} status_update_gid The status update to get.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/StatusUpdateResponseData}
     */
  }, {
    key: "getStatus",
    value: function(e, A) {
      return this.getStatusWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get status updates from an object
     * Returns the compact status update records for all updates on the object.
     * @param {String} parent Globally unique identifier for object to fetch statuses from. Must be a GID for a project, portfolio, or goal.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Date} opts.created_since Only return statuses that have been created since the given time.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getStatusesForObjectWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'parent' when calling getStatusesForObject");
      var i = {}, a = {};
      A = A || {}, a = A, a.parent = e;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? Qw.fromApiClient(this.apiClient.callApi("/status_updates", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/status_updates",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/status_updates", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get status updates from an object
     * Returns the compact status update records for all updates on the object.
     * @param {<&vendorExtensions.x-jsdoc-type>} parent Globally unique identifier for object to fetch statuses from. Must be a GID for a project, portfolio, or goal.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Date} opts.created_since Only return statuses that have been created since the given time.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/StatusUpdateResponseArray}
     */
  }, {
    key: "getStatusesForObject",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getStatusesForObjectWithHttpInfo(e, A) : this.getStatusesForObjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var ea = {};
Object.defineProperty(ea, "__esModule", {
  value: !0
});
ea.StoriesApi = void 0;
var Bw = le;
function An(r) {
  "@babel/helpers - typeof";
  return An = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, An(r);
}
function Iw(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function dw(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, yw(A.key), A);
  }
}
function pw(r, t, e) {
  return t && dw(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function yw(r) {
  var t = mw(r, "string");
  return An(t) == "symbol" ? t : t + "";
}
function mw(r, t) {
  if (An(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (An(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var ww = de;
ea.StoriesApi = /* @__PURE__ */ function() {
  function r(t) {
    Iw(this, r), this.apiClient = t || Bw.ApiClient.instance;
  }
  return pw(r, [{
    key: "createStoryForTaskWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createStoryForTask");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling createStoryForTask");
      var a = {
        task_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}/stories", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Create a story on a task
     * Adds a story to a task. This endpoint currently only allows for comment stories to be created. The comment will be authored by the currently authenticated user, and timestamped when the server receives the request.  Returns the full record for the new story added to the task.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The story to create.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/StoryResponseData}
     */
  }, {
    key: "createStoryForTask",
    value: function(e, A, n) {
      return this.createStoryForTaskWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Delete a story
     * Deletes a story. A user can only delete stories they have created.  Returns an empty data record.
     * @param {String} story_gid Globally unique identifier for the story.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deleteStoryWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'story_gid' when calling deleteStory");
      var n = {
        story_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/stories/{story_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a story
     * Deletes a story. A user can only delete stories they have created.  Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} story_gid Globally unique identifier for the story.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteStory",
    value: function(e) {
      return this.deleteStoryWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get stories from a task
     * Returns the compact records for all stories on the task.
     * @param {String} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getStoriesForTaskWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'task_gid' when calling getStoriesForTask");
      var i = {
        task_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? ww.fromApiClient(this.apiClient.callApi("/tasks/{task_gid}/stories", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/tasks/{task_gid}/stories",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/tasks/{task_gid}/stories", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get stories from a task
     * Returns the compact records for all stories on the task.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/StoryResponseArray}
     */
  }, {
    key: "getStoriesForTask",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getStoriesForTaskWithHttpInfo(e, A) : this.getStoriesForTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get a story
     * Returns the full record for a single story.
     * @param {String} story_gid Globally unique identifier for the story.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getStoryWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'story_gid' when calling getStory");
      var i = {
        story_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/stories/{story_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a story
     * Returns the full record for a single story.
     * @param {<&vendorExtensions.x-jsdoc-type>} story_gid Globally unique identifier for the story.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/StoryResponseData}
     */
  }, {
    key: "getStory",
    value: function(e, A) {
      return this.getStoryWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Update a story
     * Updates the story and returns the full record for the updated story. Only comment stories can have their text updated, and only comment stories and attachment stories can be pinned. Only one of &#x60;text&#x60; and &#x60;html_text&#x60; can be specified.
     * @param {module:model/Object} body The comment story to update.
     * @param {String} story_gid Globally unique identifier for the story.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateStoryWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling updateStory");
      if (A == null)
        throw new Error("Missing the required parameter 'story_gid' when calling updateStory");
      var a = {
        story_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/stories/{story_gid}", "PUT", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Update a story
     * Updates the story and returns the full record for the updated story. Only comment stories can have their text updated, and only comment stories and attachment stories can be pinned. Only one of &#x60;text&#x60; and &#x60;html_text&#x60; can be specified.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The comment story to update.
     * @param {<&vendorExtensions.x-jsdoc-type>} story_gid Globally unique identifier for the story.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/StoryResponseData}
     */
  }, {
    key: "updateStory",
    value: function(e, A, n) {
      return this.updateStoryWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
  }]);
}();
var Aa = {};
Object.defineProperty(Aa, "__esModule", {
  value: !0
});
Aa.TagsApi = void 0;
var vw = le;
function tn(r) {
  "@babel/helpers - typeof";
  return tn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, tn(r);
}
function kw(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function bw(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Fw(A.key), A);
  }
}
function Tw(r, t, e) {
  return t && bw(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Fw(r) {
  var t = Rw(r, "string");
  return tn(t) == "symbol" ? t : t + "";
}
function Rw(r, t) {
  if (tn(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (tn(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var zo = de;
Aa.TagsApi = /* @__PURE__ */ function() {
  function r(t) {
    kw(this, r), this.apiClient = t || vw.ApiClient.instance;
  }
  return Tw(r, [{
    key: "createTagWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createTag");
      var i = {}, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/tags", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Create a tag
     * Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The tag to create.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TagResponseData}
     */
  }, {
    key: "createTag",
    value: function(e, A) {
      return this.createTagWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Create a tag in a workspace
     * Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.
     * @param {module:model/Object} body The tag to create.
     * @param {String} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "createTagForWorkspaceWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createTagForWorkspace");
      if (A == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling createTagForWorkspace");
      var a = {
        workspace_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/workspaces/{workspace_gid}/tags", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Create a tag in a workspace
     * Creates a new tag in a workspace or organization.  Every tag is required to be created in a specific workspace or organization, and this cannot be changed once set. Note that you can use the workspace parameter regardless of whether or not it is an organization.  Returns the full record of the newly created tag.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The tag to create.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TagResponseData}
     */
  }, {
    key: "createTagForWorkspace",
    value: function(e, A, n) {
      return this.createTagForWorkspaceWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Delete a tag
     * A specific, existing tag can be deleted by making a DELETE request on the URL for that tag.  Returns an empty data record.
     * @param {String} tag_gid Globally unique identifier for the tag.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deleteTagWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'tag_gid' when calling deleteTag");
      var n = {
        tag_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/tags/{tag_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a tag
     * A specific, existing tag can be deleted by making a DELETE request on the URL for that tag.  Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} tag_gid Globally unique identifier for the tag.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteTag",
    value: function(e) {
      return this.deleteTagWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get a tag
     * Returns the complete tag record for a single tag.
     * @param {String} tag_gid Globally unique identifier for the tag.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTagWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'tag_gid' when calling getTag");
      var i = {
        tag_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/tags/{tag_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a tag
     * Returns the complete tag record for a single tag.
     * @param {<&vendorExtensions.x-jsdoc-type>} tag_gid Globally unique identifier for the tag.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TagResponseData}
     */
  }, {
    key: "getTag",
    value: function(e, A) {
      return this.getTagWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get multiple tags
     * Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.workspace The workspace to filter tags on.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTagsWithHttpInfo",
    value: function(e) {
      e = e || {};
      var A = null, n = {}, i = {};
      e = e || {}, i = e;
      var a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.RETURN_COLLECTION ? zo.fromApiClient(this.apiClient.callApi("/tags", "GET", n, i, a, o, A, s, l, c, u), this.apiClient, {
        path: "/tags",
        httpMethod: "GET",
        pathParams: n,
        queryParams: i,
        headerParams: a,
        formParams: o,
        bodyParam: A,
        authNames: s,
        contentTypes: l,
        accepts: c,
        returnType: u
      }) : this.apiClient.callApi("/tags", "GET", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Get multiple tags
     * Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.workspace The workspace to filter tags on.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TagResponseArray}
     */
  }, {
    key: "getTags",
    value: function(e) {
      return this.apiClient.RETURN_COLLECTION ? this.getTagsWithHttpInfo(e) : this.getTagsWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get a task&#x27;s tags
     * Get a compact representation of all of the tags the task has.
     * @param {String} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTagsForTaskWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'task_gid' when calling getTagsForTask");
      var i = {
        task_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? zo.fromApiClient(this.apiClient.callApi("/tasks/{task_gid}/tags", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/tasks/{task_gid}/tags",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/tasks/{task_gid}/tags", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a task&#x27;s tags
     * Get a compact representation of all of the tags the task has.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TagResponseArray}
     */
  }, {
    key: "getTagsForTask",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getTagsForTaskWithHttpInfo(e, A) : this.getTagsForTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get tags in a workspace
     * Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
     * @param {String} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTagsForWorkspaceWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling getTagsForWorkspace");
      var i = {
        workspace_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? zo.fromApiClient(this.apiClient.callApi("/workspaces/{workspace_gid}/tags", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/workspaces/{workspace_gid}/tags",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/workspaces/{workspace_gid}/tags", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get tags in a workspace
     * Returns the compact tag records for some filtered set of tags. Use one or more of the parameters provided to filter the tags returned.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TagResponseArray}
     */
  }, {
    key: "getTagsForWorkspace",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getTagsForWorkspaceWithHttpInfo(e, A) : this.getTagsForWorkspaceWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Update a tag
     * Updates the properties of a tag. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the tag.  Returns the complete updated tag record.
     * @param {String} tag_gid Globally unique identifier for the tag.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateTagWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'tag_gid' when calling updateTag");
      var i = {
        tag_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/tags/{tag_gid}", "PUT", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Update a tag
     * Updates the properties of a tag. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the tag.  Returns the complete updated tag record.
     * @param {<&vendorExtensions.x-jsdoc-type>} tag_gid Globally unique identifier for the tag.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TagResponseData}
     */
  }, {
    key: "updateTag",
    value: function(e, A) {
      return this.updateTagWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var ta = {};
Object.defineProperty(ta, "__esModule", {
  value: !0
});
ta.TaskTemplatesApi = void 0;
var Dw = le;
function rn(r) {
  "@babel/helpers - typeof";
  return rn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, rn(r);
}
function Nw(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Sw(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Pw(A.key), A);
  }
}
function Uw(r, t, e) {
  return t && Sw(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Pw(r) {
  var t = Mw(r, "string");
  return rn(t) == "symbol" ? t : t + "";
}
function Mw(r, t) {
  if (rn(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (rn(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var Lw = de;
ta.TaskTemplatesApi = /* @__PURE__ */ function() {
  function r(t) {
    Nw(this, r), this.apiClient = t || Dw.ApiClient.instance;
  }
  return Uw(r, [{
    key: "deleteTaskTemplateWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'task_template_gid' when calling deleteTaskTemplate");
      var n = {
        task_template_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/task_templates/{task_template_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a task template
     * A specific, existing task template can be deleted by making a DELETE request on the URL for that task template. Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_template_gid Globally unique identifier for the task template.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteTaskTemplate",
    value: function(e) {
      return this.deleteTaskTemplateWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get a task template
     * Returns the complete task template record for a single task template.
     * @param {String} task_template_gid Globally unique identifier for the task template.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTaskTemplateWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'task_template_gid' when calling getTaskTemplate");
      var i = {
        task_template_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/task_templates/{task_template_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a task template
     * Returns the complete task template record for a single task template.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_template_gid Globally unique identifier for the task template.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskTemplateResponseData}
     */
  }, {
    key: "getTaskTemplate",
    value: function(e, A) {
      return this.getTaskTemplateWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get multiple task templates
     * Returns the compact task template records for some filtered set of task templates. You must specify a &#x60;project&#x60;
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.project The project to filter task templates on.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTaskTemplatesWithHttpInfo",
    value: function(e) {
      e = e || {};
      var A = null, n = {}, i = {};
      e = e || {}, i = e;
      var a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.RETURN_COLLECTION ? Lw.fromApiClient(this.apiClient.callApi("/task_templates", "GET", n, i, a, o, A, s, l, c, u), this.apiClient, {
        path: "/task_templates",
        httpMethod: "GET",
        pathParams: n,
        queryParams: i,
        headerParams: a,
        formParams: o,
        bodyParam: A,
        authNames: s,
        contentTypes: l,
        accepts: c,
        returnType: u
      }) : this.apiClient.callApi("/task_templates", "GET", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Get multiple task templates
     * Returns the compact task template records for some filtered set of task templates. You must specify a &#x60;project&#x60;
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.project The project to filter task templates on.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskTemplateResponseArray}
     */
  }, {
    key: "getTaskTemplates",
    value: function(e) {
      return this.apiClient.RETURN_COLLECTION ? this.getTaskTemplatesWithHttpInfo(e) : this.getTaskTemplatesWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Instantiate a task from a task template
     * Creates and returns a job that will asynchronously handle the task instantiation.
     * @param {String} task_template_gid Globally unique identifier for the task template.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body Describes the inputs used for instantiating a task - the task&#x27;s name.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "instantiateTaskWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = A.body;
      if (e == null)
        throw new Error("Missing the required parameter 'task_template_gid' when calling instantiateTask");
      var i = {
        task_template_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/task_templates/{task_template_gid}/instantiateTask", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Instantiate a task from a task template
     * Creates and returns a job that will asynchronously handle the task instantiation.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_template_gid Globally unique identifier for the task template.
     * @param {Object} opts Optional parameters
     * @param {module:model/Object} opts.body Describes the inputs used for instantiating a task - the task&#x27;s name.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/JobResponseData}
     */
  }, {
    key: "instantiateTask",
    value: function(e, A) {
      return this.instantiateTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var ra = {};
Object.defineProperty(ra, "__esModule", {
  value: !0
});
ra.TasksApi = void 0;
var Hw = le;
function nn(r) {
  "@babel/helpers - typeof";
  return nn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, nn(r);
}
function Gw(r, t) {
  return _w(r) || Jw(r, t) || Yw(r, t) || Ww();
}
function Ww() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function Yw(r, t) {
  if (r) {
    if (typeof r == "string")
      return fu(r, t);
    var e = Object.prototype.toString.call(r).slice(8, -1);
    if (e === "Object" && r.constructor && (e = r.constructor.name), e === "Map" || e === "Set")
      return Array.from(r);
    if (e === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e))
      return fu(r, t);
  }
}
function fu(r, t) {
  (t == null || t > r.length) && (t = r.length);
  for (var e = 0, A = new Array(t); e < t; e++)
    A[e] = r[e];
  return A;
}
function Jw(r, t) {
  var e = r == null ? null : typeof Symbol < "u" && r[Symbol.iterator] || r["@@iterator"];
  if (e != null) {
    var A, n, i, a, o = [], s = !0, l = !1;
    try {
      if (i = (e = e.call(r)).next, t !== 0)
        for (; !(s = (A = i.call(e)).done) && (o.push(A.value), o.length !== t); s = !0)
          ;
    } catch (c) {
      l = !0, n = c;
    } finally {
      try {
        if (!s && e.return != null && (a = e.return(), Object(a) !== a))
          return;
      } finally {
        if (l)
          throw n;
      }
    }
    return o;
  }
}
function _w(r) {
  if (Array.isArray(r))
    return r;
}
function xw(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ow(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, jw(A.key), A);
  }
}
function qw(r, t, e) {
  return t && Ow(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function jw(r) {
  var t = Vw(r, "string");
  return nn(t) == "symbol" ? t : t + "";
}
function Vw(r, t) {
  if (nn(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (nn(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var qA = de;
ra.TasksApi = /* @__PURE__ */ function() {
  function r(t) {
    xw(this, r), this.apiClient = t || Hw.ApiClient.instance;
  }
  return qw(r, [{
    key: "addDependenciesForTaskWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling addDependenciesForTask");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling addDependenciesForTask");
      var i = {
        task_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}/addDependencies", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Set dependencies for a task
     * Marks a set of tasks as dependencies of this task, if they are not already dependencies. *A task can have at most 30 dependents and dependencies combined*.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The list of tasks to set as dependencies.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "addDependenciesForTask",
    value: function(e, A) {
      return this.addDependenciesForTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Set dependents for a task
     * Marks a set of tasks as dependents of this task, if they are not already dependents. *A task can have at most 30 dependents and dependencies combined*.
     * @param {module:model/Object} body The list of tasks to add as dependents.
     * @param {String} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "addDependentsForTaskWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling addDependentsForTask");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling addDependentsForTask");
      var i = {
        task_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}/addDependents", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Set dependents for a task
     * Marks a set of tasks as dependents of this task, if they are not already dependents. *A task can have at most 30 dependents and dependencies combined*.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The list of tasks to add as dependents.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "addDependentsForTask",
    value: function(e, A) {
      return this.addDependentsForTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Add followers to a task
     * Adds followers to a task. Returns an empty data block. Each task can be associated with zero or more followers in the system. Requests to add/remove followers, if successful, will return the complete updated task record, described above.
     * @param {module:model/Object} body The followers to add to the task.
     * @param {String} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "addFollowersForTaskWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling addFollowersForTask");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling addFollowersForTask");
      var a = {
        task_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}/addFollowers", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Add followers to a task
     * Adds followers to a task. Returns an empty data block. Each task can be associated with zero or more followers in the system. Requests to add/remove followers, if successful, will return the complete updated task record, described above.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The followers to add to the task.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseData}
     */
  }, {
    key: "addFollowersForTask",
    value: function(e, A, n) {
      return this.addFollowersForTaskWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Add a project to a task
     * Adds the task to the specified project, in the optional location specified. If no location arguments are given, the task will be added to the end of the project.  &#x60;addProject&#x60; can also be used to reorder a task within a project or section that already contains it.  At most one of &#x60;insert_before&#x60;, &#x60;insert_after&#x60;, or &#x60;section&#x60; should be specified. Inserting into a section in an non-order-dependent way can be done by specifying section, otherwise, to insert within a section in a particular place, specify &#x60;insert_before&#x60; or &#x60;insert_after&#x60; and a task within the section to anchor the position of this task.  Returns an empty data block.
     * @param {module:model/Object} body The project to add the task to.
     * @param {String} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "addProjectForTaskWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling addProjectForTask");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling addProjectForTask");
      var i = {
        task_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}/addProject", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Add a project to a task
     * Adds the task to the specified project, in the optional location specified. If no location arguments are given, the task will be added to the end of the project.  &#x60;addProject&#x60; can also be used to reorder a task within a project or section that already contains it.  At most one of &#x60;insert_before&#x60;, &#x60;insert_after&#x60;, or &#x60;section&#x60; should be specified. Inserting into a section in an non-order-dependent way can be done by specifying section, otherwise, to insert within a section in a particular place, specify &#x60;insert_before&#x60; or &#x60;insert_after&#x60; and a task within the section to anchor the position of this task.  Returns an empty data block.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The project to add the task to.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "addProjectForTask",
    value: function(e, A) {
      return this.addProjectForTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Add a tag to a task
     * Adds a tag to a task. Returns an empty data block.
     * @param {module:model/Object} body The tag to add to the task.
     * @param {String} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "addTagForTaskWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling addTagForTask");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling addTagForTask");
      var i = {
        task_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}/addTag", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Add a tag to a task
     * Adds a tag to a task. Returns an empty data block.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The tag to add to the task.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "addTagForTask",
    value: function(e, A) {
      return this.addTagForTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Create a subtask
     * Creates a new subtask and adds it to the parent task. Returns the full record for the newly created subtask.
     * @param {module:model/Object} body The new subtask to create.
     * @param {String} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "createSubtaskForTaskWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createSubtaskForTask");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling createSubtaskForTask");
      var a = {
        task_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}/subtasks", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Create a subtask
     * Creates a new subtask and adds it to the parent task. Returns the full record for the newly created subtask.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The new subtask to create.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseData}
     */
  }, {
    key: "createSubtaskForTask",
    value: function(e, A, n) {
      return this.createSubtaskForTaskWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Create a task
     * Creating a new task is as easy as POSTing to the &#x60;/tasks&#x60; endpoint with a data block containing the fields youd like to set on the task. Any unspecified fields will take on default values.  Every task is required to be created in a specific workspace, and this workspace cannot be changed once set. The workspace need not be set explicitly if you specify &#x60;projects&#x60; or a &#x60;parent&#x60; task instead.
     * @param {module:model/Object} body The task to create.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "createTaskWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createTask");
      var i = {}, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/tasks", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Create a task
     * Creating a new task is as easy as POSTing to the &#x60;/tasks&#x60; endpoint with a data block containing the fields youd like to set on the task. Any unspecified fields will take on default values.  Every task is required to be created in a specific workspace, and this workspace cannot be changed once set. The workspace need not be set explicitly if you specify &#x60;projects&#x60; or a &#x60;parent&#x60; task instead.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The task to create.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseData}
     */
  }, {
    key: "createTask",
    value: function(e, A) {
      return this.createTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Delete a task
     * A specific, existing task can be deleted by making a DELETE request on the URL for that task. Deleted tasks go into the trash of the user making the delete request. Tasks can be recovered from the trash within a period of 30 days; afterward they are completely removed from the system.  Returns an empty data record.
     * @param {String} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deleteTaskWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'task_gid' when calling deleteTask");
      var n = {
        task_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a task
     * A specific, existing task can be deleted by making a DELETE request on the URL for that task. Deleted tasks go into the trash of the user making the delete request. Tasks can be recovered from the trash within a period of 30 days; afterward they are completely removed from the system.  Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteTask",
    value: function(e) {
      return this.deleteTaskWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Duplicate a task
     * Creates and returns a job that will asynchronously handle the duplication.
     * @param {module:model/Object} body Describes the duplicate&#x27;s name and the fields that will be duplicated.
     * @param {String} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "duplicateTaskWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling duplicateTask");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling duplicateTask");
      var a = {
        task_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}/duplicate", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Duplicate a task
     * Creates and returns a job that will asynchronously handle the duplication.
     * @param {<&vendorExtensions.x-jsdoc-type>} body Describes the duplicate&#x27;s name and the fields that will be duplicated.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/JobResponseData}
     */
  }, {
    key: "duplicateTask",
    value: function(e, A, n) {
      return this.duplicateTaskWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Get dependencies from a task
     * Returns the compact representations of all of the dependencies of a task.
     * @param {String} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getDependenciesForTaskWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'task_gid' when calling getDependenciesForTask");
      var i = {
        task_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? qA.fromApiClient(this.apiClient.callApi("/tasks/{task_gid}/dependencies", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/tasks/{task_gid}/dependencies",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/tasks/{task_gid}/dependencies", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get dependencies from a task
     * Returns the compact representations of all of the dependencies of a task.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseArray}
     */
  }, {
    key: "getDependenciesForTask",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getDependenciesForTaskWithHttpInfo(e, A) : this.getDependenciesForTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get dependents from a task
     * Returns the compact representations of all of the dependents of a task.
     * @param {String} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getDependentsForTaskWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'task_gid' when calling getDependentsForTask");
      var i = {
        task_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? qA.fromApiClient(this.apiClient.callApi("/tasks/{task_gid}/dependents", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/tasks/{task_gid}/dependents",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/tasks/{task_gid}/dependents", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get dependents from a task
     * Returns the compact representations of all of the dependents of a task.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseArray}
     */
  }, {
    key: "getDependentsForTask",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getDependentsForTaskWithHttpInfo(e, A) : this.getDependentsForTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get subtasks from a task
     * Returns a compact representation of all of the subtasks of a task.
     * @param {String} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getSubtasksForTaskWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'task_gid' when calling getSubtasksForTask");
      var i = {
        task_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? qA.fromApiClient(this.apiClient.callApi("/tasks/{task_gid}/subtasks", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/tasks/{task_gid}/subtasks",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/tasks/{task_gid}/subtasks", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get subtasks from a task
     * Returns a compact representation of all of the subtasks of a task.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseArray}
     */
  }, {
    key: "getSubtasksForTask",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getSubtasksForTaskWithHttpInfo(e, A) : this.getSubtasksForTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get a task
     * Returns the complete task record for a single task.
     * @param {String} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTaskWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'task_gid' when calling getTask");
      var i = {
        task_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a task
     * Returns the complete task record for a single task.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseData}
     */
  }, {
    key: "getTask",
    value: function(e, A) {
      return this.getTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get a task for a given custom ID
     * Returns a task given a custom ID shortcode.
     * @param {String} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {String} custom_id Generated custom ID for a task.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTaskForCustomIDWithHttpInfo",
    value: function(e, A) {
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling getTaskForCustomID");
      if (A == null)
        throw new Error("Missing the required parameter 'custom_id' when calling getTaskForCustomID");
      var i = {
        workspace_gid: e,
        custom_id: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/workspaces/{workspace_gid}/tasks/custom_id/{custom_id}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a task for a given custom ID
     * Returns a task given a custom ID shortcode.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {<&vendorExtensions.x-jsdoc-type>} custom_id Generated custom ID for a task.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseData}
     */
  }, {
    key: "getTaskForCustomID",
    value: function(e, A) {
      return this.getTaskForCustomIDWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get multiple tasks
     * Returns the compact task records for some filtered set of tasks. Use one or more of the parameters provided to filter the tasks returned. You must specify a &#x60;project&#x60; or &#x60;tag&#x60; if you do not specify &#x60;assignee&#x60; and &#x60;workspace&#x60;.  For more complex task retrieval, use [workspaces/{workspace_gid}/tasks/search](/reference/searchtasksforworkspace).
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.assignee The assignee to filter tasks on. If searching for unassigned tasks, assignee.any &#x3D; null can be specified. *Note: If you specify &#x60;assignee&#x60;, you must also specify the &#x60;workspace&#x60; to filter on.*
     * @param {String} opts.project The project to filter tasks on.
     * @param {String} opts.section The section to filter tasks on.
     * @param {String} opts.workspace The workspace to filter tasks on. *Note: If you specify &#x60;workspace&#x60;, you must also specify the &#x60;assignee&#x60; to filter on.*
     * @param {Date} opts.completed_since Only return tasks that are either incomplete or that have been completed since this time.
     * @param {Date} opts.modified_since Only return tasks that have been modified since the given time.  *Note: A task is considered modified if any of its properties change, or associations between it and other objects are modified (e.g.  a task being added to a project). A task is not considered modified just because another object it is associated with (e.g. a subtask) is modified. Actions that count as modifying the task include assigning, renaming, completing, and adding stories.*
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTasksWithHttpInfo",
    value: function(e) {
      e = e || {};
      var A = null, n = {}, i = {};
      e = e || {}, i = e;
      var a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.RETURN_COLLECTION ? qA.fromApiClient(this.apiClient.callApi("/tasks", "GET", n, i, a, o, A, s, l, c, u), this.apiClient, {
        path: "/tasks",
        httpMethod: "GET",
        pathParams: n,
        queryParams: i,
        headerParams: a,
        formParams: o,
        bodyParam: A,
        authNames: s,
        contentTypes: l,
        accepts: c,
        returnType: u
      }) : this.apiClient.callApi("/tasks", "GET", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Get multiple tasks
     * Returns the compact task records for some filtered set of tasks. Use one or more of the parameters provided to filter the tasks returned. You must specify a &#x60;project&#x60; or &#x60;tag&#x60; if you do not specify &#x60;assignee&#x60; and &#x60;workspace&#x60;.  For more complex task retrieval, use [workspaces/{workspace_gid}/tasks/search](/reference/searchtasksforworkspace).
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.assignee The assignee to filter tasks on. If searching for unassigned tasks, assignee.any &#x3D; null can be specified. *Note: If you specify &#x60;assignee&#x60;, you must also specify the &#x60;workspace&#x60; to filter on.*
     * @param {String} opts.project The project to filter tasks on.
     * @param {String} opts.section The section to filter tasks on.
     * @param {String} opts.workspace The workspace to filter tasks on. *Note: If you specify &#x60;workspace&#x60;, you must also specify the &#x60;assignee&#x60; to filter on.*
     * @param {Date} opts.completed_since Only return tasks that are either incomplete or that have been completed since this time.
     * @param {Date} opts.modified_since Only return tasks that have been modified since the given time.  *Note: A task is considered modified if any of its properties change, or associations between it and other objects are modified (e.g.  a task being added to a project). A task is not considered modified just because another object it is associated with (e.g. a subtask) is modified. Actions that count as modifying the task include assigning, renaming, completing, and adding stories.*
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseArray}
     */
  }, {
    key: "getTasks",
    value: function(e) {
      return this.apiClient.RETURN_COLLECTION ? this.getTasksWithHttpInfo(e) : this.getTasksWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get tasks from a project
     * Returns the compact task records for all tasks within the given project, ordered by their priority within the project. Tasks can exist in more than one project at a time.
     * @param {String} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {String} opts.completed_since Only return tasks that are either incomplete or that have been completed since this time. Accepts a date-time string or the keyword *now*. 
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTasksForProjectWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'project_gid' when calling getTasksForProject");
      var i = {
        project_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? qA.fromApiClient(this.apiClient.callApi("/projects/{project_gid}/tasks", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/projects/{project_gid}/tasks",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/projects/{project_gid}/tasks", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get tasks from a project
     * Returns the compact task records for all tasks within the given project, ordered by their priority within the project. Tasks can exist in more than one project at a time.
     * @param {<&vendorExtensions.x-jsdoc-type>} project_gid Globally unique identifier for the project.
     * @param {Object} opts Optional parameters
     * @param {String} opts.completed_since Only return tasks that are either incomplete or that have been completed since this time. Accepts a date-time string or the keyword *now*. 
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseArray}
     */
  }, {
    key: "getTasksForProject",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getTasksForProjectWithHttpInfo(e, A) : this.getTasksForProjectWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get tasks from a section
     * *Board view only*: Returns the compact section records for all tasks within the given section.
     * @param {String} section_gid The globally unique identifier for the section.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.completed_since Only return tasks that are either incomplete or that have been completed since this time. Accepts a date-time string or the keyword *now*. 
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTasksForSectionWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'section_gid' when calling getTasksForSection");
      var i = {
        section_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? qA.fromApiClient(this.apiClient.callApi("/sections/{section_gid}/tasks", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/sections/{section_gid}/tasks",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/sections/{section_gid}/tasks", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get tasks from a section
     * *Board view only*: Returns the compact section records for all tasks within the given section.
     * @param {<&vendorExtensions.x-jsdoc-type>} section_gid The globally unique identifier for the section.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.completed_since Only return tasks that are either incomplete or that have been completed since this time. Accepts a date-time string or the keyword *now*. 
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseArray}
     */
  }, {
    key: "getTasksForSection",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getTasksForSectionWithHttpInfo(e, A) : this.getTasksForSectionWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get tasks from a tag
     * Returns the compact task records for all tasks with the given tag. Tasks can have more than one tag at a time.
     * @param {String} tag_gid Globally unique identifier for the tag.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTasksForTagWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'tag_gid' when calling getTasksForTag");
      var i = {
        tag_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? qA.fromApiClient(this.apiClient.callApi("/tags/{tag_gid}/tasks", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/tags/{tag_gid}/tasks",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/tags/{tag_gid}/tasks", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get tasks from a tag
     * Returns the compact task records for all tasks with the given tag. Tasks can have more than one tag at a time.
     * @param {<&vendorExtensions.x-jsdoc-type>} tag_gid Globally unique identifier for the tag.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseArray}
     */
  }, {
    key: "getTasksForTag",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getTasksForTagWithHttpInfo(e, A) : this.getTasksForTagWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get tasks from a user task list
     * Returns the compact list of tasks in a users My Tasks list. *Note: Access control is enforced for this endpoint as with all Asana API endpoints, meaning a users private tasks will be filtered out if the API-authenticated user does not have access to them.* *Note: Both complete and incomplete tasks are returned by default unless they are filtered out (for example, setting &#x60;completed_since&#x3D;now&#x60; will return only incomplete tasks, which is the default view for My Tasks in Asana.)*
     * @param {String} user_task_list_gid Globally unique identifier for the user task list.
     * @param {Object} opts Optional parameters
     * @param {String} opts.completed_since Only return tasks that are either incomplete or that have been completed since this time. Accepts a date-time string or the keyword *now*. 
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTasksForUserTaskListWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'user_task_list_gid' when calling getTasksForUserTaskList");
      var i = {
        user_task_list_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? qA.fromApiClient(this.apiClient.callApi("/user_task_lists/{user_task_list_gid}/tasks", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/user_task_lists/{user_task_list_gid}/tasks",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/user_task_lists/{user_task_list_gid}/tasks", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get tasks from a user task list
     * Returns the compact list of tasks in a users My Tasks list. *Note: Access control is enforced for this endpoint as with all Asana API endpoints, meaning a users private tasks will be filtered out if the API-authenticated user does not have access to them.* *Note: Both complete and incomplete tasks are returned by default unless they are filtered out (for example, setting &#x60;completed_since&#x3D;now&#x60; will return only incomplete tasks, which is the default view for My Tasks in Asana.)*
     * @param {<&vendorExtensions.x-jsdoc-type>} user_task_list_gid Globally unique identifier for the user task list.
     * @param {Object} opts Optional parameters
     * @param {String} opts.completed_since Only return tasks that are either incomplete or that have been completed since this time. Accepts a date-time string or the keyword *now*. 
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseArray}
     */
  }, {
    key: "getTasksForUserTaskList",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getTasksForUserTaskListWithHttpInfo(e, A) : this.getTasksForUserTaskListWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Unlink dependencies from a task
     * Unlinks a set of dependencies from this task.
     * @param {module:model/Object} body The list of tasks to unlink as dependencies.
     * @param {String} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "removeDependenciesForTaskWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling removeDependenciesForTask");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling removeDependenciesForTask");
      var i = {
        task_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}/removeDependencies", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Unlink dependencies from a task
     * Unlinks a set of dependencies from this task.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The list of tasks to unlink as dependencies.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "removeDependenciesForTask",
    value: function(e, A) {
      return this.removeDependenciesForTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Unlink dependents from a task
     * Unlinks a set of dependents from this task.
     * @param {module:model/Object} body The list of tasks to remove as dependents.
     * @param {String} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "removeDependentsForTaskWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling removeDependentsForTask");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling removeDependentsForTask");
      var i = {
        task_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}/removeDependents", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Unlink dependents from a task
     * Unlinks a set of dependents from this task.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The list of tasks to remove as dependents.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "removeDependentsForTask",
    value: function(e, A) {
      return this.removeDependentsForTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Remove followers from a task
     * Removes each of the specified followers from the task if they are following. Returns the complete, updated record for the affected task.
     * @param {module:model/Object} body The followers to remove from the task.
     * @param {String} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "removeFollowerForTaskWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling removeFollowerForTask");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling removeFollowerForTask");
      var a = {
        task_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}/removeFollowers", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Remove followers from a task
     * Removes each of the specified followers from the task if they are following. Returns the complete, updated record for the affected task.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The followers to remove from the task.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseData}
     */
  }, {
    key: "removeFollowerForTask",
    value: function(e, A, n) {
      return this.removeFollowerForTaskWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Remove a project from a task
     * Removes the task from the specified project. The task will still exist in the system, but it will not be in the project anymore.  Returns an empty data block.
     * @param {module:model/Object} body The project to remove the task from.
     * @param {String} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "removeProjectForTaskWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling removeProjectForTask");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling removeProjectForTask");
      var i = {
        task_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}/removeProject", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Remove a project from a task
     * Removes the task from the specified project. The task will still exist in the system, but it will not be in the project anymore.  Returns an empty data block.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The project to remove the task from.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "removeProjectForTask",
    value: function(e, A) {
      return this.removeProjectForTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Remove a tag from a task
     * Removes a tag from a task. Returns an empty data block.
     * @param {module:model/Object} body The tag to remove from the task.
     * @param {String} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "removeTagForTaskWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling removeTagForTask");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling removeTagForTask");
      var i = {
        task_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}/removeTag", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Remove a tag from a task
     * Removes a tag from a task. Returns an empty data block.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The tag to remove from the task.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "removeTagForTask",
    value: function(e, A) {
      return this.removeTagForTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Search tasks in a workspace
     * To mirror the functionality of the Asana web app&#x27;s advanced search feature, the Asana API has a task search endpoint that allows you to build complex filters to find and retrieve the exact data you need. #### Premium access Like the Asana web product&#x27;s advance search feature, this search endpoint will only be available to premium Asana users. A user is premium if any of the following is true:  - The workspace in which the search is being performed is a premium workspace - The user is a member of a premium team inside the workspace  Even if a user is only a member of a premium team inside a non-premium workspace, search will allow them to find data anywhere in the workspace, not just inside the premium team. Making a search request using credentials of a non-premium user will result in a &#x60;402 Payment Required&#x60; error. #### Pagination Search results are not stable; repeating the same query multiple times may return the data in a different order, even if the data do not change. Because of this, the traditional [pagination](https://developers.asana.com/docs/#pagination) available elsewhere in the Asana API is not available here. However, you can paginate manually by sorting the search results by their creation time and then modifying each subsequent query to exclude data you have already seen. Page sizes are limited to a maximum of 100 items, and can be specified by the &#x60;limit&#x60; query parameter. #### Eventual consistency Changes in Asana (regardless of whether theyre made though the web product or the API) are forwarded to our search infrastructure to be indexed. This process can take between 10 and 60 seconds to complete under normal operation, and longer during some production incidents. Making a change to a task that would alter its presence in a particular search query will not be reflected immediately. This is also true of the advanced search feature in the web product. #### Rate limits You may receive a &#x60;429 Too Many Requests&#x60; response if you hit any of our [rate limits](https://developers.asana.com/docs/#rate-limits). #### Custom field parameters | Parameter name | Custom field type | Accepted type | |---|---|---| | custom_fields.{gid}.is_set | All | Boolean | | custom_fields.{gid}.value | Text | String | | custom_fields.{gid}.value | Number | Number | | custom_fields.{gid}.value | Enum | Enum option ID | | custom_fields.{gid}.starts_with | Text only | String | | custom_fields.{gid}.ends_with | Text only | String | | custom_fields.{gid}.contains | Text only | String | | custom_fields.{gid}.less_than | Number only | Number | | custom_fields.{gid}.greater_than | Number only | Number |   For example, if the gid of the custom field is 12345, these query parameter to find tasks where it is set would be &#x60;custom_fields.12345.is_set&#x3D;true&#x60;. To match an exact value for an enum custom field, use the gid of the desired enum option and not the name of the enum option: &#x60;custom_fields.12345.value&#x3D;67890&#x60;.  **Not Supported**: searching for multiple exact matches of a custom field, searching for multi-enum custom field  *Note: If you specify &#x60;projects.any&#x60; and &#x60;sections.any&#x60;, you will receive tasks for the project **and** tasks for the section. If you&#x27;re looking for only tasks in a section, omit the &#x60;projects.any&#x60; from the request.*
     * @param {String} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {String} opts.text Performs full-text search on both task name and description
     * @param {module:model/String} opts.resource_subtype Filters results by the task&#x27;s resource_subtype (default to <.>)
     * @param {String} opts.assignee.any Comma-separated list of user identifiers
     * @param {String} opts.assignee.not Comma-separated list of user identifiers
     * @param {String} opts.portfolios.any Comma-separated list of portfolio IDs
     * @param {String} opts.projects.any Comma-separated list of project IDs
     * @param {String} opts.projects.not Comma-separated list of project IDs
     * @param {String} opts.projects.all Comma-separated list of project IDs
     * @param {String} opts.sections.any Comma-separated list of section or column IDs
     * @param {String} opts.sections.not Comma-separated list of section or column IDs
     * @param {String} opts.sections.all Comma-separated list of section or column IDs
     * @param {String} opts.tags.any Comma-separated list of tag IDs
     * @param {String} opts.tags.not Comma-separated list of tag IDs
     * @param {String} opts.tags.all Comma-separated list of tag IDs
     * @param {String} opts.teams.any Comma-separated list of team IDs
     * @param {String} opts.followers.not Comma-separated list of user identifiers
     * @param {String} opts.created_by.any Comma-separated list of user identifiers
     * @param {String} opts.created_by.not Comma-separated list of user identifiers
     * @param {String} opts.assigned_by.any Comma-separated list of user identifiers
     * @param {String} opts.assigned_by.not Comma-separated list of user identifiers
     * @param {String} opts.liked_by.not Comma-separated list of user identifiers
     * @param {String} opts.commented_on_by.not Comma-separated list of user identifiers
     * @param {Date} opts.due_on.before ISO 8601 date string
     * @param {Date} opts.due_on.after ISO 8601 date string
     * @param {Date} opts.due_on ISO 8601 date string or &#x60;null&#x60;
     * @param {Date} opts.due_at.before ISO 8601 datetime string
     * @param {Date} opts.due_at.after ISO 8601 datetime string
     * @param {Date} opts.start_on.before ISO 8601 date string
     * @param {Date} opts.start_on.after ISO 8601 date string
     * @param {Date} opts.start_on ISO 8601 date string or &#x60;null&#x60;
     * @param {Date} opts.created_on.before ISO 8601 date string
     * @param {Date} opts.created_on.after ISO 8601 date string
     * @param {Date} opts.created_on ISO 8601 date string or &#x60;null&#x60;
     * @param {Date} opts.created_at.before ISO 8601 datetime string
     * @param {Date} opts.created_at.after ISO 8601 datetime string
     * @param {Date} opts.completed_on.before ISO 8601 date string
     * @param {Date} opts.completed_on.after ISO 8601 date string
     * @param {Date} opts.completed_on ISO 8601 date string or &#x60;null&#x60;
     * @param {Date} opts.completed_at.before ISO 8601 datetime string
     * @param {Date} opts.completed_at.after ISO 8601 datetime string
     * @param {Date} opts.modified_on.before ISO 8601 date string
     * @param {Date} opts.modified_on.after ISO 8601 date string
     * @param {Date} opts.modified_on ISO 8601 date string or &#x60;null&#x60;
     * @param {Date} opts.modified_at.before ISO 8601 datetime string
     * @param {Date} opts.modified_at.after ISO 8601 datetime string
     * @param {Boolean} opts.is_blocking Filter to incomplete tasks with dependents
     * @param {Boolean} opts.is_blocked Filter to tasks with incomplete dependencies
     * @param {Boolean} opts.has_attachment Filter to tasks with attachments
     * @param {Boolean} opts.completed Filter to completed tasks
     * @param {Boolean} opts.is_subtask Filter to subtasks
     * @param {module:model/String} opts.sort_by One of &#x60;due_date&#x60;, &#x60;created_at&#x60;, &#x60;completed_at&#x60;, &#x60;likes&#x60;, or &#x60;modified_at&#x60;, defaults to &#x60;modified_at&#x60; (default to <.>)
     * @param {Boolean} opts.sort_ascending Default &#x60;false&#x60; (default to <.>)
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "searchTasksForWorkspaceWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling searchTasksForWorkspace");
      var i = {
        workspace_gid: e
      }, a = {};
      A = A || {}, a = A;
      for (var o = 0, s = Object.entries(A); o < s.length; o++) {
        var l = Gw(s[o], 2), c = l[0], u = l[1], h = /custom_fields\.(.*?)\..*/, g = /custom_fields_(.*?)_.*/;
        if (h.test(c))
          a[c] = u;
        else if (g.test(c)) {
          var d = g.exec(c)[1], I = c.replace("custom_fields_".concat(d, "_"), "custom_fields.".concat(d, "."));
          a[I] = u;
        }
      }
      var y = {}, Q = {}, E = ["personalAccessToken"], B = [], w = ["application/json; charset=UTF-8"], C = "Blob";
      return this.apiClient.RETURN_COLLECTION ? qA.fromApiClient(this.apiClient.callApi("/workspaces/{workspace_gid}/tasks/search", "GET", i, a, y, Q, n, E, B, w, C), this.apiClient, {
        path: "/workspaces/{workspace_gid}/tasks/search",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: y,
        formParams: Q,
        bodyParam: n,
        authNames: E,
        contentTypes: B,
        accepts: w,
        returnType: C
      }) : this.apiClient.callApi("/workspaces/{workspace_gid}/tasks/search", "GET", i, a, y, Q, n, E, B, w, C);
    }
    /**
     * Search tasks in a workspace
     * To mirror the functionality of the Asana web app&#x27;s advanced search feature, the Asana API has a task search endpoint that allows you to build complex filters to find and retrieve the exact data you need. #### Premium access Like the Asana web product&#x27;s advance search feature, this search endpoint will only be available to premium Asana users. A user is premium if any of the following is true:  - The workspace in which the search is being performed is a premium workspace - The user is a member of a premium team inside the workspace  Even if a user is only a member of a premium team inside a non-premium workspace, search will allow them to find data anywhere in the workspace, not just inside the premium team. Making a search request using credentials of a non-premium user will result in a &#x60;402 Payment Required&#x60; error. #### Pagination Search results are not stable; repeating the same query multiple times may return the data in a different order, even if the data do not change. Because of this, the traditional [pagination](https://developers.asana.com/docs/#pagination) available elsewhere in the Asana API is not available here. However, you can paginate manually by sorting the search results by their creation time and then modifying each subsequent query to exclude data you have already seen. Page sizes are limited to a maximum of 100 items, and can be specified by the &#x60;limit&#x60; query parameter. #### Eventual consistency Changes in Asana (regardless of whether theyre made though the web product or the API) are forwarded to our search infrastructure to be indexed. This process can take between 10 and 60 seconds to complete under normal operation, and longer during some production incidents. Making a change to a task that would alter its presence in a particular search query will not be reflected immediately. This is also true of the advanced search feature in the web product. #### Rate limits You may receive a &#x60;429 Too Many Requests&#x60; response if you hit any of our [rate limits](https://developers.asana.com/docs/#rate-limits). #### Custom field parameters | Parameter name | Custom field type | Accepted type | |---|---|---| | custom_fields.{gid}.is_set | All | Boolean | | custom_fields.{gid}.value | Text | String | | custom_fields.{gid}.value | Number | Number | | custom_fields.{gid}.value | Enum | Enum option ID | | custom_fields.{gid}.starts_with | Text only | String | | custom_fields.{gid}.ends_with | Text only | String | | custom_fields.{gid}.contains | Text only | String | | custom_fields.{gid}.less_than | Number only | Number | | custom_fields.{gid}.greater_than | Number only | Number |   For example, if the gid of the custom field is 12345, these query parameter to find tasks where it is set would be &#x60;custom_fields.12345.is_set&#x3D;true&#x60;. To match an exact value for an enum custom field, use the gid of the desired enum option and not the name of the enum option: &#x60;custom_fields.12345.value&#x3D;67890&#x60;.  **Not Supported**: searching for multiple exact matches of a custom field, searching for multi-enum custom field  *Note: If you specify &#x60;projects.any&#x60; and &#x60;sections.any&#x60;, you will receive tasks for the project **and** tasks for the section. If you&#x27;re looking for only tasks in a section, omit the &#x60;projects.any&#x60; from the request.*
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {String} opts.text Performs full-text search on both task name and description
     * @param {module:model/String} opts.resource_subtype Filters results by the task&#x27;s resource_subtype (default to <.>)
     * @param {String} opts.assignee.any Comma-separated list of user identifiers
     * @param {String} opts.assignee.not Comma-separated list of user identifiers
     * @param {String} opts.portfolios.any Comma-separated list of portfolio IDs
     * @param {String} opts.projects.any Comma-separated list of project IDs
     * @param {String} opts.projects.not Comma-separated list of project IDs
     * @param {String} opts.projects.all Comma-separated list of project IDs
     * @param {String} opts.sections.any Comma-separated list of section or column IDs
     * @param {String} opts.sections.not Comma-separated list of section or column IDs
     * @param {String} opts.sections.all Comma-separated list of section or column IDs
     * @param {String} opts.tags.any Comma-separated list of tag IDs
     * @param {String} opts.tags.not Comma-separated list of tag IDs
     * @param {String} opts.tags.all Comma-separated list of tag IDs
     * @param {String} opts.teams.any Comma-separated list of team IDs
     * @param {String} opts.followers.not Comma-separated list of user identifiers
     * @param {String} opts.created_by.any Comma-separated list of user identifiers
     * @param {String} opts.created_by.not Comma-separated list of user identifiers
     * @param {String} opts.assigned_by.any Comma-separated list of user identifiers
     * @param {String} opts.assigned_by.not Comma-separated list of user identifiers
     * @param {String} opts.liked_by.not Comma-separated list of user identifiers
     * @param {String} opts.commented_on_by.not Comma-separated list of user identifiers
     * @param {Date} opts.due_on.before ISO 8601 date string
     * @param {Date} opts.due_on.after ISO 8601 date string
     * @param {Date} opts.due_on ISO 8601 date string or &#x60;null&#x60;
     * @param {Date} opts.due_at.before ISO 8601 datetime string
     * @param {Date} opts.due_at.after ISO 8601 datetime string
     * @param {Date} opts.start_on.before ISO 8601 date string
     * @param {Date} opts.start_on.after ISO 8601 date string
     * @param {Date} opts.start_on ISO 8601 date string or &#x60;null&#x60;
     * @param {Date} opts.created_on.before ISO 8601 date string
     * @param {Date} opts.created_on.after ISO 8601 date string
     * @param {Date} opts.created_on ISO 8601 date string or &#x60;null&#x60;
     * @param {Date} opts.created_at.before ISO 8601 datetime string
     * @param {Date} opts.created_at.after ISO 8601 datetime string
     * @param {Date} opts.completed_on.before ISO 8601 date string
     * @param {Date} opts.completed_on.after ISO 8601 date string
     * @param {Date} opts.completed_on ISO 8601 date string or &#x60;null&#x60;
     * @param {Date} opts.completed_at.before ISO 8601 datetime string
     * @param {Date} opts.completed_at.after ISO 8601 datetime string
     * @param {Date} opts.modified_on.before ISO 8601 date string
     * @param {Date} opts.modified_on.after ISO 8601 date string
     * @param {Date} opts.modified_on ISO 8601 date string or &#x60;null&#x60;
     * @param {Date} opts.modified_at.before ISO 8601 datetime string
     * @param {Date} opts.modified_at.after ISO 8601 datetime string
     * @param {Boolean} opts.is_blocking Filter to incomplete tasks with dependents
     * @param {Boolean} opts.is_blocked Filter to tasks with incomplete dependencies
     * @param {Boolean} opts.has_attachment Filter to tasks with attachments
     * @param {Boolean} opts.completed Filter to completed tasks
     * @param {Boolean} opts.is_subtask Filter to subtasks
     * @param {module:model/String} opts.sort_by One of &#x60;due_date&#x60;, &#x60;created_at&#x60;, &#x60;completed_at&#x60;, &#x60;likes&#x60;, or &#x60;modified_at&#x60;, defaults to &#x60;modified_at&#x60; (default to <.>)
     * @param {Boolean} opts.sort_ascending Default &#x60;false&#x60; (default to <.>)
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseArray}
     */
  }, {
    key: "searchTasksForWorkspace",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.searchTasksForWorkspaceWithHttpInfo(e, A) : this.searchTasksForWorkspaceWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Set the parent of a task
     * parent, or no parent task at all. Returns an empty data block. When using &#x60;insert_before&#x60; and &#x60;insert_after&#x60;, at most one of those two options can be specified, and they must already be subtasks of the parent.
     * @param {module:model/Object} body The new parent of the subtask.
     * @param {String} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "setParentForTaskWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling setParentForTask");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling setParentForTask");
      var a = {
        task_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}/setParent", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Set the parent of a task
     * parent, or no parent task at all. Returns an empty data block. When using &#x60;insert_before&#x60; and &#x60;insert_after&#x60;, at most one of those two options can be specified, and they must already be subtasks of the parent.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The new parent of the subtask.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseData}
     */
  }, {
    key: "setParentForTask",
    value: function(e, A, n) {
      return this.setParentForTaskWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Update a task
     * A specific, existing task can be updated by making a PUT request on the URL for that task. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated task record.
     * @param {module:model/Object} body The task to update.
     * @param {String} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateTaskWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling updateTask");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling updateTask");
      var a = {
        task_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}", "PUT", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Update a task
     * A specific, existing task can be updated by making a PUT request on the URL for that task. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated task record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The task to update.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TaskResponseData}
     */
  }, {
    key: "updateTask",
    value: function(e, A, n) {
      return this.updateTaskWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
  }]);
}();
var na = {};
Object.defineProperty(na, "__esModule", {
  value: !0
});
na.TeamMembershipsApi = void 0;
var $w = le;
function an(r) {
  "@babel/helpers - typeof";
  return an = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, an(r);
}
function Xw(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Zw(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, zw(A.key), A);
  }
}
function Kw(r, t, e) {
  return t && Zw(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function zw(r) {
  var t = ev(r, "string");
  return an(t) == "symbol" ? t : t + "";
}
function ev(r, t) {
  if (an(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (an(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var es = de;
na.TeamMembershipsApi = /* @__PURE__ */ function() {
  function r(t) {
    Xw(this, r), this.apiClient = t || $w.ApiClient.instance;
  }
  return Kw(r, [{
    key: "getTeamMembershipWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'team_membership_gid' when calling getTeamMembership");
      var i = {
        team_membership_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/team_memberships/{team_membership_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a team membership
     * Returns the complete team membership record for a single team membership.
     * @param {<&vendorExtensions.x-jsdoc-type>} team_membership_gid 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TeamMembershipResponseData}
     */
  }, {
    key: "getTeamMembership",
    value: function(e, A) {
      return this.getTeamMembershipWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get team memberships
     * Returns compact team membership records.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.team Globally unique identifier for the team.
     * @param {String} opts.user A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user. This parameter must be used with the workspace parameter.
     * @param {String} opts.workspace Globally unique identifier for the workspace. This parameter must be used with the user parameter.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTeamMembershipsWithHttpInfo",
    value: function(e) {
      e = e || {};
      var A = null, n = {}, i = {};
      e = e || {}, i = e;
      var a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.RETURN_COLLECTION ? es.fromApiClient(this.apiClient.callApi("/team_memberships", "GET", n, i, a, o, A, s, l, c, u), this.apiClient, {
        path: "/team_memberships",
        httpMethod: "GET",
        pathParams: n,
        queryParams: i,
        headerParams: a,
        formParams: o,
        bodyParam: A,
        authNames: s,
        contentTypes: l,
        accepts: c,
        returnType: u
      }) : this.apiClient.callApi("/team_memberships", "GET", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Get team memberships
     * Returns compact team membership records.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.team Globally unique identifier for the team.
     * @param {String} opts.user A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user. This parameter must be used with the workspace parameter.
     * @param {String} opts.workspace Globally unique identifier for the workspace. This parameter must be used with the user parameter.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TeamMembershipResponseArray}
     */
  }, {
    key: "getTeamMemberships",
    value: function(e) {
      return this.apiClient.RETURN_COLLECTION ? this.getTeamMembershipsWithHttpInfo(e) : this.getTeamMembershipsWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get memberships from a team
     * Returns the compact team memberships for the team.
     * @param {String} team_gid Globally unique identifier for the team.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTeamMembershipsForTeamWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'team_gid' when calling getTeamMembershipsForTeam");
      var i = {
        team_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? es.fromApiClient(this.apiClient.callApi("/teams/{team_gid}/team_memberships", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/teams/{team_gid}/team_memberships",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/teams/{team_gid}/team_memberships", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get memberships from a team
     * Returns the compact team memberships for the team.
     * @param {<&vendorExtensions.x-jsdoc-type>} team_gid Globally unique identifier for the team.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TeamMembershipResponseArray}
     */
  }, {
    key: "getTeamMembershipsForTeam",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getTeamMembershipsForTeamWithHttpInfo(e, A) : this.getTeamMembershipsForTeamWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get memberships from a user
     * Returns the compact team membership records for the user.
     * @param {String} user_gid A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {String} workspace Globally unique identifier for the workspace.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTeamMembershipsForUserWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = null;
      if (e == null)
        throw new Error("Missing the required parameter 'user_gid' when calling getTeamMembershipsForUser");
      if (A == null)
        throw new Error("Missing the required parameter 'workspace' when calling getTeamMembershipsForUser");
      var a = {
        user_gid: e
      }, o = {};
      n = n || {}, o = n, o.workspace = A;
      var s = {}, l = {}, c = ["personalAccessToken"], u = [], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.RETURN_COLLECTION ? es.fromApiClient(this.apiClient.callApi("/users/{user_gid}/team_memberships", "GET", a, o, s, l, i, c, u, h, g), this.apiClient, {
        path: "/users/{user_gid}/team_memberships",
        httpMethod: "GET",
        pathParams: a,
        queryParams: o,
        headerParams: s,
        formParams: l,
        bodyParam: i,
        authNames: c,
        contentTypes: u,
        accepts: h,
        returnType: g
      }) : this.apiClient.callApi("/users/{user_gid}/team_memberships", "GET", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Get memberships from a user
     * Returns the compact team membership records for the user.
     * @param {<&vendorExtensions.x-jsdoc-type>} user_gid A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace Globally unique identifier for the workspace.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TeamMembershipResponseArray}
     */
  }, {
    key: "getTeamMembershipsForUser",
    value: function(e, A, n) {
      return this.apiClient.RETURN_COLLECTION ? this.getTeamMembershipsForUserWithHttpInfo(e, A, n) : this.getTeamMembershipsForUserWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
  }]);
}();
var ia = {};
Object.defineProperty(ia, "__esModule", {
  value: !0
});
ia.TeamsApi = void 0;
var Av = le;
function on(r) {
  "@babel/helpers - typeof";
  return on = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, on(r);
}
function tv(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function rv(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, iv(A.key), A);
  }
}
function nv(r, t, e) {
  return t && rv(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function iv(r) {
  var t = av(r, "string");
  return on(t) == "symbol" ? t : t + "";
}
function av(r, t) {
  if (on(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (on(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var Qu = de;
ia.TeamsApi = /* @__PURE__ */ function() {
  function r(t) {
    tv(this, r), this.apiClient = t || Av.ApiClient.instance;
  }
  return nv(r, [{
    key: "addUserForTeamWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling addUserForTeam");
      if (A == null)
        throw new Error("Missing the required parameter 'team_gid' when calling addUserForTeam");
      var a = {
        team_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/teams/{team_gid}/addUser", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Add a user to a team
     * The user making this call must be a member of the team in order to add others. The user being added must exist in the same organization as the team.  Returns the complete team membership record for the newly added user.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The user to add to the team.
     * @param {<&vendorExtensions.x-jsdoc-type>} team_gid Globally unique identifier for the team.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TeamMembershipResponseData}
     */
  }, {
    key: "addUserForTeam",
    value: function(e, A, n) {
      return this.addUserForTeamWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Create a team
     * Creates a team within the current workspace.
     * @param {module:model/Object} body The team to create.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "createTeamWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createTeam");
      var i = {}, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/teams", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Create a team
     * Creates a team within the current workspace.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The team to create.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TeamResponseData}
     */
  }, {
    key: "createTeam",
    value: function(e, A) {
      return this.createTeamWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get a team
     * Returns the full record for a single team.
     * @param {String} team_gid Globally unique identifier for the team.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTeamWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'team_gid' when calling getTeam");
      var i = {
        team_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/teams/{team_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a team
     * Returns the full record for a single team.
     * @param {<&vendorExtensions.x-jsdoc-type>} team_gid Globally unique identifier for the team.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TeamResponseData}
     */
  }, {
    key: "getTeam",
    value: function(e, A) {
      return this.getTeamWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get teams for a user
     * Returns the compact records for all teams to which the given user is assigned.
     * @param {String} user_gid A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {String} organization The workspace or organization to filter teams on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTeamsForUserWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = null;
      if (e == null)
        throw new Error("Missing the required parameter 'user_gid' when calling getTeamsForUser");
      if (A == null)
        throw new Error("Missing the required parameter 'organization' when calling getTeamsForUser");
      var a = {
        user_gid: e
      }, o = {};
      n = n || {}, o = n, o.organization = A;
      var s = {}, l = {}, c = ["personalAccessToken"], u = [], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.RETURN_COLLECTION ? Qu.fromApiClient(this.apiClient.callApi("/users/{user_gid}/teams", "GET", a, o, s, l, i, c, u, h, g), this.apiClient, {
        path: "/users/{user_gid}/teams",
        httpMethod: "GET",
        pathParams: a,
        queryParams: o,
        headerParams: s,
        formParams: l,
        bodyParam: i,
        authNames: c,
        contentTypes: u,
        accepts: h,
        returnType: g
      }) : this.apiClient.callApi("/users/{user_gid}/teams", "GET", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Get teams for a user
     * Returns the compact records for all teams to which the given user is assigned.
     * @param {<&vendorExtensions.x-jsdoc-type>} user_gid A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {<&vendorExtensions.x-jsdoc-type>} organization The workspace or organization to filter teams on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TeamResponseArray}
     */
  }, {
    key: "getTeamsForUser",
    value: function(e, A, n) {
      return this.apiClient.RETURN_COLLECTION ? this.getTeamsForUserWithHttpInfo(e, A, n) : this.getTeamsForUserWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Get teams in a workspace
     * Returns the compact records for all teams in the workspace visible to the authorized user.
     * @param {String} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTeamsForWorkspaceWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling getTeamsForWorkspace");
      var i = {
        workspace_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? Qu.fromApiClient(this.apiClient.callApi("/workspaces/{workspace_gid}/teams", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/workspaces/{workspace_gid}/teams",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/workspaces/{workspace_gid}/teams", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get teams in a workspace
     * Returns the compact records for all teams in the workspace visible to the authorized user.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TeamResponseArray}
     */
  }, {
    key: "getTeamsForWorkspace",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getTeamsForWorkspaceWithHttpInfo(e, A) : this.getTeamsForWorkspaceWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Remove a user from a team
     * The user making this call must be a member of the team in order to remove themselves or others.
     * @param {module:model/Object} body The user to remove from the team.
     * @param {String} team_gid Globally unique identifier for the team.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "removeUserForTeamWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling removeUserForTeam");
      if (A == null)
        throw new Error("Missing the required parameter 'team_gid' when calling removeUserForTeam");
      var i = {
        team_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/teams/{team_gid}/removeUser", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Remove a user from a team
     * The user making this call must be a member of the team in order to remove themselves or others.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The user to remove from the team.
     * @param {<&vendorExtensions.x-jsdoc-type>} team_gid Globally unique identifier for the team.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "removeUserForTeam",
    value: function(e, A) {
      return this.removeUserForTeamWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Update a team
     * Updates a team within the current workspace.
     * @param {module:model/Object} body The team to update.
     * @param {String} team_gid Globally unique identifier for the team.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateTeamWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling updateTeam");
      if (A == null)
        throw new Error("Missing the required parameter 'team_gid' when calling updateTeam");
      var a = {
        team_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/teams/{team_gid}", "PUT", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Update a team
     * Updates a team within the current workspace.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The team to update.
     * @param {<&vendorExtensions.x-jsdoc-type>} team_gid Globally unique identifier for the team.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TeamResponseData}
     */
  }, {
    key: "updateTeam",
    value: function(e, A, n) {
      return this.updateTeamWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
  }]);
}();
var aa = {};
Object.defineProperty(aa, "__esModule", {
  value: !0
});
aa.TimePeriodsApi = void 0;
var ov = le;
function sn(r) {
  "@babel/helpers - typeof";
  return sn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, sn(r);
}
function sv(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function cv(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, uv(A.key), A);
  }
}
function lv(r, t, e) {
  return t && cv(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function uv(r) {
  var t = hv(r, "string");
  return sn(t) == "symbol" ? t : t + "";
}
function hv(r, t) {
  if (sn(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (sn(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var gv = de;
aa.TimePeriodsApi = /* @__PURE__ */ function() {
  function r(t) {
    sv(this, r), this.apiClient = t || ov.ApiClient.instance;
  }
  return lv(r, [{
    key: "getTimePeriodWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'time_period_gid' when calling getTimePeriod");
      var i = {
        time_period_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/time_periods/{time_period_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a time period
     * Returns the full record for a single time period.
     * @param {<&vendorExtensions.x-jsdoc-type>} time_period_gid Globally unique identifier for the time period.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TimePeriodResponseData}
     */
  }, {
    key: "getTimePeriod",
    value: function(e, A) {
      return this.getTimePeriodWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get time periods
     * Returns compact time period records.
     * @param {String} workspace Globally unique identifier for the workspace.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Date} opts.start_on ISO 8601 date string
     * @param {Date} opts.end_on ISO 8601 date string
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTimePeriodsWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'workspace' when calling getTimePeriods");
      var i = {}, a = {};
      A = A || {}, a = A, a.workspace = e;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? gv.fromApiClient(this.apiClient.callApi("/time_periods", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/time_periods",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/time_periods", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get time periods
     * Returns compact time period records.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace Globally unique identifier for the workspace.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Date} opts.start_on ISO 8601 date string
     * @param {Date} opts.end_on ISO 8601 date string
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TimePeriodResponseArray}
     */
  }, {
    key: "getTimePeriods",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getTimePeriodsWithHttpInfo(e, A) : this.getTimePeriodsWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var oa = {};
Object.defineProperty(oa, "__esModule", {
  value: !0
});
oa.TimeTrackingEntriesApi = void 0;
var Ev = le;
function cn(r) {
  "@babel/helpers - typeof";
  return cn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, cn(r);
}
function Cv(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function fv(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Bv(A.key), A);
  }
}
function Qv(r, t, e) {
  return t && fv(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Bv(r) {
  var t = Iv(r, "string");
  return cn(t) == "symbol" ? t : t + "";
}
function Iv(r, t) {
  if (cn(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (cn(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var dv = de;
oa.TimeTrackingEntriesApi = /* @__PURE__ */ function() {
  function r(t) {
    Cv(this, r), this.apiClient = t || Ev.ApiClient.instance;
  }
  return Qv(r, [{
    key: "createTimeTrackingEntryWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createTimeTrackingEntry");
      if (A == null)
        throw new Error("Missing the required parameter 'task_gid' when calling createTimeTrackingEntry");
      var a = {
        task_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/tasks/{task_gid}/time_tracking_entries", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Create a time tracking entry
     * Creates a time tracking entry on a given task.  Returns the record of the newly created time tracking entry.
     * @param {<&vendorExtensions.x-jsdoc-type>} body Information about the time tracking entry.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TimeTrackingEntryBaseData}
     */
  }, {
    key: "createTimeTrackingEntry",
    value: function(e, A, n) {
      return this.createTimeTrackingEntryWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Delete a time tracking entry
     * A specific, existing time tracking entry can be deleted by making a &#x60;DELETE&#x60; request on the URL for that time tracking entry.  Returns an empty data record.
     * @param {String} time_tracking_entry_gid Globally unique identifier for the time tracking entry.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deleteTimeTrackingEntryWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'time_tracking_entry_gid' when calling deleteTimeTrackingEntry");
      var n = {
        time_tracking_entry_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/time_tracking_entries/{time_tracking_entry_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a time tracking entry
     * A specific, existing time tracking entry can be deleted by making a &#x60;DELETE&#x60; request on the URL for that time tracking entry.  Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} time_tracking_entry_gid Globally unique identifier for the time tracking entry.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteTimeTrackingEntry",
    value: function(e) {
      return this.deleteTimeTrackingEntryWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get time tracking entries for a task
     * Returns time tracking entries for a given task.
     * @param {String} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTimeTrackingEntriesForTaskWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'task_gid' when calling getTimeTrackingEntriesForTask");
      var i = {
        task_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? dv.fromApiClient(this.apiClient.callApi("/tasks/{task_gid}/time_tracking_entries", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/tasks/{task_gid}/time_tracking_entries",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/tasks/{task_gid}/time_tracking_entries", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get time tracking entries for a task
     * Returns time tracking entries for a given task.
     * @param {<&vendorExtensions.x-jsdoc-type>} task_gid The task to operate on.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TimeTrackingEntryCompactArray}
     */
  }, {
    key: "getTimeTrackingEntriesForTask",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getTimeTrackingEntriesForTaskWithHttpInfo(e, A) : this.getTimeTrackingEntriesForTaskWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get a time tracking entry
     * Returns the complete time tracking entry record for a single time tracking entry.
     * @param {String} time_tracking_entry_gid Globally unique identifier for the time tracking entry.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getTimeTrackingEntryWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'time_tracking_entry_gid' when calling getTimeTrackingEntry");
      var i = {
        time_tracking_entry_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/time_tracking_entries/{time_tracking_entry_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a time tracking entry
     * Returns the complete time tracking entry record for a single time tracking entry.
     * @param {<&vendorExtensions.x-jsdoc-type>} time_tracking_entry_gid Globally unique identifier for the time tracking entry.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TimeTrackingEntryBaseData}
     */
  }, {
    key: "getTimeTrackingEntry",
    value: function(e, A) {
      return this.getTimeTrackingEntryWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Update a time tracking entry
     * A specific, existing time tracking entry can be updated by making a &#x60;PUT&#x60; request on the URL for that time tracking entry. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated time tracking entry record.
     * @param {module:model/Object} body The updated fields for the time tracking entry.
     * @param {String} time_tracking_entry_gid Globally unique identifier for the time tracking entry.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateTimeTrackingEntryWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling updateTimeTrackingEntry");
      if (A == null)
        throw new Error("Missing the required parameter 'time_tracking_entry_gid' when calling updateTimeTrackingEntry");
      var a = {
        time_tracking_entry_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/time_tracking_entries/{time_tracking_entry_gid}", "PUT", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Update a time tracking entry
     * A specific, existing time tracking entry can be updated by making a &#x60;PUT&#x60; request on the URL for that time tracking entry. Only the fields provided in the &#x60;data&#x60; block will be updated; any unspecified fields will remain unchanged.  When using this method, it is best to specify only those fields you wish to change, or else you may overwrite changes made by another user since you last retrieved the task.  Returns the complete updated time tracking entry record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The updated fields for the time tracking entry.
     * @param {<&vendorExtensions.x-jsdoc-type>} time_tracking_entry_gid Globally unique identifier for the time tracking entry.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/TimeTrackingEntryBaseData}
     */
  }, {
    key: "updateTimeTrackingEntry",
    value: function(e, A, n) {
      return this.updateTimeTrackingEntryWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
  }]);
}();
var sa = {};
Object.defineProperty(sa, "__esModule", {
  value: !0
});
sa.TypeaheadApi = void 0;
var pv = le;
function ln(r) {
  "@babel/helpers - typeof";
  return ln = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ln(r);
}
function yv(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function mv(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, vv(A.key), A);
  }
}
function wv(r, t, e) {
  return t && mv(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function vv(r) {
  var t = kv(r, "string");
  return ln(t) == "symbol" ? t : t + "";
}
function kv(r, t) {
  if (ln(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (ln(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var bv = de;
sa.TypeaheadApi = /* @__PURE__ */ function() {
  function r(t) {
    yv(this, r), this.apiClient = t || pv.ApiClient.instance;
  }
  return wv(r, [{
    key: "typeaheadForWorkspaceWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = null;
      if (e == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling typeaheadForWorkspace");
      if (A == null)
        throw new Error("Missing the required parameter 'resource_type' when calling typeaheadForWorkspace");
      var a = {
        workspace_gid: e
      }, o = {};
      n = n || {}, o = n, o.resource_type = A;
      var s = {}, l = {}, c = ["personalAccessToken"], u = [], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.RETURN_COLLECTION ? bv.fromApiClient(this.apiClient.callApi("/workspaces/{workspace_gid}/typeahead", "GET", a, o, s, l, i, c, u, h, g), this.apiClient, {
        path: "/workspaces/{workspace_gid}/typeahead",
        httpMethod: "GET",
        pathParams: a,
        queryParams: o,
        headerParams: s,
        formParams: l,
        bodyParam: i,
        authNames: c,
        contentTypes: u,
        accepts: h,
        returnType: g
      }) : this.apiClient.callApi("/workspaces/{workspace_gid}/typeahead", "GET", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Get objects via typeahead
     * Retrieves objects in the workspace based via an auto-completion/typeahead search algorithm. This feature is meant to provide results quickly, so do not rely on this API to provide extremely accurate search results. The result set is limited to a single page of results with a maximum size, so you wont be able to fetch large numbers of results.  The typeahead search API provides search for objects from a single workspace. This endpoint should be used to query for objects when creating an auto-completion/typeahead search feature. This API is meant to provide results quickly and should not be relied upon for accurate or exhaustive search results. The results sets are limited in size and cannot be paginated.  Queries return a compact representation of each object which is typically the gid and name fields. Interested in a specific set of fields or all of the fields?! Of course you are. Use field selectors to manipulate what data is included in a response.  Resources with type &#x60;user&#x60; are returned in order of most contacted to least contacted. This is determined by task assignments, adding the user to projects, and adding the user as a follower to tasks, messages, etc.  Resources with type &#x60;project&#x60; are returned in order of recency. This is determined when the user visits the project, is added to the project, and completes tasks in the project.  Resources with type &#x60;task&#x60; are returned with priority placed on tasks the user is following, but no guarantee on the order of those tasks.  Resources with type &#x60;project_template&#x60; are returned with priority placed on favorited project templates.  Leaving the &#x60;query&#x60; string empty or omitted will give you results, still following the resource ordering above. This could be used to list users or projects that are relevant for the requesting user&#x27;s api token.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {<&vendorExtensions.x-jsdoc-type>} resource_type The type of values the typeahead should return. You can choose from one of the following: &#x60;custom_field&#x60;, &#x60;goal&#x60;, &#x60;project&#x60;, &#x60;project_template&#x60;, &#x60;portfolio&#x60;, &#x60;tag&#x60;, &#x60;task&#x60;, &#x60;team&#x60;, and &#x60;user&#x60;. Note that unlike in the names of endpoints, the types listed here are in singular form (e.g. &#x60;task&#x60;). Using multiple types is not yet supported.
     * @param {Object} opts Optional parameters
     * @param {module:model/String} opts.type *Deprecated: new integrations should prefer the resource_type field.* (default to <.>)
     * @param {String} opts.query The string that will be used to search for relevant objects. If an empty string is passed in, the API will return results.
     * @param {Number} opts.count The number of results to return. The default is 20 if this parameter is omitted, with a minimum of 1 and a maximum of 100. If there are fewer results found than requested, all will be returned.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AsanaNamedResourceArray}
     */
  }, {
    key: "typeaheadForWorkspace",
    value: function(e, A, n) {
      return this.apiClient.RETURN_COLLECTION ? this.typeaheadForWorkspaceWithHttpInfo(e, A, n) : this.typeaheadForWorkspaceWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
  }]);
}();
var ca = {};
Object.defineProperty(ca, "__esModule", {
  value: !0
});
ca.UserTaskListsApi = void 0;
var Tv = le;
function un(r) {
  "@babel/helpers - typeof";
  return un = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, un(r);
}
function Fv(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Rv(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Nv(A.key), A);
  }
}
function Dv(r, t, e) {
  return t && Rv(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Nv(r) {
  var t = Sv(r, "string");
  return un(t) == "symbol" ? t : t + "";
}
function Sv(r, t) {
  if (un(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (un(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
ca.UserTaskListsApi = /* @__PURE__ */ function() {
  function r(t) {
    Fv(this, r), this.apiClient = t || Tv.ApiClient.instance;
  }
  return Dv(r, [{
    key: "getUserTaskListWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'user_task_list_gid' when calling getUserTaskList");
      var i = {
        user_task_list_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/user_task_lists/{user_task_list_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a user task list
     * Returns the full record for a user task list.
     * @param {<&vendorExtensions.x-jsdoc-type>} user_task_list_gid Globally unique identifier for the user task list.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/UserTaskListResponseData}
     */
  }, {
    key: "getUserTaskList",
    value: function(e, A) {
      return this.getUserTaskListWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get a user&#x27;s task list
     * Returns the full record for a user&#x27;s task list.
     * @param {String} user_gid A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {String} workspace The workspace in which to get the user task list.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getUserTaskListForUserWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = null;
      if (e == null)
        throw new Error("Missing the required parameter 'user_gid' when calling getUserTaskListForUser");
      if (A == null)
        throw new Error("Missing the required parameter 'workspace' when calling getUserTaskListForUser");
      var a = {
        user_gid: e
      }, o = {};
      n = n || {}, o = n, o.workspace = A;
      var s = {}, l = {}, c = ["personalAccessToken"], u = [], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/users/{user_gid}/user_task_list", "GET", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Get a user&#x27;s task list
     * Returns the full record for a user&#x27;s task list.
     * @param {<&vendorExtensions.x-jsdoc-type>} user_gid A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace The workspace in which to get the user task list.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/UserTaskListResponseData}
     */
  }, {
    key: "getUserTaskListForUser",
    value: function(e, A, n) {
      return this.getUserTaskListForUserWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
  }]);
}();
var la = {};
Object.defineProperty(la, "__esModule", {
  value: !0
});
la.UsersApi = void 0;
var Uv = le;
function hn(r) {
  "@babel/helpers - typeof";
  return hn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, hn(r);
}
function Pv(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Mv(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Hv(A.key), A);
  }
}
function Lv(r, t, e) {
  return t && Mv(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Hv(r) {
  var t = Gv(r, "string");
  return hn(t) == "symbol" ? t : t + "";
}
function Gv(r, t) {
  if (hn(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (hn(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var ei = de;
la.UsersApi = /* @__PURE__ */ function() {
  function r(t) {
    Pv(this, r), this.apiClient = t || Uv.ApiClient.instance;
  }
  return Lv(r, [{
    key: "getFavoritesForUserWithHttpInfo",
    value: function(e, A, n, i) {
      i = i || {};
      var a = null;
      if (e == null)
        throw new Error("Missing the required parameter 'user_gid' when calling getFavoritesForUser");
      if (A == null)
        throw new Error("Missing the required parameter 'resource_type' when calling getFavoritesForUser");
      if (n == null)
        throw new Error("Missing the required parameter 'workspace' when calling getFavoritesForUser");
      var o = {
        user_gid: e
      }, s = {};
      i = i || {}, s = i, s.resource_type = A, s.workspace = n;
      var l = {}, c = {}, u = ["personalAccessToken"], h = [], g = ["application/json; charset=UTF-8"], d = "Blob";
      return this.apiClient.RETURN_COLLECTION ? ei.fromApiClient(this.apiClient.callApi("/users/{user_gid}/favorites", "GET", o, s, l, c, a, u, h, g, d), this.apiClient, {
        path: "/users/{user_gid}/favorites",
        httpMethod: "GET",
        pathParams: o,
        queryParams: s,
        headerParams: l,
        formParams: c,
        bodyParam: a,
        authNames: u,
        contentTypes: h,
        accepts: g,
        returnType: d
      }) : this.apiClient.callApi("/users/{user_gid}/favorites", "GET", o, s, l, c, a, u, h, g, d);
    }
    /**
     * Get a user&#x27;s favorites
     * Returns all of a user&#x27;s favorites in the given workspace, of the given type. Results are given in order (The same order as Asana&#x27;s sidebar).
     * @param {<&vendorExtensions.x-jsdoc-type>} user_gid A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {<&vendorExtensions.x-jsdoc-type>} resource_type The resource type of favorites to be returned.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace The workspace in which to get favorites.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/AsanaNamedResourceArray}
     */
  }, {
    key: "getFavoritesForUser",
    value: function(e, A, n, i) {
      return this.apiClient.RETURN_COLLECTION ? this.getFavoritesForUserWithHttpInfo(e, A, n, i) : this.getFavoritesForUserWithHttpInfo(e, A, n, i).then(function(a) {
        return a.data;
      });
    }
    /**
     * Get a user
     * Returns the full user record for the single user with the provided ID.
     * @param {String} user_gid A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getUserWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'user_gid' when calling getUser");
      var i = {
        user_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/users/{user_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a user
     * Returns the full user record for the single user with the provided ID.
     * @param {<&vendorExtensions.x-jsdoc-type>} user_gid A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/UserResponseData}
     */
  }, {
    key: "getUser",
    value: function(e, A) {
      return this.getUserWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get multiple users
     * Returns the user records for all users in all workspaces and organizations accessible to the authenticated user. Accepts an optional workspace ID parameter. Results are sorted by user ID.
     * @param {Object} opts Optional parameters
     * @param {String} opts.workspace The workspace or organization ID to filter users on.
     * @param {String} opts.team The team ID to filter users on.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getUsersWithHttpInfo",
    value: function(e) {
      e = e || {};
      var A = null, n = {}, i = {};
      e = e || {}, i = e;
      var a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.RETURN_COLLECTION ? ei.fromApiClient(this.apiClient.callApi("/users", "GET", n, i, a, o, A, s, l, c, u), this.apiClient, {
        path: "/users",
        httpMethod: "GET",
        pathParams: n,
        queryParams: i,
        headerParams: a,
        formParams: o,
        bodyParam: A,
        authNames: s,
        contentTypes: l,
        accepts: c,
        returnType: u
      }) : this.apiClient.callApi("/users", "GET", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Get multiple users
     * Returns the user records for all users in all workspaces and organizations accessible to the authenticated user. Accepts an optional workspace ID parameter. Results are sorted by user ID.
     * @param {Object} opts Optional parameters
     * @param {String} opts.workspace The workspace or organization ID to filter users on.
     * @param {String} opts.team The team ID to filter users on.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/UserResponseArray}
     */
  }, {
    key: "getUsers",
    value: function(e) {
      return this.apiClient.RETURN_COLLECTION ? this.getUsersWithHttpInfo(e) : this.getUsersWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get users in a team
     * Returns the compact records for all users that are members of the team. Results are sorted alphabetically and limited to 2000. For more results use the &#x60;/users&#x60; endpoint.
     * @param {String} team_gid Globally unique identifier for the team.
     * @param {Object} opts Optional parameters
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getUsersForTeamWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'team_gid' when calling getUsersForTeam");
      var i = {
        team_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? ei.fromApiClient(this.apiClient.callApi("/teams/{team_gid}/users", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/teams/{team_gid}/users",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/teams/{team_gid}/users", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get users in a team
     * Returns the compact records for all users that are members of the team. Results are sorted alphabetically and limited to 2000. For more results use the &#x60;/users&#x60; endpoint.
     * @param {<&vendorExtensions.x-jsdoc-type>} team_gid Globally unique identifier for the team.
     * @param {Object} opts Optional parameters
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/UserResponseArray}
     */
  }, {
    key: "getUsersForTeam",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getUsersForTeamWithHttpInfo(e, A) : this.getUsersForTeamWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get users in a workspace or organization
     * Returns the compact records for all users in the specified workspace or organization. Results are sorted alphabetically and limited to 2000. For more results use the &#x60;/users&#x60; endpoint.
     * @param {String} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getUsersForWorkspaceWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling getUsersForWorkspace");
      var i = {
        workspace_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? ei.fromApiClient(this.apiClient.callApi("/workspaces/{workspace_gid}/users", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/workspaces/{workspace_gid}/users",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/workspaces/{workspace_gid}/users", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get users in a workspace or organization
     * Returns the compact records for all users in the specified workspace or organization. Results are sorted alphabetically and limited to 2000. For more results use the &#x60;/users&#x60; endpoint.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/UserResponseArray}
     */
  }, {
    key: "getUsersForWorkspace",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getUsersForWorkspaceWithHttpInfo(e, A) : this.getUsersForWorkspaceWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var ua = {};
Object.defineProperty(ua, "__esModule", {
  value: !0
});
ua.WebhooksApi = void 0;
var Wv = le;
function gn(r) {
  "@babel/helpers - typeof";
  return gn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, gn(r);
}
function Yv(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Jv(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, xv(A.key), A);
  }
}
function _v(r, t, e) {
  return t && Jv(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function xv(r) {
  var t = Ov(r, "string");
  return gn(t) == "symbol" ? t : t + "";
}
function Ov(r, t) {
  if (gn(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (gn(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var qv = de;
ua.WebhooksApi = /* @__PURE__ */ function() {
  function r(t) {
    Yv(this, r), this.apiClient = t || Wv.ApiClient.instance;
  }
  return _v(r, [{
    key: "createWebhookWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling createWebhook");
      var i = {}, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/webhooks", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Establish a webhook
     * Establishing a webhook is a two-part process. First, a simple HTTP POST request initiates the creation similar to creating any other resource.  Next, in the middle of this request comes the confirmation handshake. When a webhook is created, we will send a test POST to the target with an &#x60;X-Hook-Secret&#x60; header. The target must respond with a &#x60;200 OK&#x60; or &#x60;204 No Content&#x60; and a matching &#x60;X-Hook-Secret&#x60; header to confirm that this webhook subscription is indeed expected. We strongly recommend storing this secret to be used to verify future webhook event signatures.  The POST request to create the webhook will then return with the status of the request. If you do not acknowledge the webhooks confirmation handshake it will fail to setup, and you will receive an error in response to your attempt to create it. This means you need to be able to receive and complete the webhook *while* the POST request is in-flight (in other words, have a server that can handle requests asynchronously).  Invalid hostnames like localhost will recieve a 403 Forbidden status code.  &#x60;&#x60;&#x60; # Request curl -H \&quot;Authorization: Bearer &lt;personal_access_token&gt;\&quot; \\ -X POST https://app.asana.com/api/1.0/webhooks \\ -d \&quot;resource&#x3D;8675309\&quot; \\ -d \&quot;target&#x3D;https://example.com/receive-webhook/7654\&quot; &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60; # Handshake sent to https://example.com/ POST /receive-webhook/7654 X-Hook-Secret: b537207f20cbfa02357cf448134da559e8bd39d61597dcd5631b8012eae53e81 &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60; # Handshake response sent by example.com HTTP/1.1 200 X-Hook-Secret: b537207f20cbfa02357cf448134da559e8bd39d61597dcd5631b8012eae53e81 &#x60;&#x60;&#x60;  &#x60;&#x60;&#x60; # Response HTTP/1.1 201 {   \&quot;data\&quot;: {     \&quot;gid\&quot;: \&quot;43214\&quot;,     \&quot;resource\&quot;: {       \&quot;gid\&quot;: \&quot;8675309\&quot;,       \&quot;name\&quot;: \&quot;Bugs\&quot;     },     \&quot;target\&quot;: \&quot;https://example.com/receive-webhook/7654\&quot;,     \&quot;active\&quot;: false,     \&quot;last_success_at\&quot;: null,     \&quot;last_failure_at\&quot;: null,     \&quot;last_failure_content\&quot;: null   } } &#x60;&#x60;&#x60;
     * @param {<&vendorExtensions.x-jsdoc-type>} body The webhook workspace and target.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/WebhookResponseData}
     */
  }, {
    key: "createWebhook",
    value: function(e, A) {
      return this.createWebhookWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Delete a webhook
     * This method *permanently* removes a webhook. Note that it may be possible to receive a request that was already in flight after deleting the webhook, but no further requests will be issued.
     * @param {String} webhook_gid Globally unique identifier for the webhook.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "deleteWebhookWithHttpInfo",
    value: function(e) {
      var A = null;
      if (e == null)
        throw new Error("Missing the required parameter 'webhook_gid' when calling deleteWebhook");
      var n = {
        webhook_gid: e
      }, i = {}, a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.callApi("/webhooks/{webhook_gid}", "DELETE", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Delete a webhook
     * This method *permanently* removes a webhook. Note that it may be possible to receive a request that was already in flight after deleting the webhook, but no further requests will be issued.
     * @param {<&vendorExtensions.x-jsdoc-type>} webhook_gid Globally unique identifier for the webhook.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "deleteWebhook",
    value: function(e) {
      return this.deleteWebhookWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Get a webhook
     * Returns the full record for the given webhook.
     * @param {String} webhook_gid Globally unique identifier for the webhook.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getWebhookWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'webhook_gid' when calling getWebhook");
      var i = {
        webhook_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/webhooks/{webhook_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a webhook
     * Returns the full record for the given webhook.
     * @param {<&vendorExtensions.x-jsdoc-type>} webhook_gid Globally unique identifier for the webhook.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/WebhookResponseData}
     */
  }, {
    key: "getWebhook",
    value: function(e, A) {
      return this.getWebhookWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get multiple webhooks
     * Get the compact representation of all webhooks your app has registered for the authenticated user in the given workspace.
     * @param {String} workspace The workspace to query for webhooks in.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.resource Only return webhooks for the given resource.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getWebhooksWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'workspace' when calling getWebhooks");
      var i = {}, a = {};
      A = A || {}, a = A, a.workspace = e;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? qv.fromApiClient(this.apiClient.callApi("/webhooks", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/webhooks",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/webhooks", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get multiple webhooks
     * Get the compact representation of all webhooks your app has registered for the authenticated user in the given workspace.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace The workspace to query for webhooks in.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {String} opts.resource Only return webhooks for the given resource.
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/WebhookResponseArray}
     */
  }, {
    key: "getWebhooks",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getWebhooksWithHttpInfo(e, A) : this.getWebhooksWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Update a webhook
     * An existing webhook&#x27;s filters can be updated by making a PUT request on the URL for that webhook. Note that the webhook&#x27;s previous &#x60;filters&#x60; array will be completely overwritten by the &#x60;filters&#x60; sent in the PUT request.
     * @param {module:model/Object} body The updated filters for the webhook.
     * @param {String} webhook_gid Globally unique identifier for the webhook.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateWebhookWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling updateWebhook");
      if (A == null)
        throw new Error("Missing the required parameter 'webhook_gid' when calling updateWebhook");
      var a = {
        webhook_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/webhooks/{webhook_gid}", "PUT", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Update a webhook
     * An existing webhook&#x27;s filters can be updated by making a PUT request on the URL for that webhook. Note that the webhook&#x27;s previous &#x60;filters&#x60; array will be completely overwritten by the &#x60;filters&#x60; sent in the PUT request.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The updated filters for the webhook.
     * @param {<&vendorExtensions.x-jsdoc-type>} webhook_gid Globally unique identifier for the webhook.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/WebhookResponseData}
     */
  }, {
    key: "updateWebhook",
    value: function(e, A, n) {
      return this.updateWebhookWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
  }]);
}();
var ha = {};
Object.defineProperty(ha, "__esModule", {
  value: !0
});
ha.WorkspaceMembershipsApi = void 0;
var jv = le;
function En(r) {
  "@babel/helpers - typeof";
  return En = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, En(r);
}
function Vv(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function $v(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, Zv(A.key), A);
  }
}
function Xv(r, t, e) {
  return t && $v(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function Zv(r) {
  var t = Kv(r, "string");
  return En(t) == "symbol" ? t : t + "";
}
function Kv(r, t) {
  if (En(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (En(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var Bu = de;
ha.WorkspaceMembershipsApi = /* @__PURE__ */ function() {
  function r(t) {
    Vv(this, r), this.apiClient = t || jv.ApiClient.instance;
  }
  return Xv(r, [{
    key: "getWorkspaceMembershipWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'workspace_membership_gid' when calling getWorkspaceMembership");
      var i = {
        workspace_membership_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/workspace_memberships/{workspace_membership_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a workspace membership
     * Returns the complete workspace record for a single workspace membership.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_membership_gid 
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/WorkspaceMembershipResponseData}
     */
  }, {
    key: "getWorkspaceMembership",
    value: function(e, A) {
      return this.getWorkspaceMembershipWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get workspace memberships for a user
     * Returns the compact workspace membership records for the user.
     * @param {String} user_gid A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getWorkspaceMembershipsForUserWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'user_gid' when calling getWorkspaceMembershipsForUser");
      var i = {
        user_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? Bu.fromApiClient(this.apiClient.callApi("/users/{user_gid}/workspace_memberships", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/users/{user_gid}/workspace_memberships",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/users/{user_gid}/workspace_memberships", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get workspace memberships for a user
     * Returns the compact workspace membership records for the user.
     * @param {<&vendorExtensions.x-jsdoc-type>} user_gid A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/WorkspaceMembershipResponseArray}
     */
  }, {
    key: "getWorkspaceMembershipsForUser",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getWorkspaceMembershipsForUserWithHttpInfo(e, A) : this.getWorkspaceMembershipsForUserWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get the workspace memberships for a workspace
     * Returns the compact workspace membership records for the workspace.
     * @param {String} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {String} opts.user A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getWorkspaceMembershipsForWorkspaceWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling getWorkspaceMembershipsForWorkspace");
      var i = {
        workspace_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.RETURN_COLLECTION ? Bu.fromApiClient(this.apiClient.callApi("/workspaces/{workspace_gid}/workspace_memberships", "GET", i, a, o, s, n, l, c, u, h), this.apiClient, {
        path: "/workspaces/{workspace_gid}/workspace_memberships",
        httpMethod: "GET",
        pathParams: i,
        queryParams: a,
        headerParams: o,
        formParams: s,
        bodyParam: n,
        authNames: l,
        contentTypes: c,
        accepts: u,
        returnType: h
      }) : this.apiClient.callApi("/workspaces/{workspace_gid}/workspace_memberships", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get the workspace memberships for a workspace
     * Returns the compact workspace membership records for the workspace.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {String} opts.user A string identifying a user. This can either be the string \&quot;me\&quot;, an email, or the gid of a user.
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/WorkspaceMembershipResponseArray}
     */
  }, {
    key: "getWorkspaceMembershipsForWorkspace",
    value: function(e, A) {
      return this.apiClient.RETURN_COLLECTION ? this.getWorkspaceMembershipsForWorkspaceWithHttpInfo(e, A) : this.getWorkspaceMembershipsForWorkspaceWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
  }]);
}();
var ga = {};
Object.defineProperty(ga, "__esModule", {
  value: !0
});
ga.WorkspacesApi = void 0;
var zv = le;
function Cn(r) {
  "@babel/helpers - typeof";
  return Cn = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Cn(r);
}
function ek(r, t) {
  if (!(r instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ak(r, t) {
  for (var e = 0; e < t.length; e++) {
    var A = t[e];
    A.enumerable = A.enumerable || !1, A.configurable = !0, "value" in A && (A.writable = !0), Object.defineProperty(r, rk(A.key), A);
  }
}
function tk(r, t, e) {
  return t && Ak(r.prototype, t), Object.defineProperty(r, "prototype", { writable: !1 }), r;
}
function rk(r) {
  var t = nk(r, "string");
  return Cn(t) == "symbol" ? t : t + "";
}
function nk(r, t) {
  if (Cn(r) != "object" || !r)
    return r;
  var e = r[Symbol.toPrimitive];
  if (e !== void 0) {
    var A = e.call(r, t);
    if (Cn(A) != "object")
      return A;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return String(r);
}
var ik = de;
ga.WorkspacesApi = /* @__PURE__ */ function() {
  function r(t) {
    ek(this, r), this.apiClient = t || zv.ApiClient.instance;
  }
  return tk(r, [{
    key: "addUserForWorkspaceWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling addUserForWorkspace");
      if (A == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling addUserForWorkspace");
      var a = {
        workspace_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/workspaces/{workspace_gid}/addUser", "POST", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Add a user to a workspace or organization
     * Add a user to a workspace or organization. The user can be referenced by their globally unique user ID or their email address. Returns the full user record for the invited user.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The user to add to the workspace.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/UserBaseResponseData}
     */
  }, {
    key: "addUserForWorkspace",
    value: function(e, A, n) {
      return this.addUserForWorkspaceWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
    /**
     * Get a workspace
     * Returns the full workspace record for a single workspace.
     * @param {String} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getWorkspaceWithHttpInfo",
    value: function(e, A) {
      A = A || {};
      var n = null;
      if (e == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling getWorkspace");
      var i = {
        workspace_gid: e
      }, a = {};
      A = A || {}, a = A;
      var o = {}, s = {}, l = ["personalAccessToken"], c = [], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/workspaces/{workspace_gid}", "GET", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Get a workspace
     * Returns the full workspace record for a single workspace.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/WorkspaceResponseData}
     */
  }, {
    key: "getWorkspace",
    value: function(e, A) {
      return this.getWorkspaceWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Get multiple workspaces
     * Returns the compact records for all workspaces visible to the authorized user.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "getWorkspacesWithHttpInfo",
    value: function(e) {
      e = e || {};
      var A = null, n = {}, i = {};
      e = e || {}, i = e;
      var a = {}, o = {}, s = ["personalAccessToken"], l = [], c = ["application/json; charset=UTF-8"], u = "Blob";
      return this.apiClient.RETURN_COLLECTION ? ik.fromApiClient(this.apiClient.callApi("/workspaces", "GET", n, i, a, o, A, s, l, c, u), this.apiClient, {
        path: "/workspaces",
        httpMethod: "GET",
        pathParams: n,
        queryParams: i,
        headerParams: a,
        formParams: o,
        bodyParam: A,
        authNames: s,
        contentTypes: l,
        accepts: c,
        returnType: u
      }) : this.apiClient.callApi("/workspaces", "GET", n, i, a, o, A, s, l, c, u);
    }
    /**
     * Get multiple workspaces
     * Returns the compact records for all workspaces visible to the authorized user.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.limit Results per page. The number of objects to return per page. The value must be between 1 and 100.
     * @param {String} opts.offset Offset token. An offset to the next page returned by the API. A pagination request will return an offset token, which can be used as an input parameter to the next request. If an offset is not passed in, the API will return the first page of results. &#x27;Note: You can only pass in an offset that was returned to you via a previously paginated request.&#x27;
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/WorkspaceResponseArray}
     */
  }, {
    key: "getWorkspaces",
    value: function(e) {
      return this.apiClient.RETURN_COLLECTION ? this.getWorkspacesWithHttpInfo(e) : this.getWorkspacesWithHttpInfo(e).then(function(A) {
        return A.data;
      });
    }
    /**
     * Remove a user from a workspace or organization
     * Remove a user from a workspace or organization. The user making this call must be an admin in the workspace. The user can be referenced by their globally unique user ID or their email address. Returns an empty data record.
     * @param {module:model/Object} body The user to remove from the workspace.
     * @param {String} workspace_gid Globally unique identifier for the workspace or organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "removeUserForWorkspaceWithHttpInfo",
    value: function(e, A) {
      var n = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling removeUserForWorkspace");
      if (A == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling removeUserForWorkspace");
      var i = {
        workspace_gid: A
      }, a = {}, o = {}, s = {}, l = ["personalAccessToken"], c = ["application/json; charset=UTF-8"], u = ["application/json; charset=UTF-8"], h = "Blob";
      return this.apiClient.callApi("/workspaces/{workspace_gid}/removeUser", "POST", i, a, o, s, n, l, c, u, h);
    }
    /**
     * Remove a user from a workspace or organization
     * Remove a user from a workspace or organization. The user making this call must be an admin in the workspace. The user can be referenced by their globally unique user ID or their email address. Returns an empty data record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The user to remove from the workspace.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/EmptyResponseData}
     */
  }, {
    key: "removeUserForWorkspace",
    value: function(e, A) {
      return this.removeUserForWorkspaceWithHttpInfo(e, A).then(function(n) {
        return n.data;
      });
    }
    /**
     * Update a workspace
     * A specific, existing workspace can be updated by making a PUT request on the URL for that workspace. Only the fields provided in the data block will be updated; any unspecified fields will remain unchanged. Currently the only field that can be modified for a workspace is its name. Returns the complete, updated workspace record.
     * @param {module:model/Object} body The workspace object with all updated properties.
     * @param {String} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with an object containing data and HTTP response
     */
  }, {
    key: "updateWorkspaceWithHttpInfo",
    value: function(e, A, n) {
      n = n || {};
      var i = e;
      if (e == null)
        throw new Error("Missing the required parameter 'body' when calling updateWorkspace");
      if (A == null)
        throw new Error("Missing the required parameter 'workspace_gid' when calling updateWorkspace");
      var a = {
        workspace_gid: A
      }, o = {};
      n = n || {}, o = n;
      var s = {}, l = {}, c = ["personalAccessToken"], u = ["application/json; charset=UTF-8"], h = ["application/json; charset=UTF-8"], g = "Blob";
      return this.apiClient.callApi("/workspaces/{workspace_gid}", "PUT", a, o, s, l, i, c, u, h, g);
    }
    /**
     * Update a workspace
     * A specific, existing workspace can be updated by making a PUT request on the URL for that workspace. Only the fields provided in the data block will be updated; any unspecified fields will remain unchanged. Currently the only field that can be modified for a workspace is its name. Returns the complete, updated workspace record.
     * @param {<&vendorExtensions.x-jsdoc-type>} body The workspace object with all updated properties.
     * @param {<&vendorExtensions.x-jsdoc-type>} workspace_gid Globally unique identifier for the workspace or organization.
     * @param {Object} opts Optional parameters
     * @param {Array.<module:model/String>} opts.opt_fields This endpoint returns a compact resource, which excludes some properties by default. To include those optional properties, set this query parameter to a comma-separated list of the properties you wish to include.
     * @return {Promise} a {@link https://www.promisejs.org/|Promise}, with data of type {@link module:model/WorkspaceResponseData}
     */
  }, {
    key: "updateWorkspace",
    value: function(e, A, n) {
      return this.updateWorkspaceWithHttpInfo(e, A, n).then(function(i) {
        return i.data;
      });
    }
  }]);
}();
(function(r) {
  Object.defineProperty(r, "__esModule", {
    value: !0
  }), Object.defineProperty(r, "AllocationsApi", {
    enumerable: !0,
    get: function() {
      return e.AllocationsApi;
    }
  }), Object.defineProperty(r, "ApiClient", {
    enumerable: !0,
    get: function() {
      return t.ApiClient;
    }
  }), Object.defineProperty(r, "AttachmentsApi", {
    enumerable: !0,
    get: function() {
      return A.AttachmentsApi;
    }
  }), Object.defineProperty(r, "AuditLogAPIApi", {
    enumerable: !0,
    get: function() {
      return n.AuditLogAPIApi;
    }
  }), Object.defineProperty(r, "BatchAPIApi", {
    enumerable: !0,
    get: function() {
      return i.BatchAPIApi;
    }
  }), Object.defineProperty(r, "CustomFieldSettingsApi", {
    enumerable: !0,
    get: function() {
      return a.CustomFieldSettingsApi;
    }
  }), Object.defineProperty(r, "CustomFieldsApi", {
    enumerable: !0,
    get: function() {
      return o.CustomFieldsApi;
    }
  }), Object.defineProperty(r, "EventsApi", {
    enumerable: !0,
    get: function() {
      return s.EventsApi;
    }
  }), Object.defineProperty(r, "GoalRelationshipsApi", {
    enumerable: !0,
    get: function() {
      return l.GoalRelationshipsApi;
    }
  }), Object.defineProperty(r, "GoalsApi", {
    enumerable: !0,
    get: function() {
      return c.GoalsApi;
    }
  }), Object.defineProperty(r, "JobsApi", {
    enumerable: !0,
    get: function() {
      return u.JobsApi;
    }
  }), Object.defineProperty(r, "MembershipsApi", {
    enumerable: !0,
    get: function() {
      return h.MembershipsApi;
    }
  }), Object.defineProperty(r, "OrganizationExportsApi", {
    enumerable: !0,
    get: function() {
      return g.OrganizationExportsApi;
    }
  }), Object.defineProperty(r, "PortfolioMembershipsApi", {
    enumerable: !0,
    get: function() {
      return d.PortfolioMembershipsApi;
    }
  }), Object.defineProperty(r, "PortfoliosApi", {
    enumerable: !0,
    get: function() {
      return I.PortfoliosApi;
    }
  }), Object.defineProperty(r, "ProjectBriefsApi", {
    enumerable: !0,
    get: function() {
      return y.ProjectBriefsApi;
    }
  }), Object.defineProperty(r, "ProjectMembershipsApi", {
    enumerable: !0,
    get: function() {
      return Q.ProjectMembershipsApi;
    }
  }), Object.defineProperty(r, "ProjectStatusesApi", {
    enumerable: !0,
    get: function() {
      return E.ProjectStatusesApi;
    }
  }), Object.defineProperty(r, "ProjectTemplatesApi", {
    enumerable: !0,
    get: function() {
      return B.ProjectTemplatesApi;
    }
  }), Object.defineProperty(r, "ProjectsApi", {
    enumerable: !0,
    get: function() {
      return w.ProjectsApi;
    }
  }), Object.defineProperty(r, "RulesApi", {
    enumerable: !0,
    get: function() {
      return C.RulesApi;
    }
  }), Object.defineProperty(r, "SectionsApi", {
    enumerable: !0,
    get: function() {
      return f.SectionsApi;
    }
  }), Object.defineProperty(r, "StatusUpdatesApi", {
    enumerable: !0,
    get: function() {
      return p.StatusUpdatesApi;
    }
  }), Object.defineProperty(r, "StoriesApi", {
    enumerable: !0,
    get: function() {
      return m.StoriesApi;
    }
  }), Object.defineProperty(r, "TagsApi", {
    enumerable: !0,
    get: function() {
      return R.TagsApi;
    }
  }), Object.defineProperty(r, "TaskTemplatesApi", {
    enumerable: !0,
    get: function() {
      return P.TaskTemplatesApi;
    }
  }), Object.defineProperty(r, "TasksApi", {
    enumerable: !0,
    get: function() {
      return N.TasksApi;
    }
  }), Object.defineProperty(r, "TeamMembershipsApi", {
    enumerable: !0,
    get: function() {
      return $.TeamMembershipsApi;
    }
  }), Object.defineProperty(r, "TeamsApi", {
    enumerable: !0,
    get: function() {
      return V.TeamsApi;
    }
  }), Object.defineProperty(r, "TimePeriodsApi", {
    enumerable: !0,
    get: function() {
      return ne.TimePeriodsApi;
    }
  }), Object.defineProperty(r, "TimeTrackingEntriesApi", {
    enumerable: !0,
    get: function() {
      return _.TimeTrackingEntriesApi;
    }
  }), Object.defineProperty(r, "TypeaheadApi", {
    enumerable: !0,
    get: function() {
      return X.TypeaheadApi;
    }
  }), Object.defineProperty(r, "UserTaskListsApi", {
    enumerable: !0,
    get: function() {
      return te.UserTaskListsApi;
    }
  }), Object.defineProperty(r, "UsersApi", {
    enumerable: !0,
    get: function() {
      return ee.UsersApi;
    }
  }), Object.defineProperty(r, "WebhooksApi", {
    enumerable: !0,
    get: function() {
      return Z.WebhooksApi;
    }
  }), Object.defineProperty(r, "WorkspaceMembershipsApi", {
    enumerable: !0,
    get: function() {
      return b.WorkspaceMembershipsApi;
    }
  }), Object.defineProperty(r, "WorkspacesApi", {
    enumerable: !0,
    get: function() {
      return W.WorkspacesApi;
    }
  });
  var t = le, e = Ni, A = Si, n = Ui, i = Pi, a = Mi, o = Li, s = Hi, l = Gi, c = Wi, u = Yi, h = Ji, g = _i, d = xi, I = Oi, y = qi, Q = ji, E = Vi, B = $i, w = Xi, C = Zi, f = Ki, p = zi, m = ea, R = Aa, P = ta, N = ra, $ = na, V = ia, ne = aa, _ = oa, X = sa, te = ca, ee = la, Z = ua, b = ha, W = ga;
})(oi);
class ak {
  constructor(t, e) {
    Wt(this, "client");
    Wt(this, "tasksApiInstance");
    Wt(this, "sectionsApiInstance");
    Wt(this, "workspaceId");
    this.client = oi.ApiClient.instance;
    let A = this.client.authentications.token;
    A.accessToken = t, this.tasksApiInstance = new oi.TasksApi(), this.sectionsApiInstance = new oi.SectionsApi(), this.workspaceId = e;
  }
  async getTask(t) {
    const e = {};
    try {
      const A = await this.tasksApiInstance.getTask(t, e);
      return console.log("Asana task found", A.data), A.data;
    } catch (A) {
      throw console.error("Error:", A.response.body), new Error("Failed to retrieve task: " + A.message);
    }
  }
  async getProjectSections(t) {
    const e = {};
    try {
      const A = await this.sectionsApiInstance.getSectionsForProject(
        t,
        e
      );
      return console.log(
        "API called successfully. Returned project data: " + JSON.stringify(A.data, null, 2)
      ), A.data;
    } catch (A) {
      throw console.error("Error:", A.response.body), new Error("Failed to retrieve project sections: " + A.message);
    }
  }
  async updateTaskSection({ task_gid: t, sectionName: e }) {
    const A = await this.getTask(t), n = this.getFirstDevProjectGid(A), i = A.memberships.find(
      (a) => a.project.gid === n
    );
    if (console.log("active project: ", i), i && i.section.name !== e) {
      const a = await this.getProjectSections(n), o = this.getSectionGid({
        name: e,
        sections: a
      });
      o && await this.setTaskSection(t, n, o);
    }
  }
  async setTaskSection(t, e, A) {
    const n = {}, i = {
      data: {
        project: e,
        section: A
      }
    };
    try {
      const a = await this.tasksApiInstance.addProjectForTask(
        i,
        t,
        n
      );
      console.log(
        "API called successfully. Returned data: " + JSON.stringify(a.data, null, 2)
      );
    } catch (a) {
      throw console.error("Error:", a.response.body), new Error("Failed to update task: " + a.message);
    }
  }
  getFirstDevProjectGid(t) {
    const e = t.projects.filter((A) => A.name.startsWith("DEV v")).shift();
    return console.log("Current project: ", e), e ? e.gid : "";
  }
  getSectionGid({ name: t, sections: e }) {
    console.log("Sections: ", e);
    const A = e.find(
      (n) => n.name.startsWith(t)
    );
    return A ? A.gid : "";
  }
  async getGidFromCustomId(t) {
    try {
      const e = await this.tasksApiInstance.getTaskForCustomID(
        this.workspaceId,
        t
      );
      return console.log("Asana task found", e.data), e.data.gid;
    } catch (e) {
      throw console.error("Error:", e.response.body), new Error("Failed to retrieve task: " + e.message);
    }
  }
  async getIdFromBranch(t) {
    var n;
    const A = (n = t.toLowerCase().split("/").find((i) => i.startsWith("dev-"))) == null ? void 0 : n.toUpperCase();
    return A ? await this.getGidFromCustomId(A) : null;
  }
  async getIdsFromCommit(t) {
    const e = [], A = t.match(/app\.asana\.com\/[^\s]+/g);
    if (A) {
      const a = A.map((o) => {
        const s = o.match(/\/(\d+)(?:\/f)?$/);
        return s ? s[1] : null;
      }).filter((o) => o !== null);
      e.push(...a);
    }
    const n = /\bdev-\d+\b/gi, i = t.match(n);
    if (i) {
      const a = i.map((o) => o.toUpperCase());
      for (const o of a) {
        const s = await this.getGidFromCustomId(o);
        s && e.push(s);
      }
    }
    return e;
  }
  async searchForTicketIds({
    branch: t,
    commit: e
  }) {
    const A = [], n = await this.getIdFromBranch(t);
    n && A.push(n);
    const i = await this.getIdsFromCommit(e);
    return A.push(...i), Array.from(new Set(A));
  }
  async parseBranchAndCommit({
    branch: t,
    commit: e
  }) {
    return await this.searchForTicketIds({ branch: t, commit: e });
  }
  async taskInProgress(t) {
    await this.updateTaskSection({ task_gid: t, sectionName: "In progress" });
  }
  async taskToCodeReview(t) {
    await this.updateTaskSection({ task_gid: t, sectionName: "Code review" });
  }
  async taskComplete(t) {
    await this.updateTaskSection({ task_gid: t, sectionName: "Done" });
  }
}
async function ok() {
  try {
    const r = jt.getInput("asana-access-token"), t = jt.getInput("asana-workspace-id"), e = jt.getInput("branch"), A = jt.getInput("commit"), n = jt.getInput("ticket-action"), i = new ak(r, t), a = {
      branch: e,
      commit: A
    };
    (await i.parseBranchAndCommit(a)).forEach((s) => {
      n === "in progress" && i.taskInProgress(s), n === "code review" && i.taskToCodeReview(s), n === "complete" && i.taskComplete(s);
    });
  } catch (r) {
    jt.setFailed(r.message);
  }
}
ok();
